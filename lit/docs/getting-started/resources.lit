\title{Resources}{tutorial-resources}

\use-plugin{concourse-docs}

\section{
  \title{The Heart of Concourse}

  Resources are the heart of Concourse. Resources make Concourse tick and are
  the source of automation within all Concourse pipelines. Resources are how
  Concourse interacts with the outside world. Here's a short list of some
  things that resources can do:

  \list{
      You want something to run every five minutes? \link{Time resource}{https://github.com/concourse/time-resource/}.
  }{
      You want to run tests on every new commit to the main branch? \link{Git resource}{https://github.com/concourse/git-resource}.
  }{
      Run unit tests on new PR's? \link{Github-PR resource}{https://github.com/telia-oss/github-pr-resource}.
  }{
      Fetch or push the latest image of your app? \link{Registry-image resource}{https://github.com/concourse/registry-image-resource/}
  }

  Resources can do a lot of things! The main goal of resources is to
  represent some external system or object in your pipeline. That external
  thing can then be used as a trigger for your \reference{jobs} or your
  \reference{jobs} can push back and modify the external system or object. It
  all depends on the resource you use and what features its author has
  implemented.

  Resources are also how Concourse tries to stay as technology agnostic as
  possible. For example, Concourse doesn't care what \link{version control
  system}{https://en.wikipedia.org/wiki/Version_control} you store your code
  in, if you deploy apps with \link{Helm}{https://helm.sh/} or
  \link{Terraform}{https://www.terraform.io/}, or what language your apps are
  built in.  If you can put your latest and hottest tech behind the resource
  interface then Concourse can understand your workflow.

  The Concourse team bundles a few basic resource types that come with the
  Linux tarball you can \link{download from
  Github}{https://github.com/concourse/concourse/releases}. You'll notice
  that the Linux tarball is much larger than the macOS or Windows tarball
  because of all the bundled resources.

  \aside{
      You can find out which resources a worker has by running:
      \codeblock{}{{
      $ fly -t tutorial workers --details
      }}
  }

  Resources only run on Linux workers because resources are distributed as
  Linux container images. There are currently no resources for macOS or
  Windows. Only \reference{task-step}{task steps} can run on macOS or Windows
  workers.
}

\section{
  \title{Versions}

  Resources represent the external system or object to Concourse by emitting
  \reference{schema.version}{\code{versions}}. When a new version is emitted
  by a resource, that is how Concourse knows to start trigger jobs.

  A version is any way that a resource can uniquely identify the state of the
  external system or object.

  For example, the git resource emits versions based on the SHA of new commits
  it finds. A single version from the git resource will look like this to
  Concourse.

  \codeblock{json}{{{
  { "ref": "04194bfc880c457a5b00f07db78d0532620414cc" }
  }}}

  Let's start digging into resources a bit more by going over the resource interface.
}

\section{
  \title{Resource Interface}

  Resources are \link{container
  images}{https://en.wikipedia.org/wiki/List_of_Linux_containers} that contain
  three executables. Each executable is run by a different type of
  \reference{steps}{step} within a pipeline:

  \list{
      \code{/opt/resource/check} - implicitly ran when a
      \reference{jobs}{job} contains a \reference{get-step}{get step}.
      Should return the latest version from the external system or object.
      Its responsibility is to find new versions.
  }{
      \code{/opt/resource/in} - run in a \reference{get-step}{get step}.
      \code{in} is given a specific version (generated by a \code{check} or
      \reference{put-step}{\code{put} step}) and retrieves the files
      representing that version from the external system or object.
  }{
      \code{/opt/resource/out} - run in a \reference{put-step}{put step}.
      Generates a new version, usually based on some input generated by
      another step in the job. Depending on the resource, this may mean
      sending something to the external system. For the git resource, this
      means pushing commits to the external git repository.
  }

  That's a high-level overview of the resource interface. Next, we will learn
  how to add resources to a pipeline.
}

\section{
  \title{Get Steps}

  Let's add some automation to our \code{hello-world.yml} pipeline and have
  it \bold{trigger on every new commit from some git repo}. We will use the \link{git
  resource}{https://github.com/concourse/git-resource/} to accomplish this.

  Before proceeding, please have a git repository ready that you can push code
  to. The rest of the tutorial will point to
  \link{\code{github.com/concourse/examples}}{https://github.com/concourse/examples}
  which you should replace with your own repository or your own fork of
  \code{concourse/examples}.

  To start, let's go back to the one step version of the pipeline.

  \codeblock{yaml}{{
  jobs:
  - name: hello-world-job
    plan:
    - task: hello-world-task
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: busybox
        run:
          path: echo
          args: ["Hello World!"]
  }}

  Now let's add the \link{git
  resource}{https://github.com/concourse/git-resource/} to the pipeline. First
  we'll add the \reference{resources}{\code{resources}} key to the top-level of
  our yaml.

  \codeblock{yaml}{{
  resources:

  jobs:
  - name: hello-world-job
    plan:
    - task: hello-world-task
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: busybox
        run:
          path: echo
          args: ["Hello World!"]
  }}

  The \reference{resources}{\code{resources}} key takes a list of resources.
  In our case, we're going to add one item to that list. We will name the
  resource \code{repo}. This is the name we'll use to refer to this
  specific instance of the resource within our pipeline. We'll define the
  \reference{schema.resource.type}{\code{type}} as \code{git}, which we got
  from the output of \code{fly -t tutorial workers --details}.

  \codeblock{yaml}{{
  resources:
  - name: repo
    type: git

  jobs:
  - name: hello-world-job
    plan:
    - task: hello-world-task
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: busybox
        run:
          path: echo
          args: ["Hello World!"]
  }}

  There is one last field we need to fill out, the
  \reference{schema.resource.source}{\code{source}} field.

  The \code{source} field contains the configuration for the resource. By
  convention, documentation for each resource's configuration is found in
  the \code{README} of its git repository. The \code{source} field will be
  different for every resource type, so you'll need to refer to that resource's
  documentation to determine how to fill out the \code{source} field.

  If we look at the \link{\code{README} for the git
  resource}{https://github.com/concourse/git-resource/#source-configuration}
  we'll find that it requires we set the \code{uri} field. This should point to
  the location of the git repository. We can specify it in \code{https://} or
  \code{ssh@} format.  Let's add the \code{uri} field and set it to your
  repository.

  \aside{
    If you use the \code{ssh@} format for the \code{uri} then you'll likely
    need to set the \code{private_key} field as well.

    If you use the \code{https://} format and your repo is public then you
    don't need to set anything else. If you repository is private then you'll
    need to set the \code{username} and \code{password} fields to allow the git
    resource to authenticate. \code{private_key} can also be used for
    \code{https://} uri's.
  }

  \codeblock{yaml}{{
  resources:
  - name: repo
    type: git
    source:
      uri: https://github.com/concourse/examples.git

  jobs:
  - name: hello-world-job
    plan:
    - task: hello-world-task
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: busybox
        run:
          path: echo
          args: ["Hello World!"]
  }}

  Next we need to connect the \code{repo} resource to the
  \code{hello-world-job}. We connect the two objects by adding a
  \reference{get-step}{get step} to the job.

  \codeblock{yaml}{{
  resources:
  - name: repo
    type: git
    source:
      uri: https://github.com/concourse/examples.git

  jobs:
  - name: hello-world-job
    plan:
    # Add a get step referencing the resource
    - get: repo
    - task: hello-world-task
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: busybox
        run:
          path: echo
          args: ["Hello World!"]
  }}

  The final piece is telling Concourse to trigger the \code{hello-world-job}
  whenever the \code{repo} resource emits a new version. We can do that
  by setting \reference{schema.step.get-step.trigger}{\code{trigger}} to
  \code{true} for the \reference{get-step}{get step}.

  \codeblock{yaml}{{
  resources:
  - name: repo
    type: git
    source:
      uri: https://github.com/concourse/examples.git

  jobs:
  - name: hello-world-job
    plan:
    - get: repo
      trigger: true   # tell Concourse to trigger this job when new versions are emitted
    - task: hello-world-task
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: busybox
        run:
          path: echo
          args: ["Hello World!"]
  }}

  Let's set our pipeline and watch it automatically trigger from the
  \link{web UI}{http://localhost:8080/teams/main/pipelines/hello-world}.

  \codeblock{}{{
  $ fly -t tutorial set-pipeline -p hello-world -c hello-world.yml
  }}

  \image{images/tutorial/hello-world-trigger-job.png}

  If you \link{click the
  resource}{http://localhost:8080/teams/main/pipelines/hello-world/resources/repo}
  you'll see a list of the versions that it has emitted so far. You can expand
  each version to see which build it was used in and some metadata if the
  resource fetched any. Metadata is only populated after a version is fetched
  by a \reference{get-step}.

  By default, resources will only fetch the most recent version available. At
  this point you can make commits to your repo and watch Concourse find them
  and trigger the job. If you want to populate the version history with older
  versions you can use \reference{fly-check-resource} with the \code{--from}
  flag.
}

\section{
  \title{Get Steps and Inputs}

  Let's tie together two concepts that we've learned so far.
  \reference{get-step}{Get steps} and \reference{schema.task.inputs}{task
  inputs}.

  In the previous section we learned that \reference{task-step}{task steps} can
  specify \reference{schema.task.outputs}{outputs} that other
  \reference{task-step}{task steps} can then consume as
  \reference{schema.task.inputs}{inputs}. \reference{get-step}{Get steps}
  generate one output that can then be consumed by tasks as an
  \reference{schema.task.inputs}{input}. \reference{get-step}{Get steps}
  always generate output artifacts based on their name.

  To find out the structure of the artifact generated by a \reference{get-step}
  you will have to refer to the resource's documentation. The documentation for
  the \link{git
  resource}{https://github.com/concourse/git-resource#in-clone-the-repository-at-the-given-ref}
  tells us that the \code{in} script will clone the git repository.

  Let's add \code{repo} as an input to the \code{hello-world-task}. Let's also
  update the command the task runs to instead print the contents of some file
  in the \code{repo}.

  \codeblock{yaml}{{
  resources:
  - name: repo
    type: git
    source:
      uri: https://github.com/concourse/examples.git

  jobs:
  - name: hello-world-job
    plan:
    - get: repo
      trigger: true
    - task: hello-world-task
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: busybox
        inputs: # add the get step as an input to this task
        - name: repo
        run: # read the file from the get step
          path: cat
          args: ["repo/README.md"]
  }}

  Set the pipeline and we'll manually trigger the job.

  \codeblock{}{{{
  $ fly -t tutorial set-pipeline -p hello-world -c hello-world.yml
  $ fly -t tutorial trigger-job --job hello-world/hello-world-job --watch
  started hello-world/hello-world-job #44

  initializing
  selected worker: d032d4471e67
  running cat repo/README.md
  # examples
  Examples of Concourse workflows
  succeeded
  }}}

  The job should finish successfully and print out the contents of
  \code{repo/README.md} or whichever file you selected from your repo.
}

\section{
  \title{Checks}

  Checks are how Concourse finds new versions of resources.  In order to find
  any new versions Concourse has to run the \code{check} scripts for all
  resources across all pipelines. By default, all resources have a
  \reference{schema.resource.check_every}{\code{check_every} interval} of one
  minute.

  The default \code{check_every} interval helps keep Concourse feeling snappy
  and responsive to changes in external systems. The negative side-effect of
  this is that if you have a lot of resources all hitting the same system (e.g.
  an internal Git system) you may end up
  \link{DDOS'ing}{https://en.wikipedia.org/wiki/Denial-of-service_attack} your
  external system! In these cases you may want to increase the
  \code{check_every} interval of your resource or disable it and use
  \reference{schema.resource.webhook_token}{webhooks} instead.

  To see the results of the last check that ran, go to the \link{resource's
  page in the
  pipeline}{http://localhost:8080/teams/main/pipelines/hello-world/resources/every-1min}
  and expand the top line that starts with \code{check: <resource-name>}.

  \image{images/tutorial/view-check-status.png}

  If your resource is having trouble finding new versions or is configured
  incorrectly the resource will print a message that will be visible on its
  resource page for you to debug.

  You can also use \code{fly} to view the status by running \code{fly builds}
  and filtering for \code{check}'s to see the result of the last check.

  \codeblock{}{{
  $ fly -t tutorial builds | grep check
  id   name                    status     start
  106  hello-world/repo/check  succeeded  2021-04-10@12:00:20-0400
  }}
}

\section{
  \title{Put Steps}

  The last piece of the resource interface is \reference{put-step}{put steps}.
  Put steps are generally for pushing some change to the external system or
  object the resource represents. What this means will vary by resource, so
  again, you should carefully read the documentation for the specific resource
  you are using. Each resource is basically its own little application.

  In order to "put" something, in the context of the \link{git
  resource}{https://github.com/concourse/git-resource}, we'll need to make a
  commit that can then be "put" to the repo.

  \aside{
    If you haven't already, you'll probably need to provide the git resource
    with your \code{private_key} or a \code{username} and \code{password},
    depending on the format of \code{uri} you provided.

    If you're used to pushing code from your computer you probably have a
    private key in your \code{~/.ssh/} directory that you can use.
  }


  \codeblock{yaml}{{
  resources:
  - name: repo
    type: git
    source:
      # changed uri to ssh format
      uri: git@github.com:concourse/examples.git
      private_key: |
      -----BEGIN OPENSSH PRIVATE KEY-----
      ...
      -----END OPENSSH PRIVATE KEY-----

  jobs:
  - name: hello-world-job
    plan:
    - get: repo
      trigger: true
    - task: hello-world-task
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: busybox
        inputs:
        - name: repo
        run:
          path: cat
          args: ["repo/README.md"]
  }}

  Next let's change the \code{hello-world-task} to instead create a commit.

  \codeblock{yaml}{{
  resources:
  - name: repo
    type: git
    source:
      uri: git@github.com:concourse/examples.git
      private_key: |
      -----BEGIN OPENSSH PRIVATE KEY-----
      ...
      -----END OPENSSH PRIVATE KEY-----

  jobs:
  - name: hello-world-job
    plan:
    - get: repo
      trigger: true
    - task: create-commit # renamed task
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: gitea/gitea # use any image that has the git cli
        inputs:
        - name: repo
        run:
          path: sh
          args:
          - -cx
          # this is just a bash script
          - |
            cd repo
            date +%Y-%m-%d > todays-date
            git add ./todays-date
            git commit -m "Update todays date"
  }}

  Lastly we can add a \reference{put-step} to push the commit made by the task.
  \reference{put-step}{Put steps} usually have various \code{params} that
  you'll need to set in order run the step correctly. If we read the
  \link{documentation for the git
  resource}{https://github.com/concourse/git-resource#out-push-to-a-repository}
  we'll see that we need to specify \code{repository} field.

  \aside{
    If you're wondering why we don't do \code{git push} from the task, that's
    for two reasons:
    \ordered-list{
      The newly made commit represents a new version and Concourse won't
      capture it correctly if it's pushed from the task, which is outside of
      the resource interface (check, get, put).
    }{
      The \code{private_key} is not available in the task so you would get an
      authentication error if you \code{git push}ed.
    }
  }

  \codeblock{yaml}{{
  resources:
  - name: repo
    type: git
    source:
      uri: git@github.com:concourse/examples.git
      private_key: |
      -----BEGIN OPENSSH PRIVATE KEY-----
      ...
      -----END OPENSSH PRIVATE KEY-----

  jobs:
  - name: hello-world-job
    plan:
    - get: repo
      trigger: true
    - task: create-commit
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: gitea/gitea
        inputs:
        - name: repo
        run:
          path: sh
          args:
          - -cx
          - |
            cd repo
            date +%Y-%m-%d > todays-date
            git add ./todays-date
            git commit -m "Update todays date"
    - put: repo
      params:
        repository: repo
  }}

  Set the pipeline and let's watch it trigger and run from the \link{web
  UI}{http://localhost:8080/teams/main/pipelines/hello-world}.

  \codeblock{}{{
  $ fly -t tutorial set-pipeline -p hello-world -c hello-world.yml
  }}

  The job now has the \code{repo} resource to the left and right of the
  \code{hello-world-job}. This is how Concourse visually represents the inputs
  (\reference{get-step}{get steps}) and outputs (\reference{put-step}{put
  steps}) of a job.

  That covers the basics of resources. It is best of think of each resource as
  a little application, so carefully read any documentation the resource author
  has provided. Every resource behaves a little differently based on the
  external system it is representing.
}

\section{
  \title{Using External Resource Types}
  Concourse comes bundled with a lot of resources that are enough for most
  people to start using Concourse with. However, users will want to extend
  Concourse to work with all sorts of systems and that means bringing your own
  \reference{resource-types}.

  Adding a \reference{resource-types}{resource type} to your pipeline looks
  very similar to adding a resource. You can even override the bundled resource
  types by re-declaring them in your pipeline.

  Remember, a resource is a container image. So to pull in a new resource type
  you need to tell Concourse \italic{where} to pull the image from. This is
  done by using the built-in \link{registry-image
  resource}{https://github.com/concourse/registry-image-resource/}. The process
  of adding a resource type is just like adding a regular resource.

  Here's an example of using an external resource type to read an \link{rss
  feed}{https://github.com/suhlig/concourse-rss-resource}.

  \codeblock{yaml}{{
  resource_types:
  # declare the new resource type
  - name: rss
    type: registry-image
    source:
      repository: suhlig/concourse-rss-resource
      tag: latest

  resources:
  # use the resource as usual
  - name: dino-feed
    type: rss
    source:
      url: http://www.qwantz.com/rssfeed.php

  jobs:
  - name: announce
    plan:
    - get: dino-feed
      trigger: true
  }}

  That's how you add external resource types to your pipeline. If you're
  looking for more resource types there's a catalog of them at
  \link{resource-types.concourse-ci.org}{https://resource-types.concourse-ci.org/}.
}

\section{
  \title{Time For Takeoff ✈️}{time-to-takeoff}

  This brings us to the end of the tutorial. You should have a basic
  understanding about how to read Concourse pipelines and start creating your
  own. Here are some other parts of the site to help you take off with Concourse:

  \list{
    \reference{how-to-guides} - Contains tips for writing pipelines and examples of common pipeline workflows
  }{
    Check out all the reference documentation:
    \list{\reference{jobs}}{\reference{tasks}}{\reference{resources}}{\reference{resource-types}}
  }{
    \reference{implementing-resource-types}{Implement your own resource type}
  }{
    Find other resources at
    \link{resource-types.concourse-ci.org}{https://resource-types.concourse-ci.org/}
    or put \code{\italic{something} concourse resource} into your favorite
    search engine.
  }

  Best of luck on your automation journey!
}
