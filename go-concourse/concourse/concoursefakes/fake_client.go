// Code generated by counterfeiter. DO NOT EDIT.
package concoursefakes

import (
	"io"
	"net/http"
	"sync"
	"time"

	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/go-concourse/concourse"
)

type FakeClient struct {
	AbortBuildStub        func(string) error
	abortBuildMutex       sync.RWMutex
	abortBuildArgsForCall []struct {
		arg1 string
	}
	abortBuildReturns struct {
		result1 error
	}
	abortBuildReturnsOnCall map[int]struct {
		result1 error
	}
	BuildStub        func(string) (atc.Build, bool, error)
	buildMutex       sync.RWMutex
	buildArgsForCall []struct {
		arg1 string
	}
	buildReturns struct {
		result1 atc.Build
		result2 bool
		result3 error
	}
	buildReturnsOnCall map[int]struct {
		result1 atc.Build
		result2 bool
		result3 error
	}
	BuildEventsStub        func(string) (concourse.Events, error)
	buildEventsMutex       sync.RWMutex
	buildEventsArgsForCall []struct {
		arg1 string
	}
	buildEventsReturns struct {
		result1 concourse.Events
		result2 error
	}
	buildEventsReturnsOnCall map[int]struct {
		result1 concourse.Events
		result2 error
	}
	BuildPlanStub        func(int) (atc.PublicBuildPlan, bool, error)
	buildPlanMutex       sync.RWMutex
	buildPlanArgsForCall []struct {
		arg1 int
	}
	buildPlanReturns struct {
		result1 atc.PublicBuildPlan
		result2 bool
		result3 error
	}
	buildPlanReturnsOnCall map[int]struct {
		result1 atc.PublicBuildPlan
		result2 bool
		result3 error
	}
	BuildResourcesStub        func(int) (atc.BuildInputsOutputs, bool, error)
	buildResourcesMutex       sync.RWMutex
	buildResourcesArgsForCall []struct {
		arg1 int
	}
	buildResourcesReturns struct {
		result1 atc.BuildInputsOutputs
		result2 bool
		result3 error
	}
	buildResourcesReturnsOnCall map[int]struct {
		result1 atc.BuildInputsOutputs
		result2 bool
		result3 error
	}
	BuildsStub        func(concourse.Page) ([]atc.Build, concourse.Pagination, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		arg1 concourse.Page
	}
	buildsReturns struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 error
	}
	FindTeamStub        func(string) (concourse.Team, error)
	findTeamMutex       sync.RWMutex
	findTeamArgsForCall []struct {
		arg1 string
	}
	findTeamReturns struct {
		result1 concourse.Team
		result2 error
	}
	findTeamReturnsOnCall map[int]struct {
		result1 concourse.Team
		result2 error
	}
	GetCLIReaderStub        func(string, string) (io.ReadCloser, http.Header, error)
	getCLIReaderMutex       sync.RWMutex
	getCLIReaderArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getCLIReaderReturns struct {
		result1 io.ReadCloser
		result2 http.Header
		result3 error
	}
	getCLIReaderReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 http.Header
		result3 error
	}
	GetInfoStub        func() (atc.Info, error)
	getInfoMutex       sync.RWMutex
	getInfoArgsForCall []struct {
	}
	getInfoReturns struct {
		result1 atc.Info
		result2 error
	}
	getInfoReturnsOnCall map[int]struct {
		result1 atc.Info
		result2 error
	}
	HTTPClientStub        func() *http.Client
	hTTPClientMutex       sync.RWMutex
	hTTPClientArgsForCall []struct {
	}
	hTTPClientReturns struct {
		result1 *http.Client
	}
	hTTPClientReturnsOnCall map[int]struct {
		result1 *http.Client
	}
	LandWorkerStub        func(string) error
	landWorkerMutex       sync.RWMutex
	landWorkerArgsForCall []struct {
		arg1 string
	}
	landWorkerReturns struct {
		result1 error
	}
	landWorkerReturnsOnCall map[int]struct {
		result1 error
	}
	ListActiveUsersSinceStub        func(time.Time) ([]atc.User, error)
	listActiveUsersSinceMutex       sync.RWMutex
	listActiveUsersSinceArgsForCall []struct {
		arg1 time.Time
	}
	listActiveUsersSinceReturns struct {
		result1 []atc.User
		result2 error
	}
	listActiveUsersSinceReturnsOnCall map[int]struct {
		result1 []atc.User
		result2 error
	}
	ListAllJobsStub        func() ([]atc.Job, error)
	listAllJobsMutex       sync.RWMutex
	listAllJobsArgsForCall []struct {
	}
	listAllJobsReturns struct {
		result1 []atc.Job
		result2 error
	}
	listAllJobsReturnsOnCall map[int]struct {
		result1 []atc.Job
		result2 error
	}
	ListBuildArtifactsStub        func(string) ([]atc.WorkerArtifact, error)
	listBuildArtifactsMutex       sync.RWMutex
	listBuildArtifactsArgsForCall []struct {
		arg1 string
	}
	listBuildArtifactsReturns struct {
		result1 []atc.WorkerArtifact
		result2 error
	}
	listBuildArtifactsReturnsOnCall map[int]struct {
		result1 []atc.WorkerArtifact
		result2 error
	}
	ListPipelinesStub        func() ([]atc.Pipeline, error)
	listPipelinesMutex       sync.RWMutex
	listPipelinesArgsForCall []struct {
	}
	listPipelinesReturns struct {
		result1 []atc.Pipeline
		result2 error
	}
	listPipelinesReturnsOnCall map[int]struct {
		result1 []atc.Pipeline
		result2 error
	}
	ListTeamsStub        func() ([]atc.Team, error)
	listTeamsMutex       sync.RWMutex
	listTeamsArgsForCall []struct {
	}
	listTeamsReturns struct {
		result1 []atc.Team
		result2 error
	}
	listTeamsReturnsOnCall map[int]struct {
		result1 []atc.Team
		result2 error
	}
	ListWorkersStub        func() ([]atc.Worker, error)
	listWorkersMutex       sync.RWMutex
	listWorkersArgsForCall []struct {
	}
	listWorkersReturns struct {
		result1 []atc.Worker
		result2 error
	}
	listWorkersReturnsOnCall map[int]struct {
		result1 []atc.Worker
		result2 error
	}
	PruneWorkerStub        func(string) error
	pruneWorkerMutex       sync.RWMutex
	pruneWorkerArgsForCall []struct {
		arg1 string
	}
	pruneWorkerReturns struct {
		result1 error
	}
	pruneWorkerReturnsOnCall map[int]struct {
		result1 error
	}
	SaveWorkerStub        func(atc.Worker, *time.Duration) (*atc.Worker, error)
	saveWorkerMutex       sync.RWMutex
	saveWorkerArgsForCall []struct {
		arg1 atc.Worker
		arg2 *time.Duration
	}
	saveWorkerReturns struct {
		result1 *atc.Worker
		result2 error
	}
	saveWorkerReturnsOnCall map[int]struct {
		result1 *atc.Worker
		result2 error
	}
	TeamStub        func(string) concourse.Team
	teamMutex       sync.RWMutex
	teamArgsForCall []struct {
		arg1 string
	}
	teamReturns struct {
		result1 concourse.Team
	}
	teamReturnsOnCall map[int]struct {
		result1 concourse.Team
	}
	URLStub        func() string
	uRLMutex       sync.RWMutex
	uRLArgsForCall []struct {
	}
	uRLReturns struct {
		result1 string
	}
	uRLReturnsOnCall map[int]struct {
		result1 string
	}
	GetWallStub        func() (atc.Wall, error)
	getWallMutex       sync.RWMutex
	getWallArgsForCall []struct {
	}
	getWallReturns struct {
		result1 atc.Wall
		result2 error
	}
	getWallReturnsOnCall map[int]struct {
		result1 atc.Wall
		result2 error
	}
	SetWallStub        func(atc.Wall) error
	setWallMutex       sync.RWMutex
	setWallArgsForCall []struct {
		arg1 atc.Wall
	}
	setWallReturns struct {
		result1 error
	}
	setWallReturnsOnCall map[int]struct {
		result1 error
	}
	ClearWallStub        func() error
	clearWallMutex       sync.RWMutex
	clearWallArgsForCall []struct {
	}
	clearWallReturns struct {
		result1 error
	}
	clearWallReturnsOnCall map[int]struct {
		result1 error
	}
	UserInfoStub        func() (atc.UserInfo, error)
	userInfoMutex       sync.RWMutex
	userInfoArgsForCall []struct {
	}
	userInfoReturns struct {
		result1 atc.UserInfo
		result2 error
	}
	userInfoReturnsOnCall map[int]struct {
		result1 atc.UserInfo
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) AbortBuild(arg1 string) error {
	fake.abortBuildMutex.Lock()
	ret, specificReturn := fake.abortBuildReturnsOnCall[len(fake.abortBuildArgsForCall)]
	fake.abortBuildArgsForCall = append(fake.abortBuildArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AbortBuildStub
	fakeReturns := fake.abortBuildReturns
	fake.recordInvocation("AbortBuild", []interface{}{arg1})
	fake.abortBuildMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) AbortBuildCallCount() int {
	fake.abortBuildMutex.RLock()
	defer fake.abortBuildMutex.RUnlock()
	return len(fake.abortBuildArgsForCall)
}

func (fake *FakeClient) AbortBuildCalls(stub func(string) error) {
	fake.abortBuildMutex.Lock()
	defer fake.abortBuildMutex.Unlock()
	fake.AbortBuildStub = stub
}

func (fake *FakeClient) AbortBuildArgsForCall(i int) string {
	fake.abortBuildMutex.RLock()
	defer fake.abortBuildMutex.RUnlock()
	argsForCall := fake.abortBuildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) AbortBuildReturns(result1 error) {
	fake.abortBuildMutex.Lock()
	defer fake.abortBuildMutex.Unlock()
	fake.AbortBuildStub = nil
	fake.abortBuildReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AbortBuildReturnsOnCall(i int, result1 error) {
	fake.abortBuildMutex.Lock()
	defer fake.abortBuildMutex.Unlock()
	fake.AbortBuildStub = nil
	if fake.abortBuildReturnsOnCall == nil {
		fake.abortBuildReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.abortBuildReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Build(arg1 string) (atc.Build, bool, error) {
	fake.buildMutex.Lock()
	ret, specificReturn := fake.buildReturnsOnCall[len(fake.buildArgsForCall)]
	fake.buildArgsForCall = append(fake.buildArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.BuildStub
	fakeReturns := fake.buildReturns
	fake.recordInvocation("Build", []interface{}{arg1})
	fake.buildMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) BuildCallCount() int {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return len(fake.buildArgsForCall)
}

func (fake *FakeClient) BuildCalls(stub func(string) (atc.Build, bool, error)) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = stub
}

func (fake *FakeClient) BuildArgsForCall(i int) string {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	argsForCall := fake.buildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) BuildReturns(result1 atc.Build, result2 bool, result3 error) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	fake.buildReturns = struct {
		result1 atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) BuildReturnsOnCall(i int, result1 atc.Build, result2 bool, result3 error) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	if fake.buildReturnsOnCall == nil {
		fake.buildReturnsOnCall = make(map[int]struct {
			result1 atc.Build
			result2 bool
			result3 error
		})
	}
	fake.buildReturnsOnCall[i] = struct {
		result1 atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) BuildEvents(arg1 string) (concourse.Events, error) {
	fake.buildEventsMutex.Lock()
	ret, specificReturn := fake.buildEventsReturnsOnCall[len(fake.buildEventsArgsForCall)]
	fake.buildEventsArgsForCall = append(fake.buildEventsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.BuildEventsStub
	fakeReturns := fake.buildEventsReturns
	fake.recordInvocation("BuildEvents", []interface{}{arg1})
	fake.buildEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) BuildEventsCallCount() int {
	fake.buildEventsMutex.RLock()
	defer fake.buildEventsMutex.RUnlock()
	return len(fake.buildEventsArgsForCall)
}

func (fake *FakeClient) BuildEventsCalls(stub func(string) (concourse.Events, error)) {
	fake.buildEventsMutex.Lock()
	defer fake.buildEventsMutex.Unlock()
	fake.BuildEventsStub = stub
}

func (fake *FakeClient) BuildEventsArgsForCall(i int) string {
	fake.buildEventsMutex.RLock()
	defer fake.buildEventsMutex.RUnlock()
	argsForCall := fake.buildEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) BuildEventsReturns(result1 concourse.Events, result2 error) {
	fake.buildEventsMutex.Lock()
	defer fake.buildEventsMutex.Unlock()
	fake.BuildEventsStub = nil
	fake.buildEventsReturns = struct {
		result1 concourse.Events
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildEventsReturnsOnCall(i int, result1 concourse.Events, result2 error) {
	fake.buildEventsMutex.Lock()
	defer fake.buildEventsMutex.Unlock()
	fake.BuildEventsStub = nil
	if fake.buildEventsReturnsOnCall == nil {
		fake.buildEventsReturnsOnCall = make(map[int]struct {
			result1 concourse.Events
			result2 error
		})
	}
	fake.buildEventsReturnsOnCall[i] = struct {
		result1 concourse.Events
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BuildPlan(arg1 int) (atc.PublicBuildPlan, bool, error) {
	fake.buildPlanMutex.Lock()
	ret, specificReturn := fake.buildPlanReturnsOnCall[len(fake.buildPlanArgsForCall)]
	fake.buildPlanArgsForCall = append(fake.buildPlanArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.BuildPlanStub
	fakeReturns := fake.buildPlanReturns
	fake.recordInvocation("BuildPlan", []interface{}{arg1})
	fake.buildPlanMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) BuildPlanCallCount() int {
	fake.buildPlanMutex.RLock()
	defer fake.buildPlanMutex.RUnlock()
	return len(fake.buildPlanArgsForCall)
}

func (fake *FakeClient) BuildPlanCalls(stub func(int) (atc.PublicBuildPlan, bool, error)) {
	fake.buildPlanMutex.Lock()
	defer fake.buildPlanMutex.Unlock()
	fake.BuildPlanStub = stub
}

func (fake *FakeClient) BuildPlanArgsForCall(i int) int {
	fake.buildPlanMutex.RLock()
	defer fake.buildPlanMutex.RUnlock()
	argsForCall := fake.buildPlanArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) BuildPlanReturns(result1 atc.PublicBuildPlan, result2 bool, result3 error) {
	fake.buildPlanMutex.Lock()
	defer fake.buildPlanMutex.Unlock()
	fake.BuildPlanStub = nil
	fake.buildPlanReturns = struct {
		result1 atc.PublicBuildPlan
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) BuildPlanReturnsOnCall(i int, result1 atc.PublicBuildPlan, result2 bool, result3 error) {
	fake.buildPlanMutex.Lock()
	defer fake.buildPlanMutex.Unlock()
	fake.BuildPlanStub = nil
	if fake.buildPlanReturnsOnCall == nil {
		fake.buildPlanReturnsOnCall = make(map[int]struct {
			result1 atc.PublicBuildPlan
			result2 bool
			result3 error
		})
	}
	fake.buildPlanReturnsOnCall[i] = struct {
		result1 atc.PublicBuildPlan
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) BuildResources(arg1 int) (atc.BuildInputsOutputs, bool, error) {
	fake.buildResourcesMutex.Lock()
	ret, specificReturn := fake.buildResourcesReturnsOnCall[len(fake.buildResourcesArgsForCall)]
	fake.buildResourcesArgsForCall = append(fake.buildResourcesArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.BuildResourcesStub
	fakeReturns := fake.buildResourcesReturns
	fake.recordInvocation("BuildResources", []interface{}{arg1})
	fake.buildResourcesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) BuildResourcesCallCount() int {
	fake.buildResourcesMutex.RLock()
	defer fake.buildResourcesMutex.RUnlock()
	return len(fake.buildResourcesArgsForCall)
}

func (fake *FakeClient) BuildResourcesCalls(stub func(int) (atc.BuildInputsOutputs, bool, error)) {
	fake.buildResourcesMutex.Lock()
	defer fake.buildResourcesMutex.Unlock()
	fake.BuildResourcesStub = stub
}

func (fake *FakeClient) BuildResourcesArgsForCall(i int) int {
	fake.buildResourcesMutex.RLock()
	defer fake.buildResourcesMutex.RUnlock()
	argsForCall := fake.buildResourcesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) BuildResourcesReturns(result1 atc.BuildInputsOutputs, result2 bool, result3 error) {
	fake.buildResourcesMutex.Lock()
	defer fake.buildResourcesMutex.Unlock()
	fake.BuildResourcesStub = nil
	fake.buildResourcesReturns = struct {
		result1 atc.BuildInputsOutputs
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) BuildResourcesReturnsOnCall(i int, result1 atc.BuildInputsOutputs, result2 bool, result3 error) {
	fake.buildResourcesMutex.Lock()
	defer fake.buildResourcesMutex.Unlock()
	fake.BuildResourcesStub = nil
	if fake.buildResourcesReturnsOnCall == nil {
		fake.buildResourcesReturnsOnCall = make(map[int]struct {
			result1 atc.BuildInputsOutputs
			result2 bool
			result3 error
		})
	}
	fake.buildResourcesReturnsOnCall[i] = struct {
		result1 atc.BuildInputsOutputs
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) Builds(arg1 concourse.Page) ([]atc.Build, concourse.Pagination, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		arg1 concourse.Page
	}{arg1})
	stub := fake.BuildsStub
	fakeReturns := fake.buildsReturns
	fake.recordInvocation("Builds", []interface{}{arg1})
	fake.buildsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakeClient) BuildsCalls(stub func(concourse.Page) ([]atc.Build, concourse.Pagination, error)) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = stub
}

func (fake *FakeClient) BuildsArgsForCall(i int) concourse.Page {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	argsForCall := fake.buildsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) BuildsReturns(result1 []atc.Build, result2 concourse.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) BuildsReturnsOnCall(i int, result1 []atc.Build, result2 concourse.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 concourse.Pagination
			result3 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) FindTeam(arg1 string) (concourse.Team, error) {
	fake.findTeamMutex.Lock()
	ret, specificReturn := fake.findTeamReturnsOnCall[len(fake.findTeamArgsForCall)]
	fake.findTeamArgsForCall = append(fake.findTeamArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindTeamStub
	fakeReturns := fake.findTeamReturns
	fake.recordInvocation("FindTeam", []interface{}{arg1})
	fake.findTeamMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) FindTeamCallCount() int {
	fake.findTeamMutex.RLock()
	defer fake.findTeamMutex.RUnlock()
	return len(fake.findTeamArgsForCall)
}

func (fake *FakeClient) FindTeamCalls(stub func(string) (concourse.Team, error)) {
	fake.findTeamMutex.Lock()
	defer fake.findTeamMutex.Unlock()
	fake.FindTeamStub = stub
}

func (fake *FakeClient) FindTeamArgsForCall(i int) string {
	fake.findTeamMutex.RLock()
	defer fake.findTeamMutex.RUnlock()
	argsForCall := fake.findTeamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FindTeamReturns(result1 concourse.Team, result2 error) {
	fake.findTeamMutex.Lock()
	defer fake.findTeamMutex.Unlock()
	fake.FindTeamStub = nil
	fake.findTeamReturns = struct {
		result1 concourse.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) FindTeamReturnsOnCall(i int, result1 concourse.Team, result2 error) {
	fake.findTeamMutex.Lock()
	defer fake.findTeamMutex.Unlock()
	fake.FindTeamStub = nil
	if fake.findTeamReturnsOnCall == nil {
		fake.findTeamReturnsOnCall = make(map[int]struct {
			result1 concourse.Team
			result2 error
		})
	}
	fake.findTeamReturnsOnCall[i] = struct {
		result1 concourse.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetCLIReader(arg1 string, arg2 string) (io.ReadCloser, http.Header, error) {
	fake.getCLIReaderMutex.Lock()
	ret, specificReturn := fake.getCLIReaderReturnsOnCall[len(fake.getCLIReaderArgsForCall)]
	fake.getCLIReaderArgsForCall = append(fake.getCLIReaderArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetCLIReaderStub
	fakeReturns := fake.getCLIReaderReturns
	fake.recordInvocation("GetCLIReader", []interface{}{arg1, arg2})
	fake.getCLIReaderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) GetCLIReaderCallCount() int {
	fake.getCLIReaderMutex.RLock()
	defer fake.getCLIReaderMutex.RUnlock()
	return len(fake.getCLIReaderArgsForCall)
}

func (fake *FakeClient) GetCLIReaderCalls(stub func(string, string) (io.ReadCloser, http.Header, error)) {
	fake.getCLIReaderMutex.Lock()
	defer fake.getCLIReaderMutex.Unlock()
	fake.GetCLIReaderStub = stub
}

func (fake *FakeClient) GetCLIReaderArgsForCall(i int) (string, string) {
	fake.getCLIReaderMutex.RLock()
	defer fake.getCLIReaderMutex.RUnlock()
	argsForCall := fake.getCLIReaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetCLIReaderReturns(result1 io.ReadCloser, result2 http.Header, result3 error) {
	fake.getCLIReaderMutex.Lock()
	defer fake.getCLIReaderMutex.Unlock()
	fake.GetCLIReaderStub = nil
	fake.getCLIReaderReturns = struct {
		result1 io.ReadCloser
		result2 http.Header
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetCLIReaderReturnsOnCall(i int, result1 io.ReadCloser, result2 http.Header, result3 error) {
	fake.getCLIReaderMutex.Lock()
	defer fake.getCLIReaderMutex.Unlock()
	fake.GetCLIReaderStub = nil
	if fake.getCLIReaderReturnsOnCall == nil {
		fake.getCLIReaderReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 http.Header
			result3 error
		})
	}
	fake.getCLIReaderReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 http.Header
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInfo() (atc.Info, error) {
	fake.getInfoMutex.Lock()
	ret, specificReturn := fake.getInfoReturnsOnCall[len(fake.getInfoArgsForCall)]
	fake.getInfoArgsForCall = append(fake.getInfoArgsForCall, struct {
	}{})
	stub := fake.GetInfoStub
	fakeReturns := fake.getInfoReturns
	fake.recordInvocation("GetInfo", []interface{}{})
	fake.getInfoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetInfoCallCount() int {
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	return len(fake.getInfoArgsForCall)
}

func (fake *FakeClient) GetInfoCalls(stub func() (atc.Info, error)) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = stub
}

func (fake *FakeClient) GetInfoReturns(result1 atc.Info, result2 error) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = nil
	fake.getInfoReturns = struct {
		result1 atc.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInfoReturnsOnCall(i int, result1 atc.Info, result2 error) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = nil
	if fake.getInfoReturnsOnCall == nil {
		fake.getInfoReturnsOnCall = make(map[int]struct {
			result1 atc.Info
			result2 error
		})
	}
	fake.getInfoReturnsOnCall[i] = struct {
		result1 atc.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) HTTPClient() *http.Client {
	fake.hTTPClientMutex.Lock()
	ret, specificReturn := fake.hTTPClientReturnsOnCall[len(fake.hTTPClientArgsForCall)]
	fake.hTTPClientArgsForCall = append(fake.hTTPClientArgsForCall, struct {
	}{})
	stub := fake.HTTPClientStub
	fakeReturns := fake.hTTPClientReturns
	fake.recordInvocation("HTTPClient", []interface{}{})
	fake.hTTPClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HTTPClientCallCount() int {
	fake.hTTPClientMutex.RLock()
	defer fake.hTTPClientMutex.RUnlock()
	return len(fake.hTTPClientArgsForCall)
}

func (fake *FakeClient) HTTPClientCalls(stub func() *http.Client) {
	fake.hTTPClientMutex.Lock()
	defer fake.hTTPClientMutex.Unlock()
	fake.HTTPClientStub = stub
}

func (fake *FakeClient) HTTPClientReturns(result1 *http.Client) {
	fake.hTTPClientMutex.Lock()
	defer fake.hTTPClientMutex.Unlock()
	fake.HTTPClientStub = nil
	fake.hTTPClientReturns = struct {
		result1 *http.Client
	}{result1}
}

func (fake *FakeClient) HTTPClientReturnsOnCall(i int, result1 *http.Client) {
	fake.hTTPClientMutex.Lock()
	defer fake.hTTPClientMutex.Unlock()
	fake.HTTPClientStub = nil
	if fake.hTTPClientReturnsOnCall == nil {
		fake.hTTPClientReturnsOnCall = make(map[int]struct {
			result1 *http.Client
		})
	}
	fake.hTTPClientReturnsOnCall[i] = struct {
		result1 *http.Client
	}{result1}
}

func (fake *FakeClient) LandWorker(arg1 string) error {
	fake.landWorkerMutex.Lock()
	ret, specificReturn := fake.landWorkerReturnsOnCall[len(fake.landWorkerArgsForCall)]
	fake.landWorkerArgsForCall = append(fake.landWorkerArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LandWorkerStub
	fakeReturns := fake.landWorkerReturns
	fake.recordInvocation("LandWorker", []interface{}{arg1})
	fake.landWorkerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LandWorkerCallCount() int {
	fake.landWorkerMutex.RLock()
	defer fake.landWorkerMutex.RUnlock()
	return len(fake.landWorkerArgsForCall)
}

func (fake *FakeClient) LandWorkerCalls(stub func(string) error) {
	fake.landWorkerMutex.Lock()
	defer fake.landWorkerMutex.Unlock()
	fake.LandWorkerStub = stub
}

func (fake *FakeClient) LandWorkerArgsForCall(i int) string {
	fake.landWorkerMutex.RLock()
	defer fake.landWorkerMutex.RUnlock()
	argsForCall := fake.landWorkerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) LandWorkerReturns(result1 error) {
	fake.landWorkerMutex.Lock()
	defer fake.landWorkerMutex.Unlock()
	fake.LandWorkerStub = nil
	fake.landWorkerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) LandWorkerReturnsOnCall(i int, result1 error) {
	fake.landWorkerMutex.Lock()
	defer fake.landWorkerMutex.Unlock()
	fake.LandWorkerStub = nil
	if fake.landWorkerReturnsOnCall == nil {
		fake.landWorkerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.landWorkerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ListActiveUsersSince(arg1 time.Time) ([]atc.User, error) {
	fake.listActiveUsersSinceMutex.Lock()
	ret, specificReturn := fake.listActiveUsersSinceReturnsOnCall[len(fake.listActiveUsersSinceArgsForCall)]
	fake.listActiveUsersSinceArgsForCall = append(fake.listActiveUsersSinceArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	stub := fake.ListActiveUsersSinceStub
	fakeReturns := fake.listActiveUsersSinceReturns
	fake.recordInvocation("ListActiveUsersSince", []interface{}{arg1})
	fake.listActiveUsersSinceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListActiveUsersSinceCallCount() int {
	fake.listActiveUsersSinceMutex.RLock()
	defer fake.listActiveUsersSinceMutex.RUnlock()
	return len(fake.listActiveUsersSinceArgsForCall)
}

func (fake *FakeClient) ListActiveUsersSinceCalls(stub func(time.Time) ([]atc.User, error)) {
	fake.listActiveUsersSinceMutex.Lock()
	defer fake.listActiveUsersSinceMutex.Unlock()
	fake.ListActiveUsersSinceStub = stub
}

func (fake *FakeClient) ListActiveUsersSinceArgsForCall(i int) time.Time {
	fake.listActiveUsersSinceMutex.RLock()
	defer fake.listActiveUsersSinceMutex.RUnlock()
	argsForCall := fake.listActiveUsersSinceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListActiveUsersSinceReturns(result1 []atc.User, result2 error) {
	fake.listActiveUsersSinceMutex.Lock()
	defer fake.listActiveUsersSinceMutex.Unlock()
	fake.ListActiveUsersSinceStub = nil
	fake.listActiveUsersSinceReturns = struct {
		result1 []atc.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListActiveUsersSinceReturnsOnCall(i int, result1 []atc.User, result2 error) {
	fake.listActiveUsersSinceMutex.Lock()
	defer fake.listActiveUsersSinceMutex.Unlock()
	fake.ListActiveUsersSinceStub = nil
	if fake.listActiveUsersSinceReturnsOnCall == nil {
		fake.listActiveUsersSinceReturnsOnCall = make(map[int]struct {
			result1 []atc.User
			result2 error
		})
	}
	fake.listActiveUsersSinceReturnsOnCall[i] = struct {
		result1 []atc.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListAllJobs() ([]atc.Job, error) {
	fake.listAllJobsMutex.Lock()
	ret, specificReturn := fake.listAllJobsReturnsOnCall[len(fake.listAllJobsArgsForCall)]
	fake.listAllJobsArgsForCall = append(fake.listAllJobsArgsForCall, struct {
	}{})
	stub := fake.ListAllJobsStub
	fakeReturns := fake.listAllJobsReturns
	fake.recordInvocation("ListAllJobs", []interface{}{})
	fake.listAllJobsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListAllJobsCallCount() int {
	fake.listAllJobsMutex.RLock()
	defer fake.listAllJobsMutex.RUnlock()
	return len(fake.listAllJobsArgsForCall)
}

func (fake *FakeClient) ListAllJobsCalls(stub func() ([]atc.Job, error)) {
	fake.listAllJobsMutex.Lock()
	defer fake.listAllJobsMutex.Unlock()
	fake.ListAllJobsStub = stub
}

func (fake *FakeClient) ListAllJobsReturns(result1 []atc.Job, result2 error) {
	fake.listAllJobsMutex.Lock()
	defer fake.listAllJobsMutex.Unlock()
	fake.ListAllJobsStub = nil
	fake.listAllJobsReturns = struct {
		result1 []atc.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListAllJobsReturnsOnCall(i int, result1 []atc.Job, result2 error) {
	fake.listAllJobsMutex.Lock()
	defer fake.listAllJobsMutex.Unlock()
	fake.ListAllJobsStub = nil
	if fake.listAllJobsReturnsOnCall == nil {
		fake.listAllJobsReturnsOnCall = make(map[int]struct {
			result1 []atc.Job
			result2 error
		})
	}
	fake.listAllJobsReturnsOnCall[i] = struct {
		result1 []atc.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListBuildArtifacts(arg1 string) ([]atc.WorkerArtifact, error) {
	fake.listBuildArtifactsMutex.Lock()
	ret, specificReturn := fake.listBuildArtifactsReturnsOnCall[len(fake.listBuildArtifactsArgsForCall)]
	fake.listBuildArtifactsArgsForCall = append(fake.listBuildArtifactsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListBuildArtifactsStub
	fakeReturns := fake.listBuildArtifactsReturns
	fake.recordInvocation("ListBuildArtifacts", []interface{}{arg1})
	fake.listBuildArtifactsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListBuildArtifactsCallCount() int {
	fake.listBuildArtifactsMutex.RLock()
	defer fake.listBuildArtifactsMutex.RUnlock()
	return len(fake.listBuildArtifactsArgsForCall)
}

func (fake *FakeClient) ListBuildArtifactsCalls(stub func(string) ([]atc.WorkerArtifact, error)) {
	fake.listBuildArtifactsMutex.Lock()
	defer fake.listBuildArtifactsMutex.Unlock()
	fake.ListBuildArtifactsStub = stub
}

func (fake *FakeClient) ListBuildArtifactsArgsForCall(i int) string {
	fake.listBuildArtifactsMutex.RLock()
	defer fake.listBuildArtifactsMutex.RUnlock()
	argsForCall := fake.listBuildArtifactsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListBuildArtifactsReturns(result1 []atc.WorkerArtifact, result2 error) {
	fake.listBuildArtifactsMutex.Lock()
	defer fake.listBuildArtifactsMutex.Unlock()
	fake.ListBuildArtifactsStub = nil
	fake.listBuildArtifactsReturns = struct {
		result1 []atc.WorkerArtifact
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListBuildArtifactsReturnsOnCall(i int, result1 []atc.WorkerArtifact, result2 error) {
	fake.listBuildArtifactsMutex.Lock()
	defer fake.listBuildArtifactsMutex.Unlock()
	fake.ListBuildArtifactsStub = nil
	if fake.listBuildArtifactsReturnsOnCall == nil {
		fake.listBuildArtifactsReturnsOnCall = make(map[int]struct {
			result1 []atc.WorkerArtifact
			result2 error
		})
	}
	fake.listBuildArtifactsReturnsOnCall[i] = struct {
		result1 []atc.WorkerArtifact
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPipelines() ([]atc.Pipeline, error) {
	fake.listPipelinesMutex.Lock()
	ret, specificReturn := fake.listPipelinesReturnsOnCall[len(fake.listPipelinesArgsForCall)]
	fake.listPipelinesArgsForCall = append(fake.listPipelinesArgsForCall, struct {
	}{})
	stub := fake.ListPipelinesStub
	fakeReturns := fake.listPipelinesReturns
	fake.recordInvocation("ListPipelines", []interface{}{})
	fake.listPipelinesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListPipelinesCallCount() int {
	fake.listPipelinesMutex.RLock()
	defer fake.listPipelinesMutex.RUnlock()
	return len(fake.listPipelinesArgsForCall)
}

func (fake *FakeClient) ListPipelinesCalls(stub func() ([]atc.Pipeline, error)) {
	fake.listPipelinesMutex.Lock()
	defer fake.listPipelinesMutex.Unlock()
	fake.ListPipelinesStub = stub
}

func (fake *FakeClient) ListPipelinesReturns(result1 []atc.Pipeline, result2 error) {
	fake.listPipelinesMutex.Lock()
	defer fake.listPipelinesMutex.Unlock()
	fake.ListPipelinesStub = nil
	fake.listPipelinesReturns = struct {
		result1 []atc.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPipelinesReturnsOnCall(i int, result1 []atc.Pipeline, result2 error) {
	fake.listPipelinesMutex.Lock()
	defer fake.listPipelinesMutex.Unlock()
	fake.ListPipelinesStub = nil
	if fake.listPipelinesReturnsOnCall == nil {
		fake.listPipelinesReturnsOnCall = make(map[int]struct {
			result1 []atc.Pipeline
			result2 error
		})
	}
	fake.listPipelinesReturnsOnCall[i] = struct {
		result1 []atc.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListTeams() ([]atc.Team, error) {
	fake.listTeamsMutex.Lock()
	ret, specificReturn := fake.listTeamsReturnsOnCall[len(fake.listTeamsArgsForCall)]
	fake.listTeamsArgsForCall = append(fake.listTeamsArgsForCall, struct {
	}{})
	stub := fake.ListTeamsStub
	fakeReturns := fake.listTeamsReturns
	fake.recordInvocation("ListTeams", []interface{}{})
	fake.listTeamsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListTeamsCallCount() int {
	fake.listTeamsMutex.RLock()
	defer fake.listTeamsMutex.RUnlock()
	return len(fake.listTeamsArgsForCall)
}

func (fake *FakeClient) ListTeamsCalls(stub func() ([]atc.Team, error)) {
	fake.listTeamsMutex.Lock()
	defer fake.listTeamsMutex.Unlock()
	fake.ListTeamsStub = stub
}

func (fake *FakeClient) ListTeamsReturns(result1 []atc.Team, result2 error) {
	fake.listTeamsMutex.Lock()
	defer fake.listTeamsMutex.Unlock()
	fake.ListTeamsStub = nil
	fake.listTeamsReturns = struct {
		result1 []atc.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListTeamsReturnsOnCall(i int, result1 []atc.Team, result2 error) {
	fake.listTeamsMutex.Lock()
	defer fake.listTeamsMutex.Unlock()
	fake.ListTeamsStub = nil
	if fake.listTeamsReturnsOnCall == nil {
		fake.listTeamsReturnsOnCall = make(map[int]struct {
			result1 []atc.Team
			result2 error
		})
	}
	fake.listTeamsReturnsOnCall[i] = struct {
		result1 []atc.Team
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListWorkers() ([]atc.Worker, error) {
	fake.listWorkersMutex.Lock()
	ret, specificReturn := fake.listWorkersReturnsOnCall[len(fake.listWorkersArgsForCall)]
	fake.listWorkersArgsForCall = append(fake.listWorkersArgsForCall, struct {
	}{})
	stub := fake.ListWorkersStub
	fakeReturns := fake.listWorkersReturns
	fake.recordInvocation("ListWorkers", []interface{}{})
	fake.listWorkersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListWorkersCallCount() int {
	fake.listWorkersMutex.RLock()
	defer fake.listWorkersMutex.RUnlock()
	return len(fake.listWorkersArgsForCall)
}

func (fake *FakeClient) ListWorkersCalls(stub func() ([]atc.Worker, error)) {
	fake.listWorkersMutex.Lock()
	defer fake.listWorkersMutex.Unlock()
	fake.ListWorkersStub = stub
}

func (fake *FakeClient) ListWorkersReturns(result1 []atc.Worker, result2 error) {
	fake.listWorkersMutex.Lock()
	defer fake.listWorkersMutex.Unlock()
	fake.ListWorkersStub = nil
	fake.listWorkersReturns = struct {
		result1 []atc.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListWorkersReturnsOnCall(i int, result1 []atc.Worker, result2 error) {
	fake.listWorkersMutex.Lock()
	defer fake.listWorkersMutex.Unlock()
	fake.ListWorkersStub = nil
	if fake.listWorkersReturnsOnCall == nil {
		fake.listWorkersReturnsOnCall = make(map[int]struct {
			result1 []atc.Worker
			result2 error
		})
	}
	fake.listWorkersReturnsOnCall[i] = struct {
		result1 []atc.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PruneWorker(arg1 string) error {
	fake.pruneWorkerMutex.Lock()
	ret, specificReturn := fake.pruneWorkerReturnsOnCall[len(fake.pruneWorkerArgsForCall)]
	fake.pruneWorkerArgsForCall = append(fake.pruneWorkerArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PruneWorkerStub
	fakeReturns := fake.pruneWorkerReturns
	fake.recordInvocation("PruneWorker", []interface{}{arg1})
	fake.pruneWorkerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PruneWorkerCallCount() int {
	fake.pruneWorkerMutex.RLock()
	defer fake.pruneWorkerMutex.RUnlock()
	return len(fake.pruneWorkerArgsForCall)
}

func (fake *FakeClient) PruneWorkerCalls(stub func(string) error) {
	fake.pruneWorkerMutex.Lock()
	defer fake.pruneWorkerMutex.Unlock()
	fake.PruneWorkerStub = stub
}

func (fake *FakeClient) PruneWorkerArgsForCall(i int) string {
	fake.pruneWorkerMutex.RLock()
	defer fake.pruneWorkerMutex.RUnlock()
	argsForCall := fake.pruneWorkerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PruneWorkerReturns(result1 error) {
	fake.pruneWorkerMutex.Lock()
	defer fake.pruneWorkerMutex.Unlock()
	fake.PruneWorkerStub = nil
	fake.pruneWorkerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PruneWorkerReturnsOnCall(i int, result1 error) {
	fake.pruneWorkerMutex.Lock()
	defer fake.pruneWorkerMutex.Unlock()
	fake.PruneWorkerStub = nil
	if fake.pruneWorkerReturnsOnCall == nil {
		fake.pruneWorkerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pruneWorkerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) SaveWorker(arg1 atc.Worker, arg2 *time.Duration) (*atc.Worker, error) {
	fake.saveWorkerMutex.Lock()
	ret, specificReturn := fake.saveWorkerReturnsOnCall[len(fake.saveWorkerArgsForCall)]
	fake.saveWorkerArgsForCall = append(fake.saveWorkerArgsForCall, struct {
		arg1 atc.Worker
		arg2 *time.Duration
	}{arg1, arg2})
	stub := fake.SaveWorkerStub
	fakeReturns := fake.saveWorkerReturns
	fake.recordInvocation("SaveWorker", []interface{}{arg1, arg2})
	fake.saveWorkerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SaveWorkerCallCount() int {
	fake.saveWorkerMutex.RLock()
	defer fake.saveWorkerMutex.RUnlock()
	return len(fake.saveWorkerArgsForCall)
}

func (fake *FakeClient) SaveWorkerCalls(stub func(atc.Worker, *time.Duration) (*atc.Worker, error)) {
	fake.saveWorkerMutex.Lock()
	defer fake.saveWorkerMutex.Unlock()
	fake.SaveWorkerStub = stub
}

func (fake *FakeClient) SaveWorkerArgsForCall(i int) (atc.Worker, *time.Duration) {
	fake.saveWorkerMutex.RLock()
	defer fake.saveWorkerMutex.RUnlock()
	argsForCall := fake.saveWorkerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SaveWorkerReturns(result1 *atc.Worker, result2 error) {
	fake.saveWorkerMutex.Lock()
	defer fake.saveWorkerMutex.Unlock()
	fake.SaveWorkerStub = nil
	fake.saveWorkerReturns = struct {
		result1 *atc.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SaveWorkerReturnsOnCall(i int, result1 *atc.Worker, result2 error) {
	fake.saveWorkerMutex.Lock()
	defer fake.saveWorkerMutex.Unlock()
	fake.SaveWorkerStub = nil
	if fake.saveWorkerReturnsOnCall == nil {
		fake.saveWorkerReturnsOnCall = make(map[int]struct {
			result1 *atc.Worker
			result2 error
		})
	}
	fake.saveWorkerReturnsOnCall[i] = struct {
		result1 *atc.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Team(arg1 string) concourse.Team {
	fake.teamMutex.Lock()
	ret, specificReturn := fake.teamReturnsOnCall[len(fake.teamArgsForCall)]
	fake.teamArgsForCall = append(fake.teamArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.TeamStub
	fakeReturns := fake.teamReturns
	fake.recordInvocation("Team", []interface{}{arg1})
	fake.teamMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TeamCallCount() int {
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	return len(fake.teamArgsForCall)
}

func (fake *FakeClient) TeamCalls(stub func(string) concourse.Team) {
	fake.teamMutex.Lock()
	defer fake.teamMutex.Unlock()
	fake.TeamStub = stub
}

func (fake *FakeClient) TeamArgsForCall(i int) string {
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	argsForCall := fake.teamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) TeamReturns(result1 concourse.Team) {
	fake.teamMutex.Lock()
	defer fake.teamMutex.Unlock()
	fake.TeamStub = nil
	fake.teamReturns = struct {
		result1 concourse.Team
	}{result1}
}

func (fake *FakeClient) TeamReturnsOnCall(i int, result1 concourse.Team) {
	fake.teamMutex.Lock()
	defer fake.teamMutex.Unlock()
	fake.TeamStub = nil
	if fake.teamReturnsOnCall == nil {
		fake.teamReturnsOnCall = make(map[int]struct {
			result1 concourse.Team
		})
	}
	fake.teamReturnsOnCall[i] = struct {
		result1 concourse.Team
	}{result1}
}

func (fake *FakeClient) URL() string {
	fake.uRLMutex.Lock()
	ret, specificReturn := fake.uRLReturnsOnCall[len(fake.uRLArgsForCall)]
	fake.uRLArgsForCall = append(fake.uRLArgsForCall, struct {
	}{})
	stub := fake.URLStub
	fakeReturns := fake.uRLReturns
	fake.recordInvocation("URL", []interface{}{})
	fake.uRLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) URLCallCount() int {
	fake.uRLMutex.RLock()
	defer fake.uRLMutex.RUnlock()
	return len(fake.uRLArgsForCall)
}

func (fake *FakeClient) URLCalls(stub func() string) {
	fake.uRLMutex.Lock()
	defer fake.uRLMutex.Unlock()
	fake.URLStub = stub
}

func (fake *FakeClient) URLReturns(result1 string) {
	fake.uRLMutex.Lock()
	defer fake.uRLMutex.Unlock()
	fake.URLStub = nil
	fake.uRLReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) URLReturnsOnCall(i int, result1 string) {
	fake.uRLMutex.Lock()
	defer fake.uRLMutex.Unlock()
	fake.URLStub = nil
	if fake.uRLReturnsOnCall == nil {
		fake.uRLReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uRLReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) UserInfo() (atc.UserInfo, error) {
	fake.userInfoMutex.Lock()
	ret, specificReturn := fake.userInfoReturnsOnCall[len(fake.userInfoArgsForCall)]
	fake.userInfoArgsForCall = append(fake.userInfoArgsForCall, struct {
	}{})
	stub := fake.UserInfoStub
	fakeReturns := fake.userInfoReturns
	fake.recordInvocation("UserInfo", []interface{}{})
	fake.userInfoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UserInfoCallCount() int {
	fake.userInfoMutex.RLock()
	defer fake.userInfoMutex.RUnlock()
	return len(fake.userInfoArgsForCall)
}

func (fake *FakeClient) UserInfoCalls(stub func() (atc.UserInfo, error)) {
	fake.userInfoMutex.Lock()
	defer fake.userInfoMutex.Unlock()
	fake.UserInfoStub = stub
}

func (fake *FakeClient) UserInfoReturns(result1 atc.UserInfo, result2 error) {
	fake.userInfoMutex.Lock()
	defer fake.userInfoMutex.Unlock()
	fake.UserInfoStub = nil
	fake.userInfoReturns = struct {
		result1 atc.UserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UserInfoReturnsOnCall(i int, result1 atc.UserInfo, result2 error) {
	fake.userInfoMutex.Lock()
	defer fake.userInfoMutex.Unlock()
	fake.UserInfoStub = nil
	if fake.userInfoReturnsOnCall == nil {
		fake.userInfoReturnsOnCall = make(map[int]struct {
			result1 atc.UserInfo
			result2 error
		})
	}
	fake.userInfoReturnsOnCall[i] = struct {
		result1 atc.UserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetWall() (atc.Wall, error) {
	fake.getWallMutex.Lock()
	ret, specificReturn := fake.getWallReturnsOnCall[len(fake.getWallArgsForCall)]
	fake.getWallArgsForCall = append(fake.getWallArgsForCall, struct{}{})
	stub := fake.GetWallStub
	fakeReturns := fake.getWallReturns
	fake.recordInvocation("GetWall", []interface{}{})
	fake.getWallMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetWallCallCount() int {
	fake.getWallMutex.RLock()
	defer fake.getWallMutex.RUnlock()
	return len(fake.getWallArgsForCall)
}

func (fake *FakeClient) GetWallCalls(stub func() (atc.Wall, error)) {
	fake.getWallMutex.Lock()
	defer fake.getWallMutex.Unlock()
	fake.GetWallStub = stub
}

func (fake *FakeClient) GetWallReturns(result1 atc.Wall, result2 error) {
	fake.getWallMutex.Lock()
	defer fake.getWallMutex.Unlock()
	fake.GetWallStub = nil
	fake.getWallReturns = struct {
		result1 atc.Wall
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetWallReturnsOnCall(i int, result1 atc.Wall, result2 error) {
	fake.getWallMutex.Lock()
	defer fake.getWallMutex.Unlock()
	fake.GetWallStub = nil
	if fake.getWallReturnsOnCall == nil {
		fake.getWallReturnsOnCall = make(map[int]struct {
			result1 atc.Wall
			result2 error
		})
	}
	fake.getWallReturnsOnCall[i] = struct {
		result1 atc.Wall
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SetWall(arg1 atc.Wall) error {
	fake.setWallMutex.Lock()
	ret, specificReturn := fake.setWallReturnsOnCall[len(fake.setWallArgsForCall)]
	fake.setWallArgsForCall = append(fake.setWallArgsForCall, struct{ arg1 atc.Wall }{arg1})
	stub := fake.SetWallStub
	fakeReturns := fake.setWallReturns
	fake.recordInvocation("SetWall", []interface{}{arg1})
	fake.setWallMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SetWallCallCount() int {
	fake.setWallMutex.RLock()
	defer fake.setWallMutex.RUnlock()
	return len(fake.setWallArgsForCall)
}

func (fake *FakeClient) SetWallCalls(stub func(atc.Wall) error) {
	fake.setWallMutex.Lock()
	defer fake.setWallMutex.Unlock()
	fake.SetWallStub = stub
}

func (fake *FakeClient) SetWallArgsForCall(i int) atc.Wall {
	fake.setWallMutex.RLock()
	defer fake.setWallMutex.RUnlock()
	argsForCall := fake.setWallArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SetWallReturns(result1 error) {
	fake.setWallMutex.Lock()
	defer fake.setWallMutex.Unlock()
	fake.SetWallStub = nil
	fake.setWallReturns = struct{ result1 error }{result1}
}

func (fake *FakeClient) SetWallReturnsOnCall(i int, result1 error) {
	fake.setWallMutex.Lock()
	defer fake.setWallMutex.Unlock()
	fake.SetWallStub = nil
	if fake.setWallReturnsOnCall == nil {
		fake.setWallReturnsOnCall = make(map[int]struct{ result1 error })
	}
	fake.setWallReturnsOnCall[i] = struct{ result1 error }{result1}
}

func (fake *FakeClient) ClearWall() error {
	fake.clearWallMutex.Lock()
	ret, specificReturn := fake.clearWallReturnsOnCall[len(fake.clearWallArgsForCall)]
	fake.clearWallArgsForCall = append(fake.clearWallArgsForCall, struct{}{})
	stub := fake.ClearWallStub
	fakeReturns := fake.clearWallReturns
	fake.recordInvocation("ClearWall", []interface{}{})
	fake.clearWallMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClearWallCallCount() int {
	fake.clearWallMutex.RLock()
	defer fake.clearWallMutex.RUnlock()
	return len(fake.clearWallArgsForCall)
}

func (fake *FakeClient) ClearWallCalls(stub func() error) {
	fake.clearWallMutex.Lock()
	defer fake.clearWallMutex.Unlock()
	fake.ClearWallStub = stub
}

func (fake *FakeClient) ClearWallReturns(result1 error) {
	fake.clearWallMutex.Lock()
	defer fake.clearWallMutex.Unlock()
	fake.ClearWallStub = nil
	fake.clearWallReturns = struct{ result1 error }{result1}
}

func (fake *FakeClient) ClearWallReturnsOnCall(i int, result1 error) {
	fake.clearWallMutex.Lock()
	defer fake.clearWallMutex.Unlock()
	fake.ClearWallStub = nil
	if fake.clearWallReturnsOnCall == nil {
		fake.clearWallReturnsOnCall = make(map[int]struct{ result1 error })
	}
	fake.clearWallReturnsOnCall[i] = struct{ result1 error }{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.abortBuildMutex.RLock()
	defer fake.abortBuildMutex.RUnlock()
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	fake.buildEventsMutex.RLock()
	defer fake.buildEventsMutex.RUnlock()
	fake.buildPlanMutex.RLock()
	defer fake.buildPlanMutex.RUnlock()
	fake.buildResourcesMutex.RLock()
	defer fake.buildResourcesMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.findTeamMutex.RLock()
	defer fake.findTeamMutex.RUnlock()
	fake.getCLIReaderMutex.RLock()
	defer fake.getCLIReaderMutex.RUnlock()
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	fake.hTTPClientMutex.RLock()
	defer fake.hTTPClientMutex.RUnlock()
	fake.landWorkerMutex.RLock()
	defer fake.landWorkerMutex.RUnlock()
	fake.listActiveUsersSinceMutex.RLock()
	defer fake.listActiveUsersSinceMutex.RUnlock()
	fake.listAllJobsMutex.RLock()
	defer fake.listAllJobsMutex.RUnlock()
	fake.listBuildArtifactsMutex.RLock()
	defer fake.listBuildArtifactsMutex.RUnlock()
	fake.listPipelinesMutex.RLock()
	defer fake.listPipelinesMutex.RUnlock()
	fake.listTeamsMutex.RLock()
	defer fake.listTeamsMutex.RUnlock()
	fake.listWorkersMutex.RLock()
	defer fake.listWorkersMutex.RUnlock()
	fake.pruneWorkerMutex.RLock()
	defer fake.pruneWorkerMutex.RUnlock()
	fake.saveWorkerMutex.RLock()
	defer fake.saveWorkerMutex.RUnlock()
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	fake.uRLMutex.RLock()
	defer fake.uRLMutex.RUnlock()
	fake.getWallMutex.RLock()
	defer fake.getWallMutex.RUnlock()
	fake.setWallMutex.RLock()
	defer fake.setWallMutex.RUnlock()
	fake.clearWallMutex.RLock()
	defer fake.clearWallMutex.RUnlock()
	fake.userInfoMutex.RLock()
	defer fake.userInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ concourse.Client = new(FakeClient)
