// Code generated by counterfeiter. DO NOT EDIT.
package concoursefakes

import (
	sync "sync"

	atc "github.com/concourse/concourse/atc"
	concourse "github.com/concourse/concourse/go-concourse/concourse"
)

type FakeTeam struct {
	ArchivePipelineStub        func(string) (bool, error)
	archivePipelineMutex       sync.RWMutex
	archivePipelineArgsForCall []struct {
		arg1 string
	}
	archivePipelineReturns struct {
		result1 bool
		result2 error
	}
	archivePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	BuildInputsForJobStub        func(string, string) ([]atc.BuildInput, bool, error)
	buildInputsForJobMutex       sync.RWMutex
	buildInputsForJobArgsForCall []struct {
		arg1 string
		arg2 string
	}
	buildInputsForJobReturns struct {
		result1 []atc.BuildInput
		result2 bool
		result3 error
	}
	buildInputsForJobReturnsOnCall map[int]struct {
		result1 []atc.BuildInput
		result2 bool
		result3 error
	}
	BuildsStub        func(concourse.Page) ([]atc.Build, concourse.Pagination, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		arg1 concourse.Page
	}
	buildsReturns struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 error
	}
	BuildsWithVersionAsInputStub        func(string, string, int) ([]atc.Build, bool, error)
	buildsWithVersionAsInputMutex       sync.RWMutex
	buildsWithVersionAsInputArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
	}
	buildsWithVersionAsInputReturns struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}
	buildsWithVersionAsInputReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}
	BuildsWithVersionAsOutputStub        func(string, string, int) ([]atc.Build, bool, error)
	buildsWithVersionAsOutputMutex       sync.RWMutex
	buildsWithVersionAsOutputArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
	}
	buildsWithVersionAsOutputReturns struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}
	buildsWithVersionAsOutputReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}
	CheckResourceStub        func(string, string, atc.Version) (bool, error)
	checkResourceMutex       sync.RWMutex
	checkResourceArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 atc.Version
	}
	checkResourceReturns struct {
		result1 bool
		result2 error
	}
	checkResourceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CheckResourceTypeStub        func(string, string, atc.Version) (bool, error)
	checkResourceTypeMutex       sync.RWMutex
	checkResourceTypeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 atc.Version
	}
	checkResourceTypeReturns struct {
		result1 bool
		result2 error
	}
	checkResourceTypeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ClearTaskCacheStub        func(string, string, string, string) (int64, error)
	clearTaskCacheMutex       sync.RWMutex
	clearTaskCacheArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	clearTaskCacheReturns struct {
		result1 int64
		result2 error
	}
	clearTaskCacheReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	CreateBuildStub        func(atc.Plan) (atc.Build, error)
	createBuildMutex       sync.RWMutex
	createBuildArgsForCall []struct {
		arg1 atc.Plan
	}
	createBuildReturns struct {
		result1 atc.Build
		result2 error
	}
	createBuildReturnsOnCall map[int]struct {
		result1 atc.Build
		result2 error
	}
	CreateJobBuildStub        func(string, string) (atc.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createJobBuildReturns struct {
		result1 atc.Build
		result2 error
	}
	createJobBuildReturnsOnCall map[int]struct {
		result1 atc.Build
		result2 error
	}
	CreateOrUpdateStub        func(atc.Team) (atc.Team, bool, bool, error)
	createOrUpdateMutex       sync.RWMutex
	createOrUpdateArgsForCall []struct {
		arg1 atc.Team
	}
	createOrUpdateReturns struct {
		result1 atc.Team
		result2 bool
		result3 bool
		result4 error
	}
	createOrUpdateReturnsOnCall map[int]struct {
		result1 atc.Team
		result2 bool
		result3 bool
		result4 error
	}
	CreateOrUpdatePipelineConfigStub        func(string, string, []byte, bool) (bool, bool, []concourse.ConfigWarning, error)
	createOrUpdatePipelineConfigMutex       sync.RWMutex
	createOrUpdatePipelineConfigArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []byte
		arg4 bool
	}
	createOrUpdatePipelineConfigReturns struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}
	createOrUpdatePipelineConfigReturnsOnCall map[int]struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}
	CreatePipelineBuildStub        func(string, atc.Plan) (atc.Build, error)
	createPipelineBuildMutex       sync.RWMutex
	createPipelineBuildArgsForCall []struct {
		arg1 string
		arg2 atc.Plan
	}
	createPipelineBuildReturns struct {
		result1 atc.Build
		result2 error
	}
	createPipelineBuildReturnsOnCall map[int]struct {
		result1 atc.Build
		result2 error
	}
	DeletePipelineStub        func(string) (bool, error)
	deletePipelineMutex       sync.RWMutex
	deletePipelineArgsForCall []struct {
		arg1 string
	}
	deletePipelineReturns struct {
		result1 bool
		result2 error
	}
	deletePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DestroyTeamStub        func(string) error
	destroyTeamMutex       sync.RWMutex
	destroyTeamArgsForCall []struct {
		arg1 string
	}
	destroyTeamReturns struct {
		result1 error
	}
	destroyTeamReturnsOnCall map[int]struct {
		result1 error
	}
	DisableResourceVersionStub        func(string, string, int) (bool, error)
	disableResourceVersionMutex       sync.RWMutex
	disableResourceVersionArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
	}
	disableResourceVersionReturns struct {
		result1 bool
		result2 error
	}
	disableResourceVersionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EnableResourceVersionStub        func(string, string, int) (bool, error)
	enableResourceVersionMutex       sync.RWMutex
	enableResourceVersionArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
	}
	enableResourceVersionReturns struct {
		result1 bool
		result2 error
	}
	enableResourceVersionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ExposePipelineStub        func(string) (bool, error)
	exposePipelineMutex       sync.RWMutex
	exposePipelineArgsForCall []struct {
		arg1 string
	}
	exposePipelineReturns struct {
		result1 bool
		result2 error
	}
	exposePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	HidePipelineStub        func(string) (bool, error)
	hidePipelineMutex       sync.RWMutex
	hidePipelineArgsForCall []struct {
		arg1 string
	}
	hidePipelineReturns struct {
		result1 bool
		result2 error
	}
	hidePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	JobStub        func(string, string) (atc.Job, bool, error)
	jobMutex       sync.RWMutex
	jobArgsForCall []struct {
		arg1 string
		arg2 string
	}
	jobReturns struct {
		result1 atc.Job
		result2 bool
		result3 error
	}
	jobReturnsOnCall map[int]struct {
		result1 atc.Job
		result2 bool
		result3 error
	}
	JobBuildStub        func(string, string, string) (atc.Build, bool, error)
	jobBuildMutex       sync.RWMutex
	jobBuildArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	jobBuildReturns struct {
		result1 atc.Build
		result2 bool
		result3 error
	}
	jobBuildReturnsOnCall map[int]struct {
		result1 atc.Build
		result2 bool
		result3 error
	}
	JobBuildsStub        func(string, string, concourse.Page) ([]atc.Build, concourse.Pagination, bool, error)
	jobBuildsMutex       sync.RWMutex
	jobBuildsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 concourse.Page
	}
	jobBuildsReturns struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	jobBuildsReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	ListContainersStub        func(map[string]string) ([]atc.Container, error)
	listContainersMutex       sync.RWMutex
	listContainersArgsForCall []struct {
		arg1 map[string]string
	}
	listContainersReturns struct {
		result1 []atc.Container
		result2 error
	}
	listContainersReturnsOnCall map[int]struct {
		result1 []atc.Container
		result2 error
	}
	ListJobsStub        func(string) ([]atc.Job, error)
	listJobsMutex       sync.RWMutex
	listJobsArgsForCall []struct {
		arg1 string
	}
	listJobsReturns struct {
		result1 []atc.Job
		result2 error
	}
	listJobsReturnsOnCall map[int]struct {
		result1 []atc.Job
		result2 error
	}
	ListPipelinesStub        func() ([]atc.Pipeline, error)
	listPipelinesMutex       sync.RWMutex
	listPipelinesArgsForCall []struct {
	}
	listPipelinesReturns struct {
		result1 []atc.Pipeline
		result2 error
	}
	listPipelinesReturnsOnCall map[int]struct {
		result1 []atc.Pipeline
		result2 error
	}
	ListVolumesStub        func() ([]atc.Volume, error)
	listVolumesMutex       sync.RWMutex
	listVolumesArgsForCall []struct {
	}
	listVolumesReturns struct {
		result1 []atc.Volume
		result2 error
	}
	listVolumesReturnsOnCall map[int]struct {
		result1 []atc.Volume
		result2 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	OrderingPipelinesStub        func([]string) error
	orderingPipelinesMutex       sync.RWMutex
	orderingPipelinesArgsForCall []struct {
		arg1 []string
	}
	orderingPipelinesReturns struct {
		result1 error
	}
	orderingPipelinesReturnsOnCall map[int]struct {
		result1 error
	}
	PauseJobStub        func(string, string) (bool, error)
	pauseJobMutex       sync.RWMutex
	pauseJobArgsForCall []struct {
		arg1 string
		arg2 string
	}
	pauseJobReturns struct {
		result1 bool
		result2 error
	}
	pauseJobReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PausePipelineStub        func(string) (bool, error)
	pausePipelineMutex       sync.RWMutex
	pausePipelineArgsForCall []struct {
		arg1 string
	}
	pausePipelineReturns struct {
		result1 bool
		result2 error
	}
	pausePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PauseResourceStub        func(string, string) (bool, error)
	pauseResourceMutex       sync.RWMutex
	pauseResourceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	pauseResourceReturns struct {
		result1 bool
		result2 error
	}
	pauseResourceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PipelineStub        func(string) (atc.Pipeline, bool, error)
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct {
		arg1 string
	}
	pipelineReturns struct {
		result1 atc.Pipeline
		result2 bool
		result3 error
	}
	pipelineReturnsOnCall map[int]struct {
		result1 atc.Pipeline
		result2 bool
		result3 error
	}
	PipelineBuildsStub        func(string, concourse.Page) ([]atc.Build, concourse.Pagination, bool, error)
	pipelineBuildsMutex       sync.RWMutex
	pipelineBuildsArgsForCall []struct {
		arg1 string
		arg2 concourse.Page
	}
	pipelineBuildsReturns struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	pipelineBuildsReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	PipelineConfigStub        func(string) (atc.Config, atc.RawConfig, string, bool, error)
	pipelineConfigMutex       sync.RWMutex
	pipelineConfigArgsForCall []struct {
		arg1 string
	}
	pipelineConfigReturns struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}
	pipelineConfigReturnsOnCall map[int]struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}
	RenamePipelineStub        func(string, string) (bool, error)
	renamePipelineMutex       sync.RWMutex
	renamePipelineArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renamePipelineReturns struct {
		result1 bool
		result2 error
	}
	renamePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RenameTeamStub        func(string, string) (bool, error)
	renameTeamMutex       sync.RWMutex
	renameTeamArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameTeamReturns struct {
		result1 bool
		result2 error
	}
	renameTeamReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ResourceStub        func(string, string) (atc.Resource, bool, error)
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	resourceReturns struct {
		result1 atc.Resource
		result2 bool
		result3 error
	}
	resourceReturnsOnCall map[int]struct {
		result1 atc.Resource
		result2 bool
		result3 error
	}
	ResourceVersionsStub        func(string, string, concourse.Page) ([]atc.VersionedResource, concourse.Pagination, bool, error)
	resourceVersionsMutex       sync.RWMutex
	resourceVersionsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 concourse.Page
	}
	resourceVersionsReturns struct {
		result1 []atc.VersionedResource
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	resourceVersionsReturnsOnCall map[int]struct {
		result1 []atc.VersionedResource
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	UnarchivePipelineStub        func(string) (bool, error)
	unarchivePipelineMutex       sync.RWMutex
	unarchivePipelineArgsForCall []struct {
		arg1 string
	}
	unarchivePipelineReturns struct {
		result1 bool
		result2 error
	}
	unarchivePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UnpauseJobStub        func(string, string) (bool, error)
	unpauseJobMutex       sync.RWMutex
	unpauseJobArgsForCall []struct {
		arg1 string
		arg2 string
	}
	unpauseJobReturns struct {
		result1 bool
		result2 error
	}
	unpauseJobReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UnpausePipelineStub        func(string) (bool, error)
	unpausePipelineMutex       sync.RWMutex
	unpausePipelineArgsForCall []struct {
		arg1 string
	}
	unpausePipelineReturns struct {
		result1 bool
		result2 error
	}
	unpausePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UnpauseResourceStub        func(string, string) (bool, error)
	unpauseResourceMutex       sync.RWMutex
	unpauseResourceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	unpauseResourceReturns struct {
		result1 bool
		result2 error
	}
	unpauseResourceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	VersionedResourceTypesStub        func(string) (atc.VersionedResourceTypes, bool, error)
	versionedResourceTypesMutex       sync.RWMutex
	versionedResourceTypesArgsForCall []struct {
		arg1 string
	}
	versionedResourceTypesReturns struct {
		result1 atc.VersionedResourceTypes
		result2 bool
		result3 error
	}
	versionedResourceTypesReturnsOnCall map[int]struct {
		result1 atc.VersionedResourceTypes
		result2 bool
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTeam) ArchivePipeline(arg1 string) (bool, error) {
	fake.archivePipelineMutex.Lock()
	ret, specificReturn := fake.archivePipelineReturnsOnCall[len(fake.archivePipelineArgsForCall)]
	fake.archivePipelineArgsForCall = append(fake.archivePipelineArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ArchivePipeline", []interface{}{arg1})
	fake.archivePipelineMutex.Unlock()
	if fake.ArchivePipelineStub != nil {
		return fake.ArchivePipelineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.archivePipelineReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) ArchivePipelineCallCount() int {
	fake.archivePipelineMutex.RLock()
	defer fake.archivePipelineMutex.RUnlock()
	return len(fake.archivePipelineArgsForCall)
}

func (fake *FakeTeam) ArchivePipelineArgsForCall(i int) string {
	fake.archivePipelineMutex.RLock()
	defer fake.archivePipelineMutex.RUnlock()
	argsForCall := fake.archivePipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) ArchivePipelineReturns(result1 bool, result2 error) {
	fake.ArchivePipelineStub = nil
	fake.archivePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ArchivePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ArchivePipelineStub = nil
	if fake.archivePipelineReturnsOnCall == nil {
		fake.archivePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.archivePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) BuildInputsForJob(arg1 string, arg2 string) ([]atc.BuildInput, bool, error) {
	fake.buildInputsForJobMutex.Lock()
	ret, specificReturn := fake.buildInputsForJobReturnsOnCall[len(fake.buildInputsForJobArgsForCall)]
	fake.buildInputsForJobArgsForCall = append(fake.buildInputsForJobArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("BuildInputsForJob", []interface{}{arg1, arg2})
	fake.buildInputsForJobMutex.Unlock()
	if fake.BuildInputsForJobStub != nil {
		return fake.BuildInputsForJobStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildInputsForJobReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) BuildInputsForJobCallCount() int {
	fake.buildInputsForJobMutex.RLock()
	defer fake.buildInputsForJobMutex.RUnlock()
	return len(fake.buildInputsForJobArgsForCall)
}

func (fake *FakeTeam) BuildInputsForJobArgsForCall(i int) (string, string) {
	fake.buildInputsForJobMutex.RLock()
	defer fake.buildInputsForJobMutex.RUnlock()
	argsForCall := fake.buildInputsForJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) BuildInputsForJobReturns(result1 []atc.BuildInput, result2 bool, result3 error) {
	fake.BuildInputsForJobStub = nil
	fake.buildInputsForJobReturns = struct {
		result1 []atc.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildInputsForJobReturnsOnCall(i int, result1 []atc.BuildInput, result2 bool, result3 error) {
	fake.BuildInputsForJobStub = nil
	if fake.buildInputsForJobReturnsOnCall == nil {
		fake.buildInputsForJobReturnsOnCall = make(map[int]struct {
			result1 []atc.BuildInput
			result2 bool
			result3 error
		})
	}
	fake.buildInputsForJobReturnsOnCall[i] = struct {
		result1 []atc.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) Builds(arg1 concourse.Page) ([]atc.Build, concourse.Pagination, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		arg1 concourse.Page
	}{arg1})
	fake.recordInvocation("Builds", []interface{}{arg1})
	fake.buildsMutex.Unlock()
	if fake.BuildsStub != nil {
		return fake.BuildsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakeTeam) BuildsArgsForCall(i int) concourse.Page {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	argsForCall := fake.buildsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) BuildsReturns(result1 []atc.Build, result2 concourse.Pagination, result3 error) {
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsReturnsOnCall(i int, result1 []atc.Build, result2 concourse.Pagination, result3 error) {
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 concourse.Pagination
			result3 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsWithVersionAsInput(arg1 string, arg2 string, arg3 int) ([]atc.Build, bool, error) {
	fake.buildsWithVersionAsInputMutex.Lock()
	ret, specificReturn := fake.buildsWithVersionAsInputReturnsOnCall[len(fake.buildsWithVersionAsInputArgsForCall)]
	fake.buildsWithVersionAsInputArgsForCall = append(fake.buildsWithVersionAsInputArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("BuildsWithVersionAsInput", []interface{}{arg1, arg2, arg3})
	fake.buildsWithVersionAsInputMutex.Unlock()
	if fake.BuildsWithVersionAsInputStub != nil {
		return fake.BuildsWithVersionAsInputStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsWithVersionAsInputReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) BuildsWithVersionAsInputCallCount() int {
	fake.buildsWithVersionAsInputMutex.RLock()
	defer fake.buildsWithVersionAsInputMutex.RUnlock()
	return len(fake.buildsWithVersionAsInputArgsForCall)
}

func (fake *FakeTeam) BuildsWithVersionAsInputArgsForCall(i int) (string, string, int) {
	fake.buildsWithVersionAsInputMutex.RLock()
	defer fake.buildsWithVersionAsInputMutex.RUnlock()
	argsForCall := fake.buildsWithVersionAsInputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) BuildsWithVersionAsInputReturns(result1 []atc.Build, result2 bool, result3 error) {
	fake.BuildsWithVersionAsInputStub = nil
	fake.buildsWithVersionAsInputReturns = struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsWithVersionAsInputReturnsOnCall(i int, result1 []atc.Build, result2 bool, result3 error) {
	fake.BuildsWithVersionAsInputStub = nil
	if fake.buildsWithVersionAsInputReturnsOnCall == nil {
		fake.buildsWithVersionAsInputReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 bool
			result3 error
		})
	}
	fake.buildsWithVersionAsInputReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsWithVersionAsOutput(arg1 string, arg2 string, arg3 int) ([]atc.Build, bool, error) {
	fake.buildsWithVersionAsOutputMutex.Lock()
	ret, specificReturn := fake.buildsWithVersionAsOutputReturnsOnCall[len(fake.buildsWithVersionAsOutputArgsForCall)]
	fake.buildsWithVersionAsOutputArgsForCall = append(fake.buildsWithVersionAsOutputArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("BuildsWithVersionAsOutput", []interface{}{arg1, arg2, arg3})
	fake.buildsWithVersionAsOutputMutex.Unlock()
	if fake.BuildsWithVersionAsOutputStub != nil {
		return fake.BuildsWithVersionAsOutputStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsWithVersionAsOutputReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) BuildsWithVersionAsOutputCallCount() int {
	fake.buildsWithVersionAsOutputMutex.RLock()
	defer fake.buildsWithVersionAsOutputMutex.RUnlock()
	return len(fake.buildsWithVersionAsOutputArgsForCall)
}

func (fake *FakeTeam) BuildsWithVersionAsOutputArgsForCall(i int) (string, string, int) {
	fake.buildsWithVersionAsOutputMutex.RLock()
	defer fake.buildsWithVersionAsOutputMutex.RUnlock()
	argsForCall := fake.buildsWithVersionAsOutputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) BuildsWithVersionAsOutputReturns(result1 []atc.Build, result2 bool, result3 error) {
	fake.BuildsWithVersionAsOutputStub = nil
	fake.buildsWithVersionAsOutputReturns = struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsWithVersionAsOutputReturnsOnCall(i int, result1 []atc.Build, result2 bool, result3 error) {
	fake.BuildsWithVersionAsOutputStub = nil
	if fake.buildsWithVersionAsOutputReturnsOnCall == nil {
		fake.buildsWithVersionAsOutputReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 bool
			result3 error
		})
	}
	fake.buildsWithVersionAsOutputReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) CheckResource(arg1 string, arg2 string, arg3 atc.Version) (bool, error) {
	fake.checkResourceMutex.Lock()
	ret, specificReturn := fake.checkResourceReturnsOnCall[len(fake.checkResourceArgsForCall)]
	fake.checkResourceArgsForCall = append(fake.checkResourceArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 atc.Version
	}{arg1, arg2, arg3})
	fake.recordInvocation("CheckResource", []interface{}{arg1, arg2, arg3})
	fake.checkResourceMutex.Unlock()
	if fake.CheckResourceStub != nil {
		return fake.CheckResourceStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.checkResourceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) CheckResourceCallCount() int {
	fake.checkResourceMutex.RLock()
	defer fake.checkResourceMutex.RUnlock()
	return len(fake.checkResourceArgsForCall)
}

func (fake *FakeTeam) CheckResourceArgsForCall(i int) (string, string, atc.Version) {
	fake.checkResourceMutex.RLock()
	defer fake.checkResourceMutex.RUnlock()
	argsForCall := fake.checkResourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) CheckResourceReturns(result1 bool, result2 error) {
	fake.CheckResourceStub = nil
	fake.checkResourceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CheckResourceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CheckResourceStub = nil
	if fake.checkResourceReturnsOnCall == nil {
		fake.checkResourceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkResourceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CheckResourceType(arg1 string, arg2 string, arg3 atc.Version) (bool, error) {
	fake.checkResourceTypeMutex.Lock()
	ret, specificReturn := fake.checkResourceTypeReturnsOnCall[len(fake.checkResourceTypeArgsForCall)]
	fake.checkResourceTypeArgsForCall = append(fake.checkResourceTypeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 atc.Version
	}{arg1, arg2, arg3})
	fake.recordInvocation("CheckResourceType", []interface{}{arg1, arg2, arg3})
	fake.checkResourceTypeMutex.Unlock()
	if fake.CheckResourceTypeStub != nil {
		return fake.CheckResourceTypeStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.checkResourceTypeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) CheckResourceTypeCallCount() int {
	fake.checkResourceTypeMutex.RLock()
	defer fake.checkResourceTypeMutex.RUnlock()
	return len(fake.checkResourceTypeArgsForCall)
}

func (fake *FakeTeam) CheckResourceTypeArgsForCall(i int) (string, string, atc.Version) {
	fake.checkResourceTypeMutex.RLock()
	defer fake.checkResourceTypeMutex.RUnlock()
	argsForCall := fake.checkResourceTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) CheckResourceTypeReturns(result1 bool, result2 error) {
	fake.CheckResourceTypeStub = nil
	fake.checkResourceTypeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CheckResourceTypeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CheckResourceTypeStub = nil
	if fake.checkResourceTypeReturnsOnCall == nil {
		fake.checkResourceTypeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkResourceTypeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ClearTaskCache(arg1 string, arg2 string, arg3 string, arg4 string) (int64, error) {
	fake.clearTaskCacheMutex.Lock()
	ret, specificReturn := fake.clearTaskCacheReturnsOnCall[len(fake.clearTaskCacheArgsForCall)]
	fake.clearTaskCacheArgsForCall = append(fake.clearTaskCacheArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ClearTaskCache", []interface{}{arg1, arg2, arg3, arg4})
	fake.clearTaskCacheMutex.Unlock()
	if fake.ClearTaskCacheStub != nil {
		return fake.ClearTaskCacheStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.clearTaskCacheReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) ClearTaskCacheCallCount() int {
	fake.clearTaskCacheMutex.RLock()
	defer fake.clearTaskCacheMutex.RUnlock()
	return len(fake.clearTaskCacheArgsForCall)
}

func (fake *FakeTeam) ClearTaskCacheArgsForCall(i int) (string, string, string, string) {
	fake.clearTaskCacheMutex.RLock()
	defer fake.clearTaskCacheMutex.RUnlock()
	argsForCall := fake.clearTaskCacheArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTeam) ClearTaskCacheReturns(result1 int64, result2 error) {
	fake.ClearTaskCacheStub = nil
	fake.clearTaskCacheReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ClearTaskCacheReturnsOnCall(i int, result1 int64, result2 error) {
	fake.ClearTaskCacheStub = nil
	if fake.clearTaskCacheReturnsOnCall == nil {
		fake.clearTaskCacheReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.clearTaskCacheReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateBuild(arg1 atc.Plan) (atc.Build, error) {
	fake.createBuildMutex.Lock()
	ret, specificReturn := fake.createBuildReturnsOnCall[len(fake.createBuildArgsForCall)]
	fake.createBuildArgsForCall = append(fake.createBuildArgsForCall, struct {
		arg1 atc.Plan
	}{arg1})
	fake.recordInvocation("CreateBuild", []interface{}{arg1})
	fake.createBuildMutex.Unlock()
	if fake.CreateBuildStub != nil {
		return fake.CreateBuildStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) CreateBuildCallCount() int {
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	return len(fake.createBuildArgsForCall)
}

func (fake *FakeTeam) CreateBuildArgsForCall(i int) atc.Plan {
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	argsForCall := fake.createBuildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) CreateBuildReturns(result1 atc.Build, result2 error) {
	fake.CreateBuildStub = nil
	fake.createBuildReturns = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateBuildReturnsOnCall(i int, result1 atc.Build, result2 error) {
	fake.CreateBuildStub = nil
	if fake.createBuildReturnsOnCall == nil {
		fake.createBuildReturnsOnCall = make(map[int]struct {
			result1 atc.Build
			result2 error
		})
	}
	fake.createBuildReturnsOnCall[i] = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateJobBuild(arg1 string, arg2 string) (atc.Build, error) {
	fake.createJobBuildMutex.Lock()
	ret, specificReturn := fake.createJobBuildReturnsOnCall[len(fake.createJobBuildArgsForCall)]
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateJobBuild", []interface{}{arg1, arg2})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createJobBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakeTeam) CreateJobBuildArgsForCall(i int) (string, string) {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	argsForCall := fake.createJobBuildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) CreateJobBuildReturns(result1 atc.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateJobBuildReturnsOnCall(i int, result1 atc.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	if fake.createJobBuildReturnsOnCall == nil {
		fake.createJobBuildReturnsOnCall = make(map[int]struct {
			result1 atc.Build
			result2 error
		})
	}
	fake.createJobBuildReturnsOnCall[i] = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateOrUpdate(arg1 atc.Team) (atc.Team, bool, bool, error) {
	fake.createOrUpdateMutex.Lock()
	ret, specificReturn := fake.createOrUpdateReturnsOnCall[len(fake.createOrUpdateArgsForCall)]
	fake.createOrUpdateArgsForCall = append(fake.createOrUpdateArgsForCall, struct {
		arg1 atc.Team
	}{arg1})
	fake.recordInvocation("CreateOrUpdate", []interface{}{arg1})
	fake.createOrUpdateMutex.Unlock()
	if fake.CreateOrUpdateStub != nil {
		return fake.CreateOrUpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.createOrUpdateReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeTeam) CreateOrUpdateCallCount() int {
	fake.createOrUpdateMutex.RLock()
	defer fake.createOrUpdateMutex.RUnlock()
	return len(fake.createOrUpdateArgsForCall)
}

func (fake *FakeTeam) CreateOrUpdateArgsForCall(i int) atc.Team {
	fake.createOrUpdateMutex.RLock()
	defer fake.createOrUpdateMutex.RUnlock()
	argsForCall := fake.createOrUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) CreateOrUpdateReturns(result1 atc.Team, result2 bool, result3 bool, result4 error) {
	fake.CreateOrUpdateStub = nil
	fake.createOrUpdateReturns = struct {
		result1 atc.Team
		result2 bool
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) CreateOrUpdateReturnsOnCall(i int, result1 atc.Team, result2 bool, result3 bool, result4 error) {
	fake.CreateOrUpdateStub = nil
	if fake.createOrUpdateReturnsOnCall == nil {
		fake.createOrUpdateReturnsOnCall = make(map[int]struct {
			result1 atc.Team
			result2 bool
			result3 bool
			result4 error
		})
	}
	fake.createOrUpdateReturnsOnCall[i] = struct {
		result1 atc.Team
		result2 bool
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfig(arg1 string, arg2 string, arg3 []byte, arg4 bool) (bool, bool, []concourse.ConfigWarning, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.createOrUpdatePipelineConfigMutex.Lock()
	ret, specificReturn := fake.createOrUpdatePipelineConfigReturnsOnCall[len(fake.createOrUpdatePipelineConfigArgsForCall)]
	fake.createOrUpdatePipelineConfigArgsForCall = append(fake.createOrUpdatePipelineConfigArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []byte
		arg4 bool
	}{arg1, arg2, arg3Copy, arg4})
	fake.recordInvocation("CreateOrUpdatePipelineConfig", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.createOrUpdatePipelineConfigMutex.Unlock()
	if fake.CreateOrUpdatePipelineConfigStub != nil {
		return fake.CreateOrUpdatePipelineConfigStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.createOrUpdatePipelineConfigReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfigCallCount() int {
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	return len(fake.createOrUpdatePipelineConfigArgsForCall)
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfigArgsForCall(i int) (string, string, []byte, bool) {
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	argsForCall := fake.createOrUpdatePipelineConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfigReturns(result1 bool, result2 bool, result3 []concourse.ConfigWarning, result4 error) {
	fake.CreateOrUpdatePipelineConfigStub = nil
	fake.createOrUpdatePipelineConfigReturns = struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfigReturnsOnCall(i int, result1 bool, result2 bool, result3 []concourse.ConfigWarning, result4 error) {
	fake.CreateOrUpdatePipelineConfigStub = nil
	if fake.createOrUpdatePipelineConfigReturnsOnCall == nil {
		fake.createOrUpdatePipelineConfigReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 bool
			result3 []concourse.ConfigWarning
			result4 error
		})
	}
	fake.createOrUpdatePipelineConfigReturnsOnCall[i] = struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) CreatePipelineBuild(arg1 string, arg2 atc.Plan) (atc.Build, error) {
	fake.createPipelineBuildMutex.Lock()
	ret, specificReturn := fake.createPipelineBuildReturnsOnCall[len(fake.createPipelineBuildArgsForCall)]
	fake.createPipelineBuildArgsForCall = append(fake.createPipelineBuildArgsForCall, struct {
		arg1 string
		arg2 atc.Plan
	}{arg1, arg2})
	fake.recordInvocation("CreatePipelineBuild", []interface{}{arg1, arg2})
	fake.createPipelineBuildMutex.Unlock()
	if fake.CreatePipelineBuildStub != nil {
		return fake.CreatePipelineBuildStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createPipelineBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) CreatePipelineBuildCallCount() int {
	fake.createPipelineBuildMutex.RLock()
	defer fake.createPipelineBuildMutex.RUnlock()
	return len(fake.createPipelineBuildArgsForCall)
}

func (fake *FakeTeam) CreatePipelineBuildArgsForCall(i int) (string, atc.Plan) {
	fake.createPipelineBuildMutex.RLock()
	defer fake.createPipelineBuildMutex.RUnlock()
	argsForCall := fake.createPipelineBuildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) CreatePipelineBuildReturns(result1 atc.Build, result2 error) {
	fake.CreatePipelineBuildStub = nil
	fake.createPipelineBuildReturns = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreatePipelineBuildReturnsOnCall(i int, result1 atc.Build, result2 error) {
	fake.CreatePipelineBuildStub = nil
	if fake.createPipelineBuildReturnsOnCall == nil {
		fake.createPipelineBuildReturnsOnCall = make(map[int]struct {
			result1 atc.Build
			result2 error
		})
	}
	fake.createPipelineBuildReturnsOnCall[i] = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) DeletePipeline(arg1 string) (bool, error) {
	fake.deletePipelineMutex.Lock()
	ret, specificReturn := fake.deletePipelineReturnsOnCall[len(fake.deletePipelineArgsForCall)]
	fake.deletePipelineArgsForCall = append(fake.deletePipelineArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeletePipeline", []interface{}{arg1})
	fake.deletePipelineMutex.Unlock()
	if fake.DeletePipelineStub != nil {
		return fake.DeletePipelineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deletePipelineReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) DeletePipelineCallCount() int {
	fake.deletePipelineMutex.RLock()
	defer fake.deletePipelineMutex.RUnlock()
	return len(fake.deletePipelineArgsForCall)
}

func (fake *FakeTeam) DeletePipelineArgsForCall(i int) string {
	fake.deletePipelineMutex.RLock()
	defer fake.deletePipelineMutex.RUnlock()
	argsForCall := fake.deletePipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) DeletePipelineReturns(result1 bool, result2 error) {
	fake.DeletePipelineStub = nil
	fake.deletePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) DeletePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeletePipelineStub = nil
	if fake.deletePipelineReturnsOnCall == nil {
		fake.deletePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deletePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) DestroyTeam(arg1 string) error {
	fake.destroyTeamMutex.Lock()
	ret, specificReturn := fake.destroyTeamReturnsOnCall[len(fake.destroyTeamArgsForCall)]
	fake.destroyTeamArgsForCall = append(fake.destroyTeamArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DestroyTeam", []interface{}{arg1})
	fake.destroyTeamMutex.Unlock()
	if fake.DestroyTeamStub != nil {
		return fake.DestroyTeamStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.destroyTeamReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) DestroyTeamCallCount() int {
	fake.destroyTeamMutex.RLock()
	defer fake.destroyTeamMutex.RUnlock()
	return len(fake.destroyTeamArgsForCall)
}

func (fake *FakeTeam) DestroyTeamArgsForCall(i int) string {
	fake.destroyTeamMutex.RLock()
	defer fake.destroyTeamMutex.RUnlock()
	argsForCall := fake.destroyTeamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) DestroyTeamReturns(result1 error) {
	fake.DestroyTeamStub = nil
	fake.destroyTeamReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) DestroyTeamReturnsOnCall(i int, result1 error) {
	fake.DestroyTeamStub = nil
	if fake.destroyTeamReturnsOnCall == nil {
		fake.destroyTeamReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyTeamReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) DisableResourceVersion(arg1 string, arg2 string, arg3 int) (bool, error) {
	fake.disableResourceVersionMutex.Lock()
	ret, specificReturn := fake.disableResourceVersionReturnsOnCall[len(fake.disableResourceVersionArgsForCall)]
	fake.disableResourceVersionArgsForCall = append(fake.disableResourceVersionArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("DisableResourceVersion", []interface{}{arg1, arg2, arg3})
	fake.disableResourceVersionMutex.Unlock()
	if fake.DisableResourceVersionStub != nil {
		return fake.DisableResourceVersionStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.disableResourceVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) DisableResourceVersionCallCount() int {
	fake.disableResourceVersionMutex.RLock()
	defer fake.disableResourceVersionMutex.RUnlock()
	return len(fake.disableResourceVersionArgsForCall)
}

func (fake *FakeTeam) DisableResourceVersionArgsForCall(i int) (string, string, int) {
	fake.disableResourceVersionMutex.RLock()
	defer fake.disableResourceVersionMutex.RUnlock()
	argsForCall := fake.disableResourceVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) DisableResourceVersionReturns(result1 bool, result2 error) {
	fake.DisableResourceVersionStub = nil
	fake.disableResourceVersionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) DisableResourceVersionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DisableResourceVersionStub = nil
	if fake.disableResourceVersionReturnsOnCall == nil {
		fake.disableResourceVersionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.disableResourceVersionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) EnableResourceVersion(arg1 string, arg2 string, arg3 int) (bool, error) {
	fake.enableResourceVersionMutex.Lock()
	ret, specificReturn := fake.enableResourceVersionReturnsOnCall[len(fake.enableResourceVersionArgsForCall)]
	fake.enableResourceVersionArgsForCall = append(fake.enableResourceVersionArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("EnableResourceVersion", []interface{}{arg1, arg2, arg3})
	fake.enableResourceVersionMutex.Unlock()
	if fake.EnableResourceVersionStub != nil {
		return fake.EnableResourceVersionStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.enableResourceVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) EnableResourceVersionCallCount() int {
	fake.enableResourceVersionMutex.RLock()
	defer fake.enableResourceVersionMutex.RUnlock()
	return len(fake.enableResourceVersionArgsForCall)
}

func (fake *FakeTeam) EnableResourceVersionArgsForCall(i int) (string, string, int) {
	fake.enableResourceVersionMutex.RLock()
	defer fake.enableResourceVersionMutex.RUnlock()
	argsForCall := fake.enableResourceVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) EnableResourceVersionReturns(result1 bool, result2 error) {
	fake.EnableResourceVersionStub = nil
	fake.enableResourceVersionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) EnableResourceVersionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.EnableResourceVersionStub = nil
	if fake.enableResourceVersionReturnsOnCall == nil {
		fake.enableResourceVersionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.enableResourceVersionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ExposePipeline(arg1 string) (bool, error) {
	fake.exposePipelineMutex.Lock()
	ret, specificReturn := fake.exposePipelineReturnsOnCall[len(fake.exposePipelineArgsForCall)]
	fake.exposePipelineArgsForCall = append(fake.exposePipelineArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ExposePipeline", []interface{}{arg1})
	fake.exposePipelineMutex.Unlock()
	if fake.ExposePipelineStub != nil {
		return fake.ExposePipelineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.exposePipelineReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) ExposePipelineCallCount() int {
	fake.exposePipelineMutex.RLock()
	defer fake.exposePipelineMutex.RUnlock()
	return len(fake.exposePipelineArgsForCall)
}

func (fake *FakeTeam) ExposePipelineArgsForCall(i int) string {
	fake.exposePipelineMutex.RLock()
	defer fake.exposePipelineMutex.RUnlock()
	argsForCall := fake.exposePipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) ExposePipelineReturns(result1 bool, result2 error) {
	fake.ExposePipelineStub = nil
	fake.exposePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ExposePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ExposePipelineStub = nil
	if fake.exposePipelineReturnsOnCall == nil {
		fake.exposePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.exposePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) HidePipeline(arg1 string) (bool, error) {
	fake.hidePipelineMutex.Lock()
	ret, specificReturn := fake.hidePipelineReturnsOnCall[len(fake.hidePipelineArgsForCall)]
	fake.hidePipelineArgsForCall = append(fake.hidePipelineArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("HidePipeline", []interface{}{arg1})
	fake.hidePipelineMutex.Unlock()
	if fake.HidePipelineStub != nil {
		return fake.HidePipelineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.hidePipelineReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) HidePipelineCallCount() int {
	fake.hidePipelineMutex.RLock()
	defer fake.hidePipelineMutex.RUnlock()
	return len(fake.hidePipelineArgsForCall)
}

func (fake *FakeTeam) HidePipelineArgsForCall(i int) string {
	fake.hidePipelineMutex.RLock()
	defer fake.hidePipelineMutex.RUnlock()
	argsForCall := fake.hidePipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) HidePipelineReturns(result1 bool, result2 error) {
	fake.HidePipelineStub = nil
	fake.hidePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) HidePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.HidePipelineStub = nil
	if fake.hidePipelineReturnsOnCall == nil {
		fake.hidePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hidePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Job(arg1 string, arg2 string) (atc.Job, bool, error) {
	fake.jobMutex.Lock()
	ret, specificReturn := fake.jobReturnsOnCall[len(fake.jobArgsForCall)]
	fake.jobArgsForCall = append(fake.jobArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Job", []interface{}{arg1, arg2})
	fake.jobMutex.Unlock()
	if fake.JobStub != nil {
		return fake.JobStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.jobReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) JobCallCount() int {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return len(fake.jobArgsForCall)
}

func (fake *FakeTeam) JobArgsForCall(i int) (string, string) {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	argsForCall := fake.jobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) JobReturns(result1 atc.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	fake.jobReturns = struct {
		result1 atc.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) JobReturnsOnCall(i int, result1 atc.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	if fake.jobReturnsOnCall == nil {
		fake.jobReturnsOnCall = make(map[int]struct {
			result1 atc.Job
			result2 bool
			result3 error
		})
	}
	fake.jobReturnsOnCall[i] = struct {
		result1 atc.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) JobBuild(arg1 string, arg2 string, arg3 string) (atc.Build, bool, error) {
	fake.jobBuildMutex.Lock()
	ret, specificReturn := fake.jobBuildReturnsOnCall[len(fake.jobBuildArgsForCall)]
	fake.jobBuildArgsForCall = append(fake.jobBuildArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("JobBuild", []interface{}{arg1, arg2, arg3})
	fake.jobBuildMutex.Unlock()
	if fake.JobBuildStub != nil {
		return fake.JobBuildStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.jobBuildReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) JobBuildCallCount() int {
	fake.jobBuildMutex.RLock()
	defer fake.jobBuildMutex.RUnlock()
	return len(fake.jobBuildArgsForCall)
}

func (fake *FakeTeam) JobBuildArgsForCall(i int) (string, string, string) {
	fake.jobBuildMutex.RLock()
	defer fake.jobBuildMutex.RUnlock()
	argsForCall := fake.jobBuildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) JobBuildReturns(result1 atc.Build, result2 bool, result3 error) {
	fake.JobBuildStub = nil
	fake.jobBuildReturns = struct {
		result1 atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) JobBuildReturnsOnCall(i int, result1 atc.Build, result2 bool, result3 error) {
	fake.JobBuildStub = nil
	if fake.jobBuildReturnsOnCall == nil {
		fake.jobBuildReturnsOnCall = make(map[int]struct {
			result1 atc.Build
			result2 bool
			result3 error
		})
	}
	fake.jobBuildReturnsOnCall[i] = struct {
		result1 atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) JobBuilds(arg1 string, arg2 string, arg3 concourse.Page) ([]atc.Build, concourse.Pagination, bool, error) {
	fake.jobBuildsMutex.Lock()
	ret, specificReturn := fake.jobBuildsReturnsOnCall[len(fake.jobBuildsArgsForCall)]
	fake.jobBuildsArgsForCall = append(fake.jobBuildsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 concourse.Page
	}{arg1, arg2, arg3})
	fake.recordInvocation("JobBuilds", []interface{}{arg1, arg2, arg3})
	fake.jobBuildsMutex.Unlock()
	if fake.JobBuildsStub != nil {
		return fake.JobBuildsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.jobBuildsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeTeam) JobBuildsCallCount() int {
	fake.jobBuildsMutex.RLock()
	defer fake.jobBuildsMutex.RUnlock()
	return len(fake.jobBuildsArgsForCall)
}

func (fake *FakeTeam) JobBuildsArgsForCall(i int) (string, string, concourse.Page) {
	fake.jobBuildsMutex.RLock()
	defer fake.jobBuildsMutex.RUnlock()
	argsForCall := fake.jobBuildsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) JobBuildsReturns(result1 []atc.Build, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.JobBuildsStub = nil
	fake.jobBuildsReturns = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) JobBuildsReturnsOnCall(i int, result1 []atc.Build, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.JobBuildsStub = nil
	if fake.jobBuildsReturnsOnCall == nil {
		fake.jobBuildsReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 concourse.Pagination
			result3 bool
			result4 error
		})
	}
	fake.jobBuildsReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) ListContainers(arg1 map[string]string) ([]atc.Container, error) {
	fake.listContainersMutex.Lock()
	ret, specificReturn := fake.listContainersReturnsOnCall[len(fake.listContainersArgsForCall)]
	fake.listContainersArgsForCall = append(fake.listContainersArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	fake.recordInvocation("ListContainers", []interface{}{arg1})
	fake.listContainersMutex.Unlock()
	if fake.ListContainersStub != nil {
		return fake.ListContainersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) ListContainersCallCount() int {
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	return len(fake.listContainersArgsForCall)
}

func (fake *FakeTeam) ListContainersArgsForCall(i int) map[string]string {
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	argsForCall := fake.listContainersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) ListContainersReturns(result1 []atc.Container, result2 error) {
	fake.ListContainersStub = nil
	fake.listContainersReturns = struct {
		result1 []atc.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListContainersReturnsOnCall(i int, result1 []atc.Container, result2 error) {
	fake.ListContainersStub = nil
	if fake.listContainersReturnsOnCall == nil {
		fake.listContainersReturnsOnCall = make(map[int]struct {
			result1 []atc.Container
			result2 error
		})
	}
	fake.listContainersReturnsOnCall[i] = struct {
		result1 []atc.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListJobs(arg1 string) ([]atc.Job, error) {
	fake.listJobsMutex.Lock()
	ret, specificReturn := fake.listJobsReturnsOnCall[len(fake.listJobsArgsForCall)]
	fake.listJobsArgsForCall = append(fake.listJobsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListJobs", []interface{}{arg1})
	fake.listJobsMutex.Unlock()
	if fake.ListJobsStub != nil {
		return fake.ListJobsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listJobsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) ListJobsCallCount() int {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	return len(fake.listJobsArgsForCall)
}

func (fake *FakeTeam) ListJobsArgsForCall(i int) string {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	argsForCall := fake.listJobsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) ListJobsReturns(result1 []atc.Job, result2 error) {
	fake.ListJobsStub = nil
	fake.listJobsReturns = struct {
		result1 []atc.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListJobsReturnsOnCall(i int, result1 []atc.Job, result2 error) {
	fake.ListJobsStub = nil
	if fake.listJobsReturnsOnCall == nil {
		fake.listJobsReturnsOnCall = make(map[int]struct {
			result1 []atc.Job
			result2 error
		})
	}
	fake.listJobsReturnsOnCall[i] = struct {
		result1 []atc.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListPipelines() ([]atc.Pipeline, error) {
	fake.listPipelinesMutex.Lock()
	ret, specificReturn := fake.listPipelinesReturnsOnCall[len(fake.listPipelinesArgsForCall)]
	fake.listPipelinesArgsForCall = append(fake.listPipelinesArgsForCall, struct {
	}{})
	fake.recordInvocation("ListPipelines", []interface{}{})
	fake.listPipelinesMutex.Unlock()
	if fake.ListPipelinesStub != nil {
		return fake.ListPipelinesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPipelinesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) ListPipelinesCallCount() int {
	fake.listPipelinesMutex.RLock()
	defer fake.listPipelinesMutex.RUnlock()
	return len(fake.listPipelinesArgsForCall)
}

func (fake *FakeTeam) ListPipelinesReturns(result1 []atc.Pipeline, result2 error) {
	fake.ListPipelinesStub = nil
	fake.listPipelinesReturns = struct {
		result1 []atc.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListPipelinesReturnsOnCall(i int, result1 []atc.Pipeline, result2 error) {
	fake.ListPipelinesStub = nil
	if fake.listPipelinesReturnsOnCall == nil {
		fake.listPipelinesReturnsOnCall = make(map[int]struct {
			result1 []atc.Pipeline
			result2 error
		})
	}
	fake.listPipelinesReturnsOnCall[i] = struct {
		result1 []atc.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListVolumes() ([]atc.Volume, error) {
	fake.listVolumesMutex.Lock()
	ret, specificReturn := fake.listVolumesReturnsOnCall[len(fake.listVolumesArgsForCall)]
	fake.listVolumesArgsForCall = append(fake.listVolumesArgsForCall, struct {
	}{})
	fake.recordInvocation("ListVolumes", []interface{}{})
	fake.listVolumesMutex.Unlock()
	if fake.ListVolumesStub != nil {
		return fake.ListVolumesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listVolumesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) ListVolumesCallCount() int {
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	return len(fake.listVolumesArgsForCall)
}

func (fake *FakeTeam) ListVolumesReturns(result1 []atc.Volume, result2 error) {
	fake.ListVolumesStub = nil
	fake.listVolumesReturns = struct {
		result1 []atc.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListVolumesReturnsOnCall(i int, result1 []atc.Volume, result2 error) {
	fake.ListVolumesStub = nil
	if fake.listVolumesReturnsOnCall == nil {
		fake.listVolumesReturnsOnCall = make(map[int]struct {
			result1 []atc.Volume
			result2 error
		})
	}
	fake.listVolumesReturnsOnCall[i] = struct {
		result1 []atc.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeTeam) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeam) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeam) OrderingPipelines(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.orderingPipelinesMutex.Lock()
	ret, specificReturn := fake.orderingPipelinesReturnsOnCall[len(fake.orderingPipelinesArgsForCall)]
	fake.orderingPipelinesArgsForCall = append(fake.orderingPipelinesArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("OrderingPipelines", []interface{}{arg1Copy})
	fake.orderingPipelinesMutex.Unlock()
	if fake.OrderingPipelinesStub != nil {
		return fake.OrderingPipelinesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.orderingPipelinesReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) OrderingPipelinesCallCount() int {
	fake.orderingPipelinesMutex.RLock()
	defer fake.orderingPipelinesMutex.RUnlock()
	return len(fake.orderingPipelinesArgsForCall)
}

func (fake *FakeTeam) OrderingPipelinesArgsForCall(i int) []string {
	fake.orderingPipelinesMutex.RLock()
	defer fake.orderingPipelinesMutex.RUnlock()
	argsForCall := fake.orderingPipelinesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) OrderingPipelinesReturns(result1 error) {
	fake.OrderingPipelinesStub = nil
	fake.orderingPipelinesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) OrderingPipelinesReturnsOnCall(i int, result1 error) {
	fake.OrderingPipelinesStub = nil
	if fake.orderingPipelinesReturnsOnCall == nil {
		fake.orderingPipelinesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.orderingPipelinesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) PauseJob(arg1 string, arg2 string) (bool, error) {
	fake.pauseJobMutex.Lock()
	ret, specificReturn := fake.pauseJobReturnsOnCall[len(fake.pauseJobArgsForCall)]
	fake.pauseJobArgsForCall = append(fake.pauseJobArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("PauseJob", []interface{}{arg1, arg2})
	fake.pauseJobMutex.Unlock()
	if fake.PauseJobStub != nil {
		return fake.PauseJobStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pauseJobReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) PauseJobCallCount() int {
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	return len(fake.pauseJobArgsForCall)
}

func (fake *FakeTeam) PauseJobArgsForCall(i int) (string, string) {
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	argsForCall := fake.pauseJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) PauseJobReturns(result1 bool, result2 error) {
	fake.PauseJobStub = nil
	fake.pauseJobReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PauseJobReturnsOnCall(i int, result1 bool, result2 error) {
	fake.PauseJobStub = nil
	if fake.pauseJobReturnsOnCall == nil {
		fake.pauseJobReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pauseJobReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PausePipeline(arg1 string) (bool, error) {
	fake.pausePipelineMutex.Lock()
	ret, specificReturn := fake.pausePipelineReturnsOnCall[len(fake.pausePipelineArgsForCall)]
	fake.pausePipelineArgsForCall = append(fake.pausePipelineArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("PausePipeline", []interface{}{arg1})
	fake.pausePipelineMutex.Unlock()
	if fake.PausePipelineStub != nil {
		return fake.PausePipelineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pausePipelineReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) PausePipelineCallCount() int {
	fake.pausePipelineMutex.RLock()
	defer fake.pausePipelineMutex.RUnlock()
	return len(fake.pausePipelineArgsForCall)
}

func (fake *FakeTeam) PausePipelineArgsForCall(i int) string {
	fake.pausePipelineMutex.RLock()
	defer fake.pausePipelineMutex.RUnlock()
	argsForCall := fake.pausePipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) PausePipelineReturns(result1 bool, result2 error) {
	fake.PausePipelineStub = nil
	fake.pausePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PausePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.PausePipelineStub = nil
	if fake.pausePipelineReturnsOnCall == nil {
		fake.pausePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pausePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PauseResource(arg1 string, arg2 string) (bool, error) {
	fake.pauseResourceMutex.Lock()
	ret, specificReturn := fake.pauseResourceReturnsOnCall[len(fake.pauseResourceArgsForCall)]
	fake.pauseResourceArgsForCall = append(fake.pauseResourceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("PauseResource", []interface{}{arg1, arg2})
	fake.pauseResourceMutex.Unlock()
	if fake.PauseResourceStub != nil {
		return fake.PauseResourceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pauseResourceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) PauseResourceCallCount() int {
	fake.pauseResourceMutex.RLock()
	defer fake.pauseResourceMutex.RUnlock()
	return len(fake.pauseResourceArgsForCall)
}

func (fake *FakeTeam) PauseResourceArgsForCall(i int) (string, string) {
	fake.pauseResourceMutex.RLock()
	defer fake.pauseResourceMutex.RUnlock()
	argsForCall := fake.pauseResourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) PauseResourceReturns(result1 bool, result2 error) {
	fake.PauseResourceStub = nil
	fake.pauseResourceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PauseResourceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.PauseResourceStub = nil
	if fake.pauseResourceReturnsOnCall == nil {
		fake.pauseResourceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pauseResourceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Pipeline(arg1 string) (atc.Pipeline, bool, error) {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Pipeline", []interface{}{arg1})
	fake.pipelineMutex.Unlock()
	if fake.PipelineStub != nil {
		return fake.PipelineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.pipelineReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeTeam) PipelineArgsForCall(i int) string {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	argsForCall := fake.pipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) PipelineReturns(result1 atc.Pipeline, result2 bool, result3 error) {
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 atc.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) PipelineReturnsOnCall(i int, result1 atc.Pipeline, result2 bool, result3 error) {
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 atc.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 atc.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) PipelineBuilds(arg1 string, arg2 concourse.Page) ([]atc.Build, concourse.Pagination, bool, error) {
	fake.pipelineBuildsMutex.Lock()
	ret, specificReturn := fake.pipelineBuildsReturnsOnCall[len(fake.pipelineBuildsArgsForCall)]
	fake.pipelineBuildsArgsForCall = append(fake.pipelineBuildsArgsForCall, struct {
		arg1 string
		arg2 concourse.Page
	}{arg1, arg2})
	fake.recordInvocation("PipelineBuilds", []interface{}{arg1, arg2})
	fake.pipelineBuildsMutex.Unlock()
	if fake.PipelineBuildsStub != nil {
		return fake.PipelineBuildsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.pipelineBuildsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeTeam) PipelineBuildsCallCount() int {
	fake.pipelineBuildsMutex.RLock()
	defer fake.pipelineBuildsMutex.RUnlock()
	return len(fake.pipelineBuildsArgsForCall)
}

func (fake *FakeTeam) PipelineBuildsArgsForCall(i int) (string, concourse.Page) {
	fake.pipelineBuildsMutex.RLock()
	defer fake.pipelineBuildsMutex.RUnlock()
	argsForCall := fake.pipelineBuildsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) PipelineBuildsReturns(result1 []atc.Build, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.PipelineBuildsStub = nil
	fake.pipelineBuildsReturns = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) PipelineBuildsReturnsOnCall(i int, result1 []atc.Build, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.PipelineBuildsStub = nil
	if fake.pipelineBuildsReturnsOnCall == nil {
		fake.pipelineBuildsReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 concourse.Pagination
			result3 bool
			result4 error
		})
	}
	fake.pipelineBuildsReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) PipelineConfig(arg1 string) (atc.Config, atc.RawConfig, string, bool, error) {
	fake.pipelineConfigMutex.Lock()
	ret, specificReturn := fake.pipelineConfigReturnsOnCall[len(fake.pipelineConfigArgsForCall)]
	fake.pipelineConfigArgsForCall = append(fake.pipelineConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("PipelineConfig", []interface{}{arg1})
	fake.pipelineConfigMutex.Unlock()
	if fake.PipelineConfigStub != nil {
		return fake.PipelineConfigStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4, ret.result5
	}
	fakeReturns := fake.pipelineConfigReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4, fakeReturns.result5
}

func (fake *FakeTeam) PipelineConfigCallCount() int {
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	return len(fake.pipelineConfigArgsForCall)
}

func (fake *FakeTeam) PipelineConfigArgsForCall(i int) string {
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	argsForCall := fake.pipelineConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) PipelineConfigReturns(result1 atc.Config, result2 atc.RawConfig, result3 string, result4 bool, result5 error) {
	fake.PipelineConfigStub = nil
	fake.pipelineConfigReturns = struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeTeam) PipelineConfigReturnsOnCall(i int, result1 atc.Config, result2 atc.RawConfig, result3 string, result4 bool, result5 error) {
	fake.PipelineConfigStub = nil
	if fake.pipelineConfigReturnsOnCall == nil {
		fake.pipelineConfigReturnsOnCall = make(map[int]struct {
			result1 atc.Config
			result2 atc.RawConfig
			result3 string
			result4 bool
			result5 error
		})
	}
	fake.pipelineConfigReturnsOnCall[i] = struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeTeam) RenamePipeline(arg1 string, arg2 string) (bool, error) {
	fake.renamePipelineMutex.Lock()
	ret, specificReturn := fake.renamePipelineReturnsOnCall[len(fake.renamePipelineArgsForCall)]
	fake.renamePipelineArgsForCall = append(fake.renamePipelineArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RenamePipeline", []interface{}{arg1, arg2})
	fake.renamePipelineMutex.Unlock()
	if fake.RenamePipelineStub != nil {
		return fake.RenamePipelineStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.renamePipelineReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) RenamePipelineCallCount() int {
	fake.renamePipelineMutex.RLock()
	defer fake.renamePipelineMutex.RUnlock()
	return len(fake.renamePipelineArgsForCall)
}

func (fake *FakeTeam) RenamePipelineArgsForCall(i int) (string, string) {
	fake.renamePipelineMutex.RLock()
	defer fake.renamePipelineMutex.RUnlock()
	argsForCall := fake.renamePipelineArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) RenamePipelineReturns(result1 bool, result2 error) {
	fake.RenamePipelineStub = nil
	fake.renamePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) RenamePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.RenamePipelineStub = nil
	if fake.renamePipelineReturnsOnCall == nil {
		fake.renamePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.renamePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) RenameTeam(arg1 string, arg2 string) (bool, error) {
	fake.renameTeamMutex.Lock()
	ret, specificReturn := fake.renameTeamReturnsOnCall[len(fake.renameTeamArgsForCall)]
	fake.renameTeamArgsForCall = append(fake.renameTeamArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RenameTeam", []interface{}{arg1, arg2})
	fake.renameTeamMutex.Unlock()
	if fake.RenameTeamStub != nil {
		return fake.RenameTeamStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.renameTeamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) RenameTeamCallCount() int {
	fake.renameTeamMutex.RLock()
	defer fake.renameTeamMutex.RUnlock()
	return len(fake.renameTeamArgsForCall)
}

func (fake *FakeTeam) RenameTeamArgsForCall(i int) (string, string) {
	fake.renameTeamMutex.RLock()
	defer fake.renameTeamMutex.RUnlock()
	argsForCall := fake.renameTeamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) RenameTeamReturns(result1 bool, result2 error) {
	fake.RenameTeamStub = nil
	fake.renameTeamReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) RenameTeamReturnsOnCall(i int, result1 bool, result2 error) {
	fake.RenameTeamStub = nil
	if fake.renameTeamReturnsOnCall == nil {
		fake.renameTeamReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.renameTeamReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Resource(arg1 string, arg2 string) (atc.Resource, bool, error) {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Resource", []interface{}{arg1, arg2})
	fake.resourceMutex.Unlock()
	if fake.ResourceStub != nil {
		return fake.ResourceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.resourceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakeTeam) ResourceArgsForCall(i int) (string, string) {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	argsForCall := fake.resourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) ResourceReturns(result1 atc.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 atc.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) ResourceReturnsOnCall(i int, result1 atc.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 atc.Resource
			result2 bool
			result3 error
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 atc.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) ResourceVersions(arg1 string, arg2 string, arg3 concourse.Page) ([]atc.VersionedResource, concourse.Pagination, bool, error) {
	fake.resourceVersionsMutex.Lock()
	ret, specificReturn := fake.resourceVersionsReturnsOnCall[len(fake.resourceVersionsArgsForCall)]
	fake.resourceVersionsArgsForCall = append(fake.resourceVersionsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 concourse.Page
	}{arg1, arg2, arg3})
	fake.recordInvocation("ResourceVersions", []interface{}{arg1, arg2, arg3})
	fake.resourceVersionsMutex.Unlock()
	if fake.ResourceVersionsStub != nil {
		return fake.ResourceVersionsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.resourceVersionsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeTeam) ResourceVersionsCallCount() int {
	fake.resourceVersionsMutex.RLock()
	defer fake.resourceVersionsMutex.RUnlock()
	return len(fake.resourceVersionsArgsForCall)
}

func (fake *FakeTeam) ResourceVersionsArgsForCall(i int) (string, string, concourse.Page) {
	fake.resourceVersionsMutex.RLock()
	defer fake.resourceVersionsMutex.RUnlock()
	argsForCall := fake.resourceVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) ResourceVersionsReturns(result1 []atc.VersionedResource, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.ResourceVersionsStub = nil
	fake.resourceVersionsReturns = struct {
		result1 []atc.VersionedResource
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) ResourceVersionsReturnsOnCall(i int, result1 []atc.VersionedResource, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.ResourceVersionsStub = nil
	if fake.resourceVersionsReturnsOnCall == nil {
		fake.resourceVersionsReturnsOnCall = make(map[int]struct {
			result1 []atc.VersionedResource
			result2 concourse.Pagination
			result3 bool
			result4 error
		})
	}
	fake.resourceVersionsReturnsOnCall[i] = struct {
		result1 []atc.VersionedResource
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) UnarchivePipeline(arg1 string) (bool, error) {
	fake.unarchivePipelineMutex.Lock()
	ret, specificReturn := fake.unarchivePipelineReturnsOnCall[len(fake.unarchivePipelineArgsForCall)]
	fake.unarchivePipelineArgsForCall = append(fake.unarchivePipelineArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("UnarchivePipeline", []interface{}{arg1})
	fake.unarchivePipelineMutex.Unlock()
	if fake.UnarchivePipelineStub != nil {
		return fake.UnarchivePipelineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.unarchivePipelineReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) UnarchivePipelineCallCount() int {
	fake.unarchivePipelineMutex.RLock()
	defer fake.unarchivePipelineMutex.RUnlock()
	return len(fake.unarchivePipelineArgsForCall)
}

func (fake *FakeTeam) UnarchivePipelineArgsForCall(i int) string {
	fake.unarchivePipelineMutex.RLock()
	defer fake.unarchivePipelineMutex.RUnlock()
	argsForCall := fake.unarchivePipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) UnarchivePipelineReturns(result1 bool, result2 error) {
	fake.UnarchivePipelineStub = nil
	fake.unarchivePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnarchivePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.UnarchivePipelineStub = nil
	if fake.unarchivePipelineReturnsOnCall == nil {
		fake.unarchivePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unarchivePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpauseJob(arg1 string, arg2 string) (bool, error) {
	fake.unpauseJobMutex.Lock()
	ret, specificReturn := fake.unpauseJobReturnsOnCall[len(fake.unpauseJobArgsForCall)]
	fake.unpauseJobArgsForCall = append(fake.unpauseJobArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("UnpauseJob", []interface{}{arg1, arg2})
	fake.unpauseJobMutex.Unlock()
	if fake.UnpauseJobStub != nil {
		return fake.UnpauseJobStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.unpauseJobReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) UnpauseJobCallCount() int {
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	return len(fake.unpauseJobArgsForCall)
}

func (fake *FakeTeam) UnpauseJobArgsForCall(i int) (string, string) {
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	argsForCall := fake.unpauseJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) UnpauseJobReturns(result1 bool, result2 error) {
	fake.UnpauseJobStub = nil
	fake.unpauseJobReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpauseJobReturnsOnCall(i int, result1 bool, result2 error) {
	fake.UnpauseJobStub = nil
	if fake.unpauseJobReturnsOnCall == nil {
		fake.unpauseJobReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unpauseJobReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpausePipeline(arg1 string) (bool, error) {
	fake.unpausePipelineMutex.Lock()
	ret, specificReturn := fake.unpausePipelineReturnsOnCall[len(fake.unpausePipelineArgsForCall)]
	fake.unpausePipelineArgsForCall = append(fake.unpausePipelineArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("UnpausePipeline", []interface{}{arg1})
	fake.unpausePipelineMutex.Unlock()
	if fake.UnpausePipelineStub != nil {
		return fake.UnpausePipelineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.unpausePipelineReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) UnpausePipelineCallCount() int {
	fake.unpausePipelineMutex.RLock()
	defer fake.unpausePipelineMutex.RUnlock()
	return len(fake.unpausePipelineArgsForCall)
}

func (fake *FakeTeam) UnpausePipelineArgsForCall(i int) string {
	fake.unpausePipelineMutex.RLock()
	defer fake.unpausePipelineMutex.RUnlock()
	argsForCall := fake.unpausePipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) UnpausePipelineReturns(result1 bool, result2 error) {
	fake.UnpausePipelineStub = nil
	fake.unpausePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpausePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.UnpausePipelineStub = nil
	if fake.unpausePipelineReturnsOnCall == nil {
		fake.unpausePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unpausePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpauseResource(arg1 string, arg2 string) (bool, error) {
	fake.unpauseResourceMutex.Lock()
	ret, specificReturn := fake.unpauseResourceReturnsOnCall[len(fake.unpauseResourceArgsForCall)]
	fake.unpauseResourceArgsForCall = append(fake.unpauseResourceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("UnpauseResource", []interface{}{arg1, arg2})
	fake.unpauseResourceMutex.Unlock()
	if fake.UnpauseResourceStub != nil {
		return fake.UnpauseResourceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.unpauseResourceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) UnpauseResourceCallCount() int {
	fake.unpauseResourceMutex.RLock()
	defer fake.unpauseResourceMutex.RUnlock()
	return len(fake.unpauseResourceArgsForCall)
}

func (fake *FakeTeam) UnpauseResourceArgsForCall(i int) (string, string) {
	fake.unpauseResourceMutex.RLock()
	defer fake.unpauseResourceMutex.RUnlock()
	argsForCall := fake.unpauseResourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) UnpauseResourceReturns(result1 bool, result2 error) {
	fake.UnpauseResourceStub = nil
	fake.unpauseResourceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpauseResourceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.UnpauseResourceStub = nil
	if fake.unpauseResourceReturnsOnCall == nil {
		fake.unpauseResourceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unpauseResourceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) VersionedResourceTypes(arg1 string) (atc.VersionedResourceTypes, bool, error) {
	fake.versionedResourceTypesMutex.Lock()
	ret, specificReturn := fake.versionedResourceTypesReturnsOnCall[len(fake.versionedResourceTypesArgsForCall)]
	fake.versionedResourceTypesArgsForCall = append(fake.versionedResourceTypesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("VersionedResourceTypes", []interface{}{arg1})
	fake.versionedResourceTypesMutex.Unlock()
	if fake.VersionedResourceTypesStub != nil {
		return fake.VersionedResourceTypesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.versionedResourceTypesReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) VersionedResourceTypesCallCount() int {
	fake.versionedResourceTypesMutex.RLock()
	defer fake.versionedResourceTypesMutex.RUnlock()
	return len(fake.versionedResourceTypesArgsForCall)
}

func (fake *FakeTeam) VersionedResourceTypesArgsForCall(i int) string {
	fake.versionedResourceTypesMutex.RLock()
	defer fake.versionedResourceTypesMutex.RUnlock()
	argsForCall := fake.versionedResourceTypesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) VersionedResourceTypesReturns(result1 atc.VersionedResourceTypes, result2 bool, result3 error) {
	fake.VersionedResourceTypesStub = nil
	fake.versionedResourceTypesReturns = struct {
		result1 atc.VersionedResourceTypes
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) VersionedResourceTypesReturnsOnCall(i int, result1 atc.VersionedResourceTypes, result2 bool, result3 error) {
	fake.VersionedResourceTypesStub = nil
	if fake.versionedResourceTypesReturnsOnCall == nil {
		fake.versionedResourceTypesReturnsOnCall = make(map[int]struct {
			result1 atc.VersionedResourceTypes
			result2 bool
			result3 error
		})
	}
	fake.versionedResourceTypesReturnsOnCall[i] = struct {
		result1 atc.VersionedResourceTypes
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.archivePipelineMutex.RLock()
	defer fake.archivePipelineMutex.RUnlock()
	fake.buildInputsForJobMutex.RLock()
	defer fake.buildInputsForJobMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.buildsWithVersionAsInputMutex.RLock()
	defer fake.buildsWithVersionAsInputMutex.RUnlock()
	fake.buildsWithVersionAsOutputMutex.RLock()
	defer fake.buildsWithVersionAsOutputMutex.RUnlock()
	fake.checkResourceMutex.RLock()
	defer fake.checkResourceMutex.RUnlock()
	fake.checkResourceTypeMutex.RLock()
	defer fake.checkResourceTypeMutex.RUnlock()
	fake.clearTaskCacheMutex.RLock()
	defer fake.clearTaskCacheMutex.RUnlock()
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.createOrUpdateMutex.RLock()
	defer fake.createOrUpdateMutex.RUnlock()
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	fake.createPipelineBuildMutex.RLock()
	defer fake.createPipelineBuildMutex.RUnlock()
	fake.deletePipelineMutex.RLock()
	defer fake.deletePipelineMutex.RUnlock()
	fake.destroyTeamMutex.RLock()
	defer fake.destroyTeamMutex.RUnlock()
	fake.disableResourceVersionMutex.RLock()
	defer fake.disableResourceVersionMutex.RUnlock()
	fake.enableResourceVersionMutex.RLock()
	defer fake.enableResourceVersionMutex.RUnlock()
	fake.exposePipelineMutex.RLock()
	defer fake.exposePipelineMutex.RUnlock()
	fake.hidePipelineMutex.RLock()
	defer fake.hidePipelineMutex.RUnlock()
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	fake.jobBuildMutex.RLock()
	defer fake.jobBuildMutex.RUnlock()
	fake.jobBuildsMutex.RLock()
	defer fake.jobBuildsMutex.RUnlock()
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	fake.listPipelinesMutex.RLock()
	defer fake.listPipelinesMutex.RUnlock()
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.orderingPipelinesMutex.RLock()
	defer fake.orderingPipelinesMutex.RUnlock()
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	fake.pausePipelineMutex.RLock()
	defer fake.pausePipelineMutex.RUnlock()
	fake.pauseResourceMutex.RLock()
	defer fake.pauseResourceMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.pipelineBuildsMutex.RLock()
	defer fake.pipelineBuildsMutex.RUnlock()
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	fake.renamePipelineMutex.RLock()
	defer fake.renamePipelineMutex.RUnlock()
	fake.renameTeamMutex.RLock()
	defer fake.renameTeamMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.resourceVersionsMutex.RLock()
	defer fake.resourceVersionsMutex.RUnlock()
	fake.unarchivePipelineMutex.RLock()
	defer fake.unarchivePipelineMutex.RUnlock()
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	fake.unpausePipelineMutex.RLock()
	defer fake.unpausePipelineMutex.RUnlock()
	fake.unpauseResourceMutex.RLock()
	defer fake.unpauseResourceMutex.RUnlock()
	fake.versionedResourceTypesMutex.RLock()
	defer fake.versionedResourceTypesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTeam) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ concourse.Team = new(FakeTeam)
