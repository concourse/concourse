// This file was generated by counterfeiter
package workerfakes

import (
	"io"
	"sync"
	"time"

	"code.cloudfoundry.org/garden"
	"github.com/concourse/atc/worker"
)

type FakeContainer struct {
	HandleStub        func() string
	handleMutex       sync.RWMutex
	handleArgsForCall []struct{}
	handleReturns     struct {
		result1 string
	}
	StopStub        func(kill bool) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		kill bool
	}
	stopReturns struct {
		result1 error
	}
	InfoStub        func() (garden.ContainerInfo, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct{}
	infoReturns     struct {
		result1 garden.ContainerInfo
		result2 error
	}
	StreamInStub        func(spec garden.StreamInSpec) error
	streamInMutex       sync.RWMutex
	streamInArgsForCall []struct {
		spec garden.StreamInSpec
	}
	streamInReturns struct {
		result1 error
	}
	StreamOutStub        func(spec garden.StreamOutSpec) (io.ReadCloser, error)
	streamOutMutex       sync.RWMutex
	streamOutArgsForCall []struct {
		spec garden.StreamOutSpec
	}
	streamOutReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	CurrentBandwidthLimitsStub        func() (garden.BandwidthLimits, error)
	currentBandwidthLimitsMutex       sync.RWMutex
	currentBandwidthLimitsArgsForCall []struct{}
	currentBandwidthLimitsReturns     struct {
		result1 garden.BandwidthLimits
		result2 error
	}
	CurrentCPULimitsStub        func() (garden.CPULimits, error)
	currentCPULimitsMutex       sync.RWMutex
	currentCPULimitsArgsForCall []struct{}
	currentCPULimitsReturns     struct {
		result1 garden.CPULimits
		result2 error
	}
	CurrentDiskLimitsStub        func() (garden.DiskLimits, error)
	currentDiskLimitsMutex       sync.RWMutex
	currentDiskLimitsArgsForCall []struct{}
	currentDiskLimitsReturns     struct {
		result1 garden.DiskLimits
		result2 error
	}
	CurrentMemoryLimitsStub        func() (garden.MemoryLimits, error)
	currentMemoryLimitsMutex       sync.RWMutex
	currentMemoryLimitsArgsForCall []struct{}
	currentMemoryLimitsReturns     struct {
		result1 garden.MemoryLimits
		result2 error
	}
	NetInStub        func(hostPort, containerPort uint32) (uint32, uint32, error)
	netInMutex       sync.RWMutex
	netInArgsForCall []struct {
		hostPort      uint32
		containerPort uint32
	}
	netInReturns struct {
		result1 uint32
		result2 uint32
		result3 error
	}
	NetOutStub        func(netOutRule garden.NetOutRule) error
	netOutMutex       sync.RWMutex
	netOutArgsForCall []struct {
		netOutRule garden.NetOutRule
	}
	netOutReturns struct {
		result1 error
	}
	RunStub        func(garden.ProcessSpec, garden.ProcessIO) (garden.Process, error)
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 garden.ProcessSpec
		arg2 garden.ProcessIO
	}
	runReturns struct {
		result1 garden.Process
		result2 error
	}
	AttachStub        func(processID string, io garden.ProcessIO) (garden.Process, error)
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
		processID string
		io        garden.ProcessIO
	}
	attachReturns struct {
		result1 garden.Process
		result2 error
	}
	MetricsStub        func() (garden.Metrics, error)
	metricsMutex       sync.RWMutex
	metricsArgsForCall []struct{}
	metricsReturns     struct {
		result1 garden.Metrics
		result2 error
	}
	SetGraceTimeStub        func(graceTime time.Duration) error
	setGraceTimeMutex       sync.RWMutex
	setGraceTimeArgsForCall []struct {
		graceTime time.Duration
	}
	setGraceTimeReturns struct {
		result1 error
	}
	PropertiesStub        func() (garden.Properties, error)
	propertiesMutex       sync.RWMutex
	propertiesArgsForCall []struct{}
	propertiesReturns     struct {
		result1 garden.Properties
		result2 error
	}
	PropertyStub        func(name string) (string, error)
	propertyMutex       sync.RWMutex
	propertyArgsForCall []struct {
		name string
	}
	propertyReturns struct {
		result1 string
		result2 error
	}
	SetPropertyStub        func(name string, value string) error
	setPropertyMutex       sync.RWMutex
	setPropertyArgsForCall []struct {
		name  string
		value string
	}
	setPropertyReturns struct {
		result1 error
	}
	RemovePropertyStub        func(name string) error
	removePropertyMutex       sync.RWMutex
	removePropertyArgsForCall []struct {
		name string
	}
	removePropertyReturns struct {
		result1 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct{}
	destroyReturns     struct {
		result1 error
	}
	ReleaseStub        func(*time.Duration)
	releaseMutex       sync.RWMutex
	releaseArgsForCall []struct {
		arg1 *time.Duration
	}
	VolumeMountsStub        func() []worker.VolumeMount
	volumeMountsMutex       sync.RWMutex
	volumeMountsArgsForCall []struct{}
	volumeMountsReturns     struct {
		result1 []worker.VolumeMount
	}
	WorkerNameStub        func() string
	workerNameMutex       sync.RWMutex
	workerNameArgsForCall []struct{}
	workerNameReturns     struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainer) Handle() string {
	fake.handleMutex.Lock()
	fake.handleArgsForCall = append(fake.handleArgsForCall, struct{}{})
	fake.recordInvocation("Handle", []interface{}{})
	fake.handleMutex.Unlock()
	if fake.HandleStub != nil {
		return fake.HandleStub()
	} else {
		return fake.handleReturns.result1
	}
}

func (fake *FakeContainer) HandleCallCount() int {
	fake.handleMutex.RLock()
	defer fake.handleMutex.RUnlock()
	return len(fake.handleArgsForCall)
}

func (fake *FakeContainer) HandleReturns(result1 string) {
	fake.HandleStub = nil
	fake.handleReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContainer) Stop(kill bool) error {
	fake.stopMutex.Lock()
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		kill bool
	}{kill})
	fake.recordInvocation("Stop", []interface{}{kill})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub(kill)
	} else {
		return fake.stopReturns.result1
	}
}

func (fake *FakeContainer) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeContainer) StopArgsForCall(i int) bool {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return fake.stopArgsForCall[i].kill
}

func (fake *FakeContainer) StopReturns(result1 error) {
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Info() (garden.ContainerInfo, error) {
	fake.infoMutex.Lock()
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct{}{})
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub()
	} else {
		return fake.infoReturns.result1, fake.infoReturns.result2
	}
}

func (fake *FakeContainer) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeContainer) InfoReturns(result1 garden.ContainerInfo, result2 error) {
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 garden.ContainerInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) StreamIn(spec garden.StreamInSpec) error {
	fake.streamInMutex.Lock()
	fake.streamInArgsForCall = append(fake.streamInArgsForCall, struct {
		spec garden.StreamInSpec
	}{spec})
	fake.recordInvocation("StreamIn", []interface{}{spec})
	fake.streamInMutex.Unlock()
	if fake.StreamInStub != nil {
		return fake.StreamInStub(spec)
	} else {
		return fake.streamInReturns.result1
	}
}

func (fake *FakeContainer) StreamInCallCount() int {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return len(fake.streamInArgsForCall)
}

func (fake *FakeContainer) StreamInArgsForCall(i int) garden.StreamInSpec {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return fake.streamInArgsForCall[i].spec
}

func (fake *FakeContainer) StreamInReturns(result1 error) {
	fake.StreamInStub = nil
	fake.streamInReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) StreamOut(spec garden.StreamOutSpec) (io.ReadCloser, error) {
	fake.streamOutMutex.Lock()
	fake.streamOutArgsForCall = append(fake.streamOutArgsForCall, struct {
		spec garden.StreamOutSpec
	}{spec})
	fake.recordInvocation("StreamOut", []interface{}{spec})
	fake.streamOutMutex.Unlock()
	if fake.StreamOutStub != nil {
		return fake.StreamOutStub(spec)
	} else {
		return fake.streamOutReturns.result1, fake.streamOutReturns.result2
	}
}

func (fake *FakeContainer) StreamOutCallCount() int {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return len(fake.streamOutArgsForCall)
}

func (fake *FakeContainer) StreamOutArgsForCall(i int) garden.StreamOutSpec {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return fake.streamOutArgsForCall[i].spec
}

func (fake *FakeContainer) StreamOutReturns(result1 io.ReadCloser, result2 error) {
	fake.StreamOutStub = nil
	fake.streamOutReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentBandwidthLimits() (garden.BandwidthLimits, error) {
	fake.currentBandwidthLimitsMutex.Lock()
	fake.currentBandwidthLimitsArgsForCall = append(fake.currentBandwidthLimitsArgsForCall, struct{}{})
	fake.recordInvocation("CurrentBandwidthLimits", []interface{}{})
	fake.currentBandwidthLimitsMutex.Unlock()
	if fake.CurrentBandwidthLimitsStub != nil {
		return fake.CurrentBandwidthLimitsStub()
	} else {
		return fake.currentBandwidthLimitsReturns.result1, fake.currentBandwidthLimitsReturns.result2
	}
}

func (fake *FakeContainer) CurrentBandwidthLimitsCallCount() int {
	fake.currentBandwidthLimitsMutex.RLock()
	defer fake.currentBandwidthLimitsMutex.RUnlock()
	return len(fake.currentBandwidthLimitsArgsForCall)
}

func (fake *FakeContainer) CurrentBandwidthLimitsReturns(result1 garden.BandwidthLimits, result2 error) {
	fake.CurrentBandwidthLimitsStub = nil
	fake.currentBandwidthLimitsReturns = struct {
		result1 garden.BandwidthLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentCPULimits() (garden.CPULimits, error) {
	fake.currentCPULimitsMutex.Lock()
	fake.currentCPULimitsArgsForCall = append(fake.currentCPULimitsArgsForCall, struct{}{})
	fake.recordInvocation("CurrentCPULimits", []interface{}{})
	fake.currentCPULimitsMutex.Unlock()
	if fake.CurrentCPULimitsStub != nil {
		return fake.CurrentCPULimitsStub()
	} else {
		return fake.currentCPULimitsReturns.result1, fake.currentCPULimitsReturns.result2
	}
}

func (fake *FakeContainer) CurrentCPULimitsCallCount() int {
	fake.currentCPULimitsMutex.RLock()
	defer fake.currentCPULimitsMutex.RUnlock()
	return len(fake.currentCPULimitsArgsForCall)
}

func (fake *FakeContainer) CurrentCPULimitsReturns(result1 garden.CPULimits, result2 error) {
	fake.CurrentCPULimitsStub = nil
	fake.currentCPULimitsReturns = struct {
		result1 garden.CPULimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentDiskLimits() (garden.DiskLimits, error) {
	fake.currentDiskLimitsMutex.Lock()
	fake.currentDiskLimitsArgsForCall = append(fake.currentDiskLimitsArgsForCall, struct{}{})
	fake.recordInvocation("CurrentDiskLimits", []interface{}{})
	fake.currentDiskLimitsMutex.Unlock()
	if fake.CurrentDiskLimitsStub != nil {
		return fake.CurrentDiskLimitsStub()
	} else {
		return fake.currentDiskLimitsReturns.result1, fake.currentDiskLimitsReturns.result2
	}
}

func (fake *FakeContainer) CurrentDiskLimitsCallCount() int {
	fake.currentDiskLimitsMutex.RLock()
	defer fake.currentDiskLimitsMutex.RUnlock()
	return len(fake.currentDiskLimitsArgsForCall)
}

func (fake *FakeContainer) CurrentDiskLimitsReturns(result1 garden.DiskLimits, result2 error) {
	fake.CurrentDiskLimitsStub = nil
	fake.currentDiskLimitsReturns = struct {
		result1 garden.DiskLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentMemoryLimits() (garden.MemoryLimits, error) {
	fake.currentMemoryLimitsMutex.Lock()
	fake.currentMemoryLimitsArgsForCall = append(fake.currentMemoryLimitsArgsForCall, struct{}{})
	fake.recordInvocation("CurrentMemoryLimits", []interface{}{})
	fake.currentMemoryLimitsMutex.Unlock()
	if fake.CurrentMemoryLimitsStub != nil {
		return fake.CurrentMemoryLimitsStub()
	} else {
		return fake.currentMemoryLimitsReturns.result1, fake.currentMemoryLimitsReturns.result2
	}
}

func (fake *FakeContainer) CurrentMemoryLimitsCallCount() int {
	fake.currentMemoryLimitsMutex.RLock()
	defer fake.currentMemoryLimitsMutex.RUnlock()
	return len(fake.currentMemoryLimitsArgsForCall)
}

func (fake *FakeContainer) CurrentMemoryLimitsReturns(result1 garden.MemoryLimits, result2 error) {
	fake.CurrentMemoryLimitsStub = nil
	fake.currentMemoryLimitsReturns = struct {
		result1 garden.MemoryLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) NetIn(hostPort uint32, containerPort uint32) (uint32, uint32, error) {
	fake.netInMutex.Lock()
	fake.netInArgsForCall = append(fake.netInArgsForCall, struct {
		hostPort      uint32
		containerPort uint32
	}{hostPort, containerPort})
	fake.recordInvocation("NetIn", []interface{}{hostPort, containerPort})
	fake.netInMutex.Unlock()
	if fake.NetInStub != nil {
		return fake.NetInStub(hostPort, containerPort)
	} else {
		return fake.netInReturns.result1, fake.netInReturns.result2, fake.netInReturns.result3
	}
}

func (fake *FakeContainer) NetInCallCount() int {
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	return len(fake.netInArgsForCall)
}

func (fake *FakeContainer) NetInArgsForCall(i int) (uint32, uint32) {
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	return fake.netInArgsForCall[i].hostPort, fake.netInArgsForCall[i].containerPort
}

func (fake *FakeContainer) NetInReturns(result1 uint32, result2 uint32, result3 error) {
	fake.NetInStub = nil
	fake.netInReturns = struct {
		result1 uint32
		result2 uint32
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeContainer) NetOut(netOutRule garden.NetOutRule) error {
	fake.netOutMutex.Lock()
	fake.netOutArgsForCall = append(fake.netOutArgsForCall, struct {
		netOutRule garden.NetOutRule
	}{netOutRule})
	fake.recordInvocation("NetOut", []interface{}{netOutRule})
	fake.netOutMutex.Unlock()
	if fake.NetOutStub != nil {
		return fake.NetOutStub(netOutRule)
	} else {
		return fake.netOutReturns.result1
	}
}

func (fake *FakeContainer) NetOutCallCount() int {
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	return len(fake.netOutArgsForCall)
}

func (fake *FakeContainer) NetOutArgsForCall(i int) garden.NetOutRule {
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	return fake.netOutArgsForCall[i].netOutRule
}

func (fake *FakeContainer) NetOutReturns(result1 error) {
	fake.NetOutStub = nil
	fake.netOutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Run(arg1 garden.ProcessSpec, arg2 garden.ProcessIO) (garden.Process, error) {
	fake.runMutex.Lock()
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 garden.ProcessSpec
		arg2 garden.ProcessIO
	}{arg1, arg2})
	fake.recordInvocation("Run", []interface{}{arg1, arg2})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		return fake.RunStub(arg1, arg2)
	} else {
		return fake.runReturns.result1, fake.runReturns.result2
	}
}

func (fake *FakeContainer) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeContainer) RunArgsForCall(i int) (garden.ProcessSpec, garden.ProcessIO) {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return fake.runArgsForCall[i].arg1, fake.runArgsForCall[i].arg2
}

func (fake *FakeContainer) RunReturns(result1 garden.Process, result2 error) {
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Attach(processID string, io garden.ProcessIO) (garden.Process, error) {
	fake.attachMutex.Lock()
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
		processID string
		io        garden.ProcessIO
	}{processID, io})
	fake.recordInvocation("Attach", []interface{}{processID, io})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		return fake.AttachStub(processID, io)
	} else {
		return fake.attachReturns.result1, fake.attachReturns.result2
	}
}

func (fake *FakeContainer) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeContainer) AttachArgsForCall(i int) (string, garden.ProcessIO) {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return fake.attachArgsForCall[i].processID, fake.attachArgsForCall[i].io
}

func (fake *FakeContainer) AttachReturns(result1 garden.Process, result2 error) {
	fake.AttachStub = nil
	fake.attachReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Metrics() (garden.Metrics, error) {
	fake.metricsMutex.Lock()
	fake.metricsArgsForCall = append(fake.metricsArgsForCall, struct{}{})
	fake.recordInvocation("Metrics", []interface{}{})
	fake.metricsMutex.Unlock()
	if fake.MetricsStub != nil {
		return fake.MetricsStub()
	} else {
		return fake.metricsReturns.result1, fake.metricsReturns.result2
	}
}

func (fake *FakeContainer) MetricsCallCount() int {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return len(fake.metricsArgsForCall)
}

func (fake *FakeContainer) MetricsReturns(result1 garden.Metrics, result2 error) {
	fake.MetricsStub = nil
	fake.metricsReturns = struct {
		result1 garden.Metrics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) SetGraceTime(graceTime time.Duration) error {
	fake.setGraceTimeMutex.Lock()
	fake.setGraceTimeArgsForCall = append(fake.setGraceTimeArgsForCall, struct {
		graceTime time.Duration
	}{graceTime})
	fake.recordInvocation("SetGraceTime", []interface{}{graceTime})
	fake.setGraceTimeMutex.Unlock()
	if fake.SetGraceTimeStub != nil {
		return fake.SetGraceTimeStub(graceTime)
	} else {
		return fake.setGraceTimeReturns.result1
	}
}

func (fake *FakeContainer) SetGraceTimeCallCount() int {
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	return len(fake.setGraceTimeArgsForCall)
}

func (fake *FakeContainer) SetGraceTimeArgsForCall(i int) time.Duration {
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	return fake.setGraceTimeArgsForCall[i].graceTime
}

func (fake *FakeContainer) SetGraceTimeReturns(result1 error) {
	fake.SetGraceTimeStub = nil
	fake.setGraceTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Properties() (garden.Properties, error) {
	fake.propertiesMutex.Lock()
	fake.propertiesArgsForCall = append(fake.propertiesArgsForCall, struct{}{})
	fake.recordInvocation("Properties", []interface{}{})
	fake.propertiesMutex.Unlock()
	if fake.PropertiesStub != nil {
		return fake.PropertiesStub()
	} else {
		return fake.propertiesReturns.result1, fake.propertiesReturns.result2
	}
}

func (fake *FakeContainer) PropertiesCallCount() int {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	return len(fake.propertiesArgsForCall)
}

func (fake *FakeContainer) PropertiesReturns(result1 garden.Properties, result2 error) {
	fake.PropertiesStub = nil
	fake.propertiesReturns = struct {
		result1 garden.Properties
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Property(name string) (string, error) {
	fake.propertyMutex.Lock()
	fake.propertyArgsForCall = append(fake.propertyArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Property", []interface{}{name})
	fake.propertyMutex.Unlock()
	if fake.PropertyStub != nil {
		return fake.PropertyStub(name)
	} else {
		return fake.propertyReturns.result1, fake.propertyReturns.result2
	}
}

func (fake *FakeContainer) PropertyCallCount() int {
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	return len(fake.propertyArgsForCall)
}

func (fake *FakeContainer) PropertyArgsForCall(i int) string {
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	return fake.propertyArgsForCall[i].name
}

func (fake *FakeContainer) PropertyReturns(result1 string, result2 error) {
	fake.PropertyStub = nil
	fake.propertyReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) SetProperty(name string, value string) error {
	fake.setPropertyMutex.Lock()
	fake.setPropertyArgsForCall = append(fake.setPropertyArgsForCall, struct {
		name  string
		value string
	}{name, value})
	fake.recordInvocation("SetProperty", []interface{}{name, value})
	fake.setPropertyMutex.Unlock()
	if fake.SetPropertyStub != nil {
		return fake.SetPropertyStub(name, value)
	} else {
		return fake.setPropertyReturns.result1
	}
}

func (fake *FakeContainer) SetPropertyCallCount() int {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	return len(fake.setPropertyArgsForCall)
}

func (fake *FakeContainer) SetPropertyArgsForCall(i int) (string, string) {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	return fake.setPropertyArgsForCall[i].name, fake.setPropertyArgsForCall[i].value
}

func (fake *FakeContainer) SetPropertyReturns(result1 error) {
	fake.SetPropertyStub = nil
	fake.setPropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) RemoveProperty(name string) error {
	fake.removePropertyMutex.Lock()
	fake.removePropertyArgsForCall = append(fake.removePropertyArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("RemoveProperty", []interface{}{name})
	fake.removePropertyMutex.Unlock()
	if fake.RemovePropertyStub != nil {
		return fake.RemovePropertyStub(name)
	} else {
		return fake.removePropertyReturns.result1
	}
}

func (fake *FakeContainer) RemovePropertyCallCount() int {
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	return len(fake.removePropertyArgsForCall)
}

func (fake *FakeContainer) RemovePropertyArgsForCall(i int) string {
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	return fake.removePropertyArgsForCall[i].name
}

func (fake *FakeContainer) RemovePropertyReturns(result1 error) {
	fake.RemovePropertyStub = nil
	fake.removePropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Destroy() error {
	fake.destroyMutex.Lock()
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct{}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	} else {
		return fake.destroyReturns.result1
	}
}

func (fake *FakeContainer) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeContainer) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Release(arg1 *time.Duration) {
	fake.releaseMutex.Lock()
	fake.releaseArgsForCall = append(fake.releaseArgsForCall, struct {
		arg1 *time.Duration
	}{arg1})
	fake.recordInvocation("Release", []interface{}{arg1})
	fake.releaseMutex.Unlock()
	if fake.ReleaseStub != nil {
		fake.ReleaseStub(arg1)
	}
}

func (fake *FakeContainer) ReleaseCallCount() int {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return len(fake.releaseArgsForCall)
}

func (fake *FakeContainer) ReleaseArgsForCall(i int) *time.Duration {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return fake.releaseArgsForCall[i].arg1
}

func (fake *FakeContainer) VolumeMounts() []worker.VolumeMount {
	fake.volumeMountsMutex.Lock()
	fake.volumeMountsArgsForCall = append(fake.volumeMountsArgsForCall, struct{}{})
	fake.recordInvocation("VolumeMounts", []interface{}{})
	fake.volumeMountsMutex.Unlock()
	if fake.VolumeMountsStub != nil {
		return fake.VolumeMountsStub()
	} else {
		return fake.volumeMountsReturns.result1
	}
}

func (fake *FakeContainer) VolumeMountsCallCount() int {
	fake.volumeMountsMutex.RLock()
	defer fake.volumeMountsMutex.RUnlock()
	return len(fake.volumeMountsArgsForCall)
}

func (fake *FakeContainer) VolumeMountsReturns(result1 []worker.VolumeMount) {
	fake.VolumeMountsStub = nil
	fake.volumeMountsReturns = struct {
		result1 []worker.VolumeMount
	}{result1}
}

func (fake *FakeContainer) WorkerName() string {
	fake.workerNameMutex.Lock()
	fake.workerNameArgsForCall = append(fake.workerNameArgsForCall, struct{}{})
	fake.recordInvocation("WorkerName", []interface{}{})
	fake.workerNameMutex.Unlock()
	if fake.WorkerNameStub != nil {
		return fake.WorkerNameStub()
	} else {
		return fake.workerNameReturns.result1
	}
}

func (fake *FakeContainer) WorkerNameCallCount() int {
	fake.workerNameMutex.RLock()
	defer fake.workerNameMutex.RUnlock()
	return len(fake.workerNameArgsForCall)
}

func (fake *FakeContainer) WorkerNameReturns(result1 string) {
	fake.WorkerNameStub = nil
	fake.workerNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContainer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.handleMutex.RLock()
	defer fake.handleMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	fake.currentBandwidthLimitsMutex.RLock()
	defer fake.currentBandwidthLimitsMutex.RUnlock()
	fake.currentCPULimitsMutex.RLock()
	defer fake.currentCPULimitsMutex.RUnlock()
	fake.currentDiskLimitsMutex.RLock()
	defer fake.currentDiskLimitsMutex.RUnlock()
	fake.currentMemoryLimitsMutex.RLock()
	defer fake.currentMemoryLimitsMutex.RUnlock()
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	fake.volumeMountsMutex.RLock()
	defer fake.volumeMountsMutex.RUnlock()
	fake.workerNameMutex.RLock()
	defer fake.workerNameMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeContainer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ worker.Container = new(FakeContainer)
