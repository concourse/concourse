// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/algorithm"
	"github.com/concourse/atc/db/lock"
)

type FakePipeline struct {
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct{}
	teamIDReturns     struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct{}
	teamNameReturns     struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	GroupsStub        func() atc.GroupConfigs
	groupsMutex       sync.RWMutex
	groupsArgsForCall []struct{}
	groupsReturns     struct {
		result1 atc.GroupConfigs
	}
	groupsReturnsOnCall map[int]struct {
		result1 atc.GroupConfigs
	}
	ConfigVersionStub        func() db.ConfigVersion
	configVersionMutex       sync.RWMutex
	configVersionArgsForCall []struct{}
	configVersionReturns     struct {
		result1 db.ConfigVersion
	}
	configVersionReturnsOnCall map[int]struct {
		result1 db.ConfigVersion
	}
	PublicStub        func() bool
	publicMutex       sync.RWMutex
	publicArgsForCall []struct{}
	publicReturns     struct {
		result1 bool
	}
	publicReturnsOnCall map[int]struct {
		result1 bool
	}
	PausedStub        func() bool
	pausedMutex       sync.RWMutex
	pausedArgsForCall []struct{}
	pausedReturns     struct {
		result1 bool
	}
	pausedReturnsOnCall map[int]struct {
		result1 bool
	}
	ScopedNameStub        func(string) string
	scopedNameMutex       sync.RWMutex
	scopedNameArgsForCall []struct {
		arg1 string
	}
	scopedNameReturns struct {
		result1 string
	}
	scopedNameReturnsOnCall map[int]struct {
		result1 string
	}
	CheckPausedStub        func() (bool, error)
	checkPausedMutex       sync.RWMutex
	checkPausedArgsForCall []struct{}
	checkPausedReturns     struct {
		result1 bool
		result2 error
	}
	checkPausedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct{}
	reloadReturns     struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CausalityStub        func(versionedResourceID int) ([]db.Cause, error)
	causalityMutex       sync.RWMutex
	causalityArgsForCall []struct {
		versionedResourceID int
	}
	causalityReturns struct {
		result1 []db.Cause
		result2 error
	}
	causalityReturnsOnCall map[int]struct {
		result1 []db.Cause
		result2 error
	}
	SetResourceCheckErrorStub        func(db.Resource, error) error
	setResourceCheckErrorMutex       sync.RWMutex
	setResourceCheckErrorArgsForCall []struct {
		arg1 db.Resource
		arg2 error
	}
	setResourceCheckErrorReturns struct {
		result1 error
	}
	setResourceCheckErrorReturnsOnCall map[int]struct {
		result1 error
	}
	SaveResourceVersionsStub        func(atc.ResourceConfig, []atc.Version) error
	saveResourceVersionsMutex       sync.RWMutex
	saveResourceVersionsArgsForCall []struct {
		arg1 atc.ResourceConfig
		arg2 []atc.Version
	}
	saveResourceVersionsReturns struct {
		result1 error
	}
	saveResourceVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	GetResourceVersionsStub        func(resourceName string, page db.Page) ([]db.SavedVersionedResource, db.Pagination, bool, error)
	getResourceVersionsMutex       sync.RWMutex
	getResourceVersionsArgsForCall []struct {
		resourceName string
		page         db.Page
	}
	getResourceVersionsReturns struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}
	getResourceVersionsReturnsOnCall map[int]struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}
	GetAllPendingBuildsStub        func() (map[string][]db.Build, error)
	getAllPendingBuildsMutex       sync.RWMutex
	getAllPendingBuildsArgsForCall []struct{}
	getAllPendingBuildsReturns     struct {
		result1 map[string][]db.Build
		result2 error
	}
	getAllPendingBuildsReturnsOnCall map[int]struct {
		result1 map[string][]db.Build
		result2 error
	}
	GetLatestVersionedResourceStub        func(resourceName string) (db.SavedVersionedResource, bool, error)
	getLatestVersionedResourceMutex       sync.RWMutex
	getLatestVersionedResourceArgsForCall []struct {
		resourceName string
	}
	getLatestVersionedResourceReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	getLatestVersionedResourceReturnsOnCall map[int]struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	GetVersionedResourceByVersionStub        func(atcVersion atc.Version, resourceName string) (db.SavedVersionedResource, bool, error)
	getVersionedResourceByVersionMutex       sync.RWMutex
	getVersionedResourceByVersionArgsForCall []struct {
		atcVersion   atc.Version
		resourceName string
	}
	getVersionedResourceByVersionReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	getVersionedResourceByVersionReturnsOnCall map[int]struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	VersionedResourceStub        func(versionedResourceID int) (db.SavedVersionedResource, bool, error)
	versionedResourceMutex       sync.RWMutex
	versionedResourceArgsForCall []struct {
		versionedResourceID int
	}
	versionedResourceReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	versionedResourceReturnsOnCall map[int]struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	DisableVersionedResourceStub        func(versionedResourceID int) error
	disableVersionedResourceMutex       sync.RWMutex
	disableVersionedResourceArgsForCall []struct {
		versionedResourceID int
	}
	disableVersionedResourceReturns struct {
		result1 error
	}
	disableVersionedResourceReturnsOnCall map[int]struct {
		result1 error
	}
	EnableVersionedResourceStub        func(versionedResourceID int) error
	enableVersionedResourceMutex       sync.RWMutex
	enableVersionedResourceArgsForCall []struct {
		versionedResourceID int
	}
	enableVersionedResourceReturns struct {
		result1 error
	}
	enableVersionedResourceReturnsOnCall map[int]struct {
		result1 error
	}
	GetBuildsWithVersionAsInputStub        func(versionedResourceID int) ([]db.Build, error)
	getBuildsWithVersionAsInputMutex       sync.RWMutex
	getBuildsWithVersionAsInputArgsForCall []struct {
		versionedResourceID int
	}
	getBuildsWithVersionAsInputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsInputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	GetBuildsWithVersionAsOutputStub        func(versionedResourceID int) ([]db.Build, error)
	getBuildsWithVersionAsOutputMutex       sync.RWMutex
	getBuildsWithVersionAsOutputArgsForCall []struct {
		versionedResourceID int
	}
	getBuildsWithVersionAsOutputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsOutputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	DeleteBuildEventsByBuildIDsStub        func(buildIDs []int) error
	deleteBuildEventsByBuildIDsMutex       sync.RWMutex
	deleteBuildEventsByBuildIDsArgsForCall []struct {
		buildIDs []int
	}
	deleteBuildEventsByBuildIDsReturns struct {
		result1 error
	}
	deleteBuildEventsByBuildIDsReturnsOnCall map[int]struct {
		result1 error
	}
	AcquireSchedulingLockStub        func(lager.Logger, time.Duration) (lock.Lock, bool, error)
	acquireSchedulingLockMutex       sync.RWMutex
	acquireSchedulingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	acquireSchedulingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireSchedulingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AcquireResourceCheckingLockWithIntervalCheckStub        func(logger lager.Logger, resourceName string, usedResourceConfig *db.UsedResourceConfig, interval time.Duration, immediate bool) (lock.Lock, bool, error)
	acquireResourceCheckingLockWithIntervalCheckMutex       sync.RWMutex
	acquireResourceCheckingLockWithIntervalCheckArgsForCall []struct {
		logger             lager.Logger
		resourceName       string
		usedResourceConfig *db.UsedResourceConfig
		interval           time.Duration
		immediate          bool
	}
	acquireResourceCheckingLockWithIntervalCheckReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceCheckingLockWithIntervalCheckReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AcquireResourceTypeCheckingLockWithIntervalCheckStub        func(logger lager.Logger, resourceTypeName string, usedResourceConfig *db.UsedResourceConfig, interval time.Duration, immediate bool) (lock.Lock, bool, error)
	acquireResourceTypeCheckingLockWithIntervalCheckMutex       sync.RWMutex
	acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall []struct {
		logger             lager.Logger
		resourceTypeName   string
		usedResourceConfig *db.UsedResourceConfig
		interval           time.Duration
		immediate          bool
	}
	acquireResourceTypeCheckingLockWithIntervalCheckReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	LoadVersionsDBStub        func() (*algorithm.VersionsDB, error)
	loadVersionsDBMutex       sync.RWMutex
	loadVersionsDBArgsForCall []struct{}
	loadVersionsDBReturns     struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	loadVersionsDBReturnsOnCall map[int]struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	ResourceStub        func(name string) (db.Resource, bool, error)
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
		name string
	}
	resourceReturns struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	resourceReturnsOnCall map[int]struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	ResourcesStub        func() (db.Resources, error)
	resourcesMutex       sync.RWMutex
	resourcesArgsForCall []struct{}
	resourcesReturns     struct {
		result1 db.Resources
		result2 error
	}
	resourcesReturnsOnCall map[int]struct {
		result1 db.Resources
		result2 error
	}
	ResourceTypesStub        func() (db.ResourceTypes, error)
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct{}
	resourceTypesReturns     struct {
		result1 db.ResourceTypes
		result2 error
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 db.ResourceTypes
		result2 error
	}
	ResourceTypeStub        func(name string) (db.ResourceType, bool, error)
	resourceTypeMutex       sync.RWMutex
	resourceTypeArgsForCall []struct {
		name string
	}
	resourceTypeReturns struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}
	resourceTypeReturnsOnCall map[int]struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}
	JobStub        func(name string) (db.Job, bool, error)
	jobMutex       sync.RWMutex
	jobArgsForCall []struct {
		name string
	}
	jobReturns struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	jobReturnsOnCall map[int]struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	JobsStub        func() (db.Jobs, error)
	jobsMutex       sync.RWMutex
	jobsArgsForCall []struct{}
	jobsReturns     struct {
		result1 db.Jobs
		result2 error
	}
	jobsReturnsOnCall map[int]struct {
		result1 db.Jobs
		result2 error
	}
	DashboardStub        func(include string) (db.Dashboard, atc.GroupConfigs, error)
	dashboardMutex       sync.RWMutex
	dashboardArgsForCall []struct {
		include string
	}
	dashboardReturns struct {
		result1 db.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}
	dashboardReturnsOnCall map[int]struct {
		result1 db.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}
	ExposeStub        func() error
	exposeMutex       sync.RWMutex
	exposeArgsForCall []struct{}
	exposeReturns     struct {
		result1 error
	}
	exposeReturnsOnCall map[int]struct {
		result1 error
	}
	HideStub        func() error
	hideMutex       sync.RWMutex
	hideArgsForCall []struct{}
	hideReturns     struct {
		result1 error
	}
	hideReturnsOnCall map[int]struct {
		result1 error
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct{}
	pauseReturns     struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	UnpauseStub        func() error
	unpauseMutex       sync.RWMutex
	unpauseArgsForCall []struct{}
	unpauseReturns     struct {
		result1 error
	}
	unpauseReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct{}
	destroyReturns     struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	RenameStub        func(string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	CreateOneOffBuildStub        func() (db.Build, error)
	createOneOffBuildMutex       sync.RWMutex
	createOneOffBuildArgsForCall []struct{}
	createOneOffBuildReturns     struct {
		result1 db.Build
		result2 error
	}
	createOneOffBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePipeline) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakePipeline) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakePipeline) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakePipeline) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakePipeline) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct{}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamIDReturns.result1
}

func (fake *FakePipeline) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakePipeline) TeamIDReturns(result1 int) {
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamIDReturnsOnCall(i int, result1 int) {
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct{}{})
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if fake.TeamNameStub != nil {
		return fake.TeamNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamNameReturns.result1
}

func (fake *FakePipeline) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakePipeline) TeamNameReturns(result1 string) {
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) TeamNameReturnsOnCall(i int, result1 string) {
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) Groups() atc.GroupConfigs {
	fake.groupsMutex.Lock()
	ret, specificReturn := fake.groupsReturnsOnCall[len(fake.groupsArgsForCall)]
	fake.groupsArgsForCall = append(fake.groupsArgsForCall, struct{}{})
	fake.recordInvocation("Groups", []interface{}{})
	fake.groupsMutex.Unlock()
	if fake.GroupsStub != nil {
		return fake.GroupsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.groupsReturns.result1
}

func (fake *FakePipeline) GroupsCallCount() int {
	fake.groupsMutex.RLock()
	defer fake.groupsMutex.RUnlock()
	return len(fake.groupsArgsForCall)
}

func (fake *FakePipeline) GroupsReturns(result1 atc.GroupConfigs) {
	fake.GroupsStub = nil
	fake.groupsReturns = struct {
		result1 atc.GroupConfigs
	}{result1}
}

func (fake *FakePipeline) GroupsReturnsOnCall(i int, result1 atc.GroupConfigs) {
	fake.GroupsStub = nil
	if fake.groupsReturnsOnCall == nil {
		fake.groupsReturnsOnCall = make(map[int]struct {
			result1 atc.GroupConfigs
		})
	}
	fake.groupsReturnsOnCall[i] = struct {
		result1 atc.GroupConfigs
	}{result1}
}

func (fake *FakePipeline) ConfigVersion() db.ConfigVersion {
	fake.configVersionMutex.Lock()
	ret, specificReturn := fake.configVersionReturnsOnCall[len(fake.configVersionArgsForCall)]
	fake.configVersionArgsForCall = append(fake.configVersionArgsForCall, struct{}{})
	fake.recordInvocation("ConfigVersion", []interface{}{})
	fake.configVersionMutex.Unlock()
	if fake.ConfigVersionStub != nil {
		return fake.ConfigVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configVersionReturns.result1
}

func (fake *FakePipeline) ConfigVersionCallCount() int {
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	return len(fake.configVersionArgsForCall)
}

func (fake *FakePipeline) ConfigVersionReturns(result1 db.ConfigVersion) {
	fake.ConfigVersionStub = nil
	fake.configVersionReturns = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) ConfigVersionReturnsOnCall(i int, result1 db.ConfigVersion) {
	fake.ConfigVersionStub = nil
	if fake.configVersionReturnsOnCall == nil {
		fake.configVersionReturnsOnCall = make(map[int]struct {
			result1 db.ConfigVersion
		})
	}
	fake.configVersionReturnsOnCall[i] = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) Public() bool {
	fake.publicMutex.Lock()
	ret, specificReturn := fake.publicReturnsOnCall[len(fake.publicArgsForCall)]
	fake.publicArgsForCall = append(fake.publicArgsForCall, struct{}{})
	fake.recordInvocation("Public", []interface{}{})
	fake.publicMutex.Unlock()
	if fake.PublicStub != nil {
		return fake.PublicStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.publicReturns.result1
}

func (fake *FakePipeline) PublicCallCount() int {
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	return len(fake.publicArgsForCall)
}

func (fake *FakePipeline) PublicReturns(result1 bool) {
	fake.PublicStub = nil
	fake.publicReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PublicReturnsOnCall(i int, result1 bool) {
	fake.PublicStub = nil
	if fake.publicReturnsOnCall == nil {
		fake.publicReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.publicReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) Paused() bool {
	fake.pausedMutex.Lock()
	ret, specificReturn := fake.pausedReturnsOnCall[len(fake.pausedArgsForCall)]
	fake.pausedArgsForCall = append(fake.pausedArgsForCall, struct{}{})
	fake.recordInvocation("Paused", []interface{}{})
	fake.pausedMutex.Unlock()
	if fake.PausedStub != nil {
		return fake.PausedStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pausedReturns.result1
}

func (fake *FakePipeline) PausedCallCount() int {
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	return len(fake.pausedArgsForCall)
}

func (fake *FakePipeline) PausedReturns(result1 bool) {
	fake.PausedStub = nil
	fake.pausedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PausedReturnsOnCall(i int, result1 bool) {
	fake.PausedStub = nil
	if fake.pausedReturnsOnCall == nil {
		fake.pausedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pausedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) ScopedName(arg1 string) string {
	fake.scopedNameMutex.Lock()
	ret, specificReturn := fake.scopedNameReturnsOnCall[len(fake.scopedNameArgsForCall)]
	fake.scopedNameArgsForCall = append(fake.scopedNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ScopedName", []interface{}{arg1})
	fake.scopedNameMutex.Unlock()
	if fake.ScopedNameStub != nil {
		return fake.ScopedNameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.scopedNameReturns.result1
}

func (fake *FakePipeline) ScopedNameCallCount() int {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	return len(fake.scopedNameArgsForCall)
}

func (fake *FakePipeline) ScopedNameArgsForCall(i int) string {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	return fake.scopedNameArgsForCall[i].arg1
}

func (fake *FakePipeline) ScopedNameReturns(result1 string) {
	fake.ScopedNameStub = nil
	fake.scopedNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) ScopedNameReturnsOnCall(i int, result1 string) {
	fake.ScopedNameStub = nil
	if fake.scopedNameReturnsOnCall == nil {
		fake.scopedNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.scopedNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) CheckPaused() (bool, error) {
	fake.checkPausedMutex.Lock()
	ret, specificReturn := fake.checkPausedReturnsOnCall[len(fake.checkPausedArgsForCall)]
	fake.checkPausedArgsForCall = append(fake.checkPausedArgsForCall, struct{}{})
	fake.recordInvocation("CheckPaused", []interface{}{})
	fake.checkPausedMutex.Unlock()
	if fake.CheckPausedStub != nil {
		return fake.CheckPausedStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.checkPausedReturns.result1, fake.checkPausedReturns.result2
}

func (fake *FakePipeline) CheckPausedCallCount() int {
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	return len(fake.checkPausedArgsForCall)
}

func (fake *FakePipeline) CheckPausedReturns(result1 bool, result2 error) {
	fake.CheckPausedStub = nil
	fake.checkPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CheckPausedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CheckPausedStub = nil
	if fake.checkPausedReturnsOnCall == nil {
		fake.checkPausedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkPausedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct{}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.reloadReturns.result1, fake.reloadReturns.result2
}

func (fake *FakePipeline) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakePipeline) ReloadReturns(result1 bool, result2 error) {
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Causality(versionedResourceID int) ([]db.Cause, error) {
	fake.causalityMutex.Lock()
	ret, specificReturn := fake.causalityReturnsOnCall[len(fake.causalityArgsForCall)]
	fake.causalityArgsForCall = append(fake.causalityArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("Causality", []interface{}{versionedResourceID})
	fake.causalityMutex.Unlock()
	if fake.CausalityStub != nil {
		return fake.CausalityStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.causalityReturns.result1, fake.causalityReturns.result2
}

func (fake *FakePipeline) CausalityCallCount() int {
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	return len(fake.causalityArgsForCall)
}

func (fake *FakePipeline) CausalityArgsForCall(i int) int {
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	return fake.causalityArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) CausalityReturns(result1 []db.Cause, result2 error) {
	fake.CausalityStub = nil
	fake.causalityReturns = struct {
		result1 []db.Cause
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CausalityReturnsOnCall(i int, result1 []db.Cause, result2 error) {
	fake.CausalityStub = nil
	if fake.causalityReturnsOnCall == nil {
		fake.causalityReturnsOnCall = make(map[int]struct {
			result1 []db.Cause
			result2 error
		})
	}
	fake.causalityReturnsOnCall[i] = struct {
		result1 []db.Cause
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) SetResourceCheckError(arg1 db.Resource, arg2 error) error {
	fake.setResourceCheckErrorMutex.Lock()
	ret, specificReturn := fake.setResourceCheckErrorReturnsOnCall[len(fake.setResourceCheckErrorArgsForCall)]
	fake.setResourceCheckErrorArgsForCall = append(fake.setResourceCheckErrorArgsForCall, struct {
		arg1 db.Resource
		arg2 error
	}{arg1, arg2})
	fake.recordInvocation("SetResourceCheckError", []interface{}{arg1, arg2})
	fake.setResourceCheckErrorMutex.Unlock()
	if fake.SetResourceCheckErrorStub != nil {
		return fake.SetResourceCheckErrorStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setResourceCheckErrorReturns.result1
}

func (fake *FakePipeline) SetResourceCheckErrorCallCount() int {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	return len(fake.setResourceCheckErrorArgsForCall)
}

func (fake *FakePipeline) SetResourceCheckErrorArgsForCall(i int) (db.Resource, error) {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	return fake.setResourceCheckErrorArgsForCall[i].arg1, fake.setResourceCheckErrorArgsForCall[i].arg2
}

func (fake *FakePipeline) SetResourceCheckErrorReturns(result1 error) {
	fake.SetResourceCheckErrorStub = nil
	fake.setResourceCheckErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SetResourceCheckErrorReturnsOnCall(i int, result1 error) {
	fake.SetResourceCheckErrorStub = nil
	if fake.setResourceCheckErrorReturnsOnCall == nil {
		fake.setResourceCheckErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setResourceCheckErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SaveResourceVersions(arg1 atc.ResourceConfig, arg2 []atc.Version) error {
	var arg2Copy []atc.Version
	if arg2 != nil {
		arg2Copy = make([]atc.Version, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.saveResourceVersionsMutex.Lock()
	ret, specificReturn := fake.saveResourceVersionsReturnsOnCall[len(fake.saveResourceVersionsArgsForCall)]
	fake.saveResourceVersionsArgsForCall = append(fake.saveResourceVersionsArgsForCall, struct {
		arg1 atc.ResourceConfig
		arg2 []atc.Version
	}{arg1, arg2Copy})
	fake.recordInvocation("SaveResourceVersions", []interface{}{arg1, arg2Copy})
	fake.saveResourceVersionsMutex.Unlock()
	if fake.SaveResourceVersionsStub != nil {
		return fake.SaveResourceVersionsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveResourceVersionsReturns.result1
}

func (fake *FakePipeline) SaveResourceVersionsCallCount() int {
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	return len(fake.saveResourceVersionsArgsForCall)
}

func (fake *FakePipeline) SaveResourceVersionsArgsForCall(i int) (atc.ResourceConfig, []atc.Version) {
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	return fake.saveResourceVersionsArgsForCall[i].arg1, fake.saveResourceVersionsArgsForCall[i].arg2
}

func (fake *FakePipeline) SaveResourceVersionsReturns(result1 error) {
	fake.SaveResourceVersionsStub = nil
	fake.saveResourceVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SaveResourceVersionsReturnsOnCall(i int, result1 error) {
	fake.SaveResourceVersionsStub = nil
	if fake.saveResourceVersionsReturnsOnCall == nil {
		fake.saveResourceVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveResourceVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetResourceVersions(resourceName string, page db.Page) ([]db.SavedVersionedResource, db.Pagination, bool, error) {
	fake.getResourceVersionsMutex.Lock()
	ret, specificReturn := fake.getResourceVersionsReturnsOnCall[len(fake.getResourceVersionsArgsForCall)]
	fake.getResourceVersionsArgsForCall = append(fake.getResourceVersionsArgsForCall, struct {
		resourceName string
		page         db.Page
	}{resourceName, page})
	fake.recordInvocation("GetResourceVersions", []interface{}{resourceName, page})
	fake.getResourceVersionsMutex.Unlock()
	if fake.GetResourceVersionsStub != nil {
		return fake.GetResourceVersionsStub(resourceName, page)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.getResourceVersionsReturns.result1, fake.getResourceVersionsReturns.result2, fake.getResourceVersionsReturns.result3, fake.getResourceVersionsReturns.result4
}

func (fake *FakePipeline) GetResourceVersionsCallCount() int {
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	return len(fake.getResourceVersionsArgsForCall)
}

func (fake *FakePipeline) GetResourceVersionsArgsForCall(i int) (string, db.Page) {
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	return fake.getResourceVersionsArgsForCall[i].resourceName, fake.getResourceVersionsArgsForCall[i].page
}

func (fake *FakePipeline) GetResourceVersionsReturns(result1 []db.SavedVersionedResource, result2 db.Pagination, result3 bool, result4 error) {
	fake.GetResourceVersionsStub = nil
	fake.getResourceVersionsReturns = struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePipeline) GetResourceVersionsReturnsOnCall(i int, result1 []db.SavedVersionedResource, result2 db.Pagination, result3 bool, result4 error) {
	fake.GetResourceVersionsStub = nil
	if fake.getResourceVersionsReturnsOnCall == nil {
		fake.getResourceVersionsReturnsOnCall = make(map[int]struct {
			result1 []db.SavedVersionedResource
			result2 db.Pagination
			result3 bool
			result4 error
		})
	}
	fake.getResourceVersionsReturnsOnCall[i] = struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePipeline) GetAllPendingBuilds() (map[string][]db.Build, error) {
	fake.getAllPendingBuildsMutex.Lock()
	ret, specificReturn := fake.getAllPendingBuildsReturnsOnCall[len(fake.getAllPendingBuildsArgsForCall)]
	fake.getAllPendingBuildsArgsForCall = append(fake.getAllPendingBuildsArgsForCall, struct{}{})
	fake.recordInvocation("GetAllPendingBuilds", []interface{}{})
	fake.getAllPendingBuildsMutex.Unlock()
	if fake.GetAllPendingBuildsStub != nil {
		return fake.GetAllPendingBuildsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAllPendingBuildsReturns.result1, fake.getAllPendingBuildsReturns.result2
}

func (fake *FakePipeline) GetAllPendingBuildsCallCount() int {
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	return len(fake.getAllPendingBuildsArgsForCall)
}

func (fake *FakePipeline) GetAllPendingBuildsReturns(result1 map[string][]db.Build, result2 error) {
	fake.GetAllPendingBuildsStub = nil
	fake.getAllPendingBuildsReturns = struct {
		result1 map[string][]db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetAllPendingBuildsReturnsOnCall(i int, result1 map[string][]db.Build, result2 error) {
	fake.GetAllPendingBuildsStub = nil
	if fake.getAllPendingBuildsReturnsOnCall == nil {
		fake.getAllPendingBuildsReturnsOnCall = make(map[int]struct {
			result1 map[string][]db.Build
			result2 error
		})
	}
	fake.getAllPendingBuildsReturnsOnCall[i] = struct {
		result1 map[string][]db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetLatestVersionedResource(resourceName string) (db.SavedVersionedResource, bool, error) {
	fake.getLatestVersionedResourceMutex.Lock()
	ret, specificReturn := fake.getLatestVersionedResourceReturnsOnCall[len(fake.getLatestVersionedResourceArgsForCall)]
	fake.getLatestVersionedResourceArgsForCall = append(fake.getLatestVersionedResourceArgsForCall, struct {
		resourceName string
	}{resourceName})
	fake.recordInvocation("GetLatestVersionedResource", []interface{}{resourceName})
	fake.getLatestVersionedResourceMutex.Unlock()
	if fake.GetLatestVersionedResourceStub != nil {
		return fake.GetLatestVersionedResourceStub(resourceName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getLatestVersionedResourceReturns.result1, fake.getLatestVersionedResourceReturns.result2, fake.getLatestVersionedResourceReturns.result3
}

func (fake *FakePipeline) GetLatestVersionedResourceCallCount() int {
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	return len(fake.getLatestVersionedResourceArgsForCall)
}

func (fake *FakePipeline) GetLatestVersionedResourceArgsForCall(i int) string {
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	return fake.getLatestVersionedResourceArgsForCall[i].resourceName
}

func (fake *FakePipeline) GetLatestVersionedResourceReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetLatestVersionedResourceStub = nil
	fake.getLatestVersionedResourceReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetLatestVersionedResourceReturnsOnCall(i int, result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetLatestVersionedResourceStub = nil
	if fake.getLatestVersionedResourceReturnsOnCall == nil {
		fake.getLatestVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 db.SavedVersionedResource
			result2 bool
			result3 error
		})
	}
	fake.getLatestVersionedResourceReturnsOnCall[i] = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetVersionedResourceByVersion(atcVersion atc.Version, resourceName string) (db.SavedVersionedResource, bool, error) {
	fake.getVersionedResourceByVersionMutex.Lock()
	ret, specificReturn := fake.getVersionedResourceByVersionReturnsOnCall[len(fake.getVersionedResourceByVersionArgsForCall)]
	fake.getVersionedResourceByVersionArgsForCall = append(fake.getVersionedResourceByVersionArgsForCall, struct {
		atcVersion   atc.Version
		resourceName string
	}{atcVersion, resourceName})
	fake.recordInvocation("GetVersionedResourceByVersion", []interface{}{atcVersion, resourceName})
	fake.getVersionedResourceByVersionMutex.Unlock()
	if fake.GetVersionedResourceByVersionStub != nil {
		return fake.GetVersionedResourceByVersionStub(atcVersion, resourceName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getVersionedResourceByVersionReturns.result1, fake.getVersionedResourceByVersionReturns.result2, fake.getVersionedResourceByVersionReturns.result3
}

func (fake *FakePipeline) GetVersionedResourceByVersionCallCount() int {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	return len(fake.getVersionedResourceByVersionArgsForCall)
}

func (fake *FakePipeline) GetVersionedResourceByVersionArgsForCall(i int) (atc.Version, string) {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	return fake.getVersionedResourceByVersionArgsForCall[i].atcVersion, fake.getVersionedResourceByVersionArgsForCall[i].resourceName
}

func (fake *FakePipeline) GetVersionedResourceByVersionReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetVersionedResourceByVersionStub = nil
	fake.getVersionedResourceByVersionReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetVersionedResourceByVersionReturnsOnCall(i int, result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetVersionedResourceByVersionStub = nil
	if fake.getVersionedResourceByVersionReturnsOnCall == nil {
		fake.getVersionedResourceByVersionReturnsOnCall = make(map[int]struct {
			result1 db.SavedVersionedResource
			result2 bool
			result3 error
		})
	}
	fake.getVersionedResourceByVersionReturnsOnCall[i] = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) VersionedResource(versionedResourceID int) (db.SavedVersionedResource, bool, error) {
	fake.versionedResourceMutex.Lock()
	ret, specificReturn := fake.versionedResourceReturnsOnCall[len(fake.versionedResourceArgsForCall)]
	fake.versionedResourceArgsForCall = append(fake.versionedResourceArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("VersionedResource", []interface{}{versionedResourceID})
	fake.versionedResourceMutex.Unlock()
	if fake.VersionedResourceStub != nil {
		return fake.VersionedResourceStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.versionedResourceReturns.result1, fake.versionedResourceReturns.result2, fake.versionedResourceReturns.result3
}

func (fake *FakePipeline) VersionedResourceCallCount() int {
	fake.versionedResourceMutex.RLock()
	defer fake.versionedResourceMutex.RUnlock()
	return len(fake.versionedResourceArgsForCall)
}

func (fake *FakePipeline) VersionedResourceArgsForCall(i int) int {
	fake.versionedResourceMutex.RLock()
	defer fake.versionedResourceMutex.RUnlock()
	return fake.versionedResourceArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) VersionedResourceReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.VersionedResourceStub = nil
	fake.versionedResourceReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) VersionedResourceReturnsOnCall(i int, result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.VersionedResourceStub = nil
	if fake.versionedResourceReturnsOnCall == nil {
		fake.versionedResourceReturnsOnCall = make(map[int]struct {
			result1 db.SavedVersionedResource
			result2 bool
			result3 error
		})
	}
	fake.versionedResourceReturnsOnCall[i] = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) DisableVersionedResource(versionedResourceID int) error {
	fake.disableVersionedResourceMutex.Lock()
	ret, specificReturn := fake.disableVersionedResourceReturnsOnCall[len(fake.disableVersionedResourceArgsForCall)]
	fake.disableVersionedResourceArgsForCall = append(fake.disableVersionedResourceArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("DisableVersionedResource", []interface{}{versionedResourceID})
	fake.disableVersionedResourceMutex.Unlock()
	if fake.DisableVersionedResourceStub != nil {
		return fake.DisableVersionedResourceStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.disableVersionedResourceReturns.result1
}

func (fake *FakePipeline) DisableVersionedResourceCallCount() int {
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	return len(fake.disableVersionedResourceArgsForCall)
}

func (fake *FakePipeline) DisableVersionedResourceArgsForCall(i int) int {
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	return fake.disableVersionedResourceArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) DisableVersionedResourceReturns(result1 error) {
	fake.DisableVersionedResourceStub = nil
	fake.disableVersionedResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DisableVersionedResourceReturnsOnCall(i int, result1 error) {
	fake.DisableVersionedResourceStub = nil
	if fake.disableVersionedResourceReturnsOnCall == nil {
		fake.disableVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disableVersionedResourceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) EnableVersionedResource(versionedResourceID int) error {
	fake.enableVersionedResourceMutex.Lock()
	ret, specificReturn := fake.enableVersionedResourceReturnsOnCall[len(fake.enableVersionedResourceArgsForCall)]
	fake.enableVersionedResourceArgsForCall = append(fake.enableVersionedResourceArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("EnableVersionedResource", []interface{}{versionedResourceID})
	fake.enableVersionedResourceMutex.Unlock()
	if fake.EnableVersionedResourceStub != nil {
		return fake.EnableVersionedResourceStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.enableVersionedResourceReturns.result1
}

func (fake *FakePipeline) EnableVersionedResourceCallCount() int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	return len(fake.enableVersionedResourceArgsForCall)
}

func (fake *FakePipeline) EnableVersionedResourceArgsForCall(i int) int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	return fake.enableVersionedResourceArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) EnableVersionedResourceReturns(result1 error) {
	fake.EnableVersionedResourceStub = nil
	fake.enableVersionedResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) EnableVersionedResourceReturnsOnCall(i int, result1 error) {
	fake.EnableVersionedResourceStub = nil
	if fake.enableVersionedResourceReturnsOnCall == nil {
		fake.enableVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableVersionedResourceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInput(versionedResourceID int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsInputReturnsOnCall[len(fake.getBuildsWithVersionAsInputArgsForCall)]
	fake.getBuildsWithVersionAsInputArgsForCall = append(fake.getBuildsWithVersionAsInputArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("GetBuildsWithVersionAsInput", []interface{}{versionedResourceID})
	fake.getBuildsWithVersionAsInputMutex.Unlock()
	if fake.GetBuildsWithVersionAsInputStub != nil {
		return fake.GetBuildsWithVersionAsInputStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildsWithVersionAsInputReturns.result1, fake.getBuildsWithVersionAsInputReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputCallCount() int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsInputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return fake.getBuildsWithVersionAsInputArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturns(result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsInputStub = nil
	fake.getBuildsWithVersionAsInputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsInputStub = nil
	if fake.getBuildsWithVersionAsInputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsInputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsInputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutput(versionedResourceID int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsOutputReturnsOnCall[len(fake.getBuildsWithVersionAsOutputArgsForCall)]
	fake.getBuildsWithVersionAsOutputArgsForCall = append(fake.getBuildsWithVersionAsOutputArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("GetBuildsWithVersionAsOutput", []interface{}{versionedResourceID})
	fake.getBuildsWithVersionAsOutputMutex.Unlock()
	if fake.GetBuildsWithVersionAsOutputStub != nil {
		return fake.GetBuildsWithVersionAsOutputStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildsWithVersionAsOutputReturns.result1, fake.getBuildsWithVersionAsOutputReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputCallCount() int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsOutputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return fake.getBuildsWithVersionAsOutputArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturns(result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsOutputStub = nil
	fake.getBuildsWithVersionAsOutputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsOutputStub = nil
	if fake.getBuildsWithVersionAsOutputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsOutputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsOutputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDs(buildIDs []int) error {
	var buildIDsCopy []int
	if buildIDs != nil {
		buildIDsCopy = make([]int, len(buildIDs))
		copy(buildIDsCopy, buildIDs)
	}
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	ret, specificReturn := fake.deleteBuildEventsByBuildIDsReturnsOnCall[len(fake.deleteBuildEventsByBuildIDsArgsForCall)]
	fake.deleteBuildEventsByBuildIDsArgsForCall = append(fake.deleteBuildEventsByBuildIDsArgsForCall, struct {
		buildIDs []int
	}{buildIDsCopy})
	fake.recordInvocation("DeleteBuildEventsByBuildIDs", []interface{}{buildIDsCopy})
	fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	if fake.DeleteBuildEventsByBuildIDsStub != nil {
		return fake.DeleteBuildEventsByBuildIDsStub(buildIDs)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteBuildEventsByBuildIDsReturns.result1
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsCallCount() int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	return len(fake.deleteBuildEventsByBuildIDsArgsForCall)
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsArgsForCall(i int) []int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	return fake.deleteBuildEventsByBuildIDsArgsForCall[i].buildIDs
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturns(result1 error) {
	fake.DeleteBuildEventsByBuildIDsStub = nil
	fake.deleteBuildEventsByBuildIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturnsOnCall(i int, result1 error) {
	fake.DeleteBuildEventsByBuildIDsStub = nil
	if fake.deleteBuildEventsByBuildIDsReturnsOnCall == nil {
		fake.deleteBuildEventsByBuildIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBuildEventsByBuildIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) AcquireSchedulingLock(arg1 lager.Logger, arg2 time.Duration) (lock.Lock, bool, error) {
	fake.acquireSchedulingLockMutex.Lock()
	ret, specificReturn := fake.acquireSchedulingLockReturnsOnCall[len(fake.acquireSchedulingLockArgsForCall)]
	fake.acquireSchedulingLockArgsForCall = append(fake.acquireSchedulingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("AcquireSchedulingLock", []interface{}{arg1, arg2})
	fake.acquireSchedulingLockMutex.Unlock()
	if fake.AcquireSchedulingLockStub != nil {
		return fake.AcquireSchedulingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireSchedulingLockReturns.result1, fake.acquireSchedulingLockReturns.result2, fake.acquireSchedulingLockReturns.result3
}

func (fake *FakePipeline) AcquireSchedulingLockCallCount() int {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return len(fake.acquireSchedulingLockArgsForCall)
}

func (fake *FakePipeline) AcquireSchedulingLockArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return fake.acquireSchedulingLockArgsForCall[i].arg1, fake.acquireSchedulingLockArgsForCall[i].arg2
}

func (fake *FakePipeline) AcquireSchedulingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireSchedulingLockStub = nil
	fake.acquireSchedulingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireSchedulingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireSchedulingLockStub = nil
	if fake.acquireSchedulingLockReturnsOnCall == nil {
		fake.acquireSchedulingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireSchedulingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheck(logger lager.Logger, resourceName string, usedResourceConfig *db.UsedResourceConfig, interval time.Duration, immediate bool) (lock.Lock, bool, error) {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.Lock()
	ret, specificReturn := fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall[len(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall)]
	fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall = append(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall, struct {
		logger             lager.Logger
		resourceName       string
		usedResourceConfig *db.UsedResourceConfig
		interval           time.Duration
		immediate          bool
	}{logger, resourceName, usedResourceConfig, interval, immediate})
	fake.recordInvocation("AcquireResourceCheckingLockWithIntervalCheck", []interface{}{logger, resourceName, usedResourceConfig, interval, immediate})
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.Unlock()
	if fake.AcquireResourceCheckingLockWithIntervalCheckStub != nil {
		return fake.AcquireResourceCheckingLockWithIntervalCheckStub(logger, resourceName, usedResourceConfig, interval, immediate)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireResourceCheckingLockWithIntervalCheckReturns.result1, fake.acquireResourceCheckingLockWithIntervalCheckReturns.result2, fake.acquireResourceCheckingLockWithIntervalCheckReturns.result3
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckCallCount() int {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	return len(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall)
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckArgsForCall(i int) (lager.Logger, string, *db.UsedResourceConfig, time.Duration, bool) {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	return fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].logger, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].resourceName, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].usedResourceConfig, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].interval, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].immediate
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockWithIntervalCheckStub = nil
	fake.acquireResourceCheckingLockWithIntervalCheckReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockWithIntervalCheckStub = nil
	if fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall == nil {
		fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheck(logger lager.Logger, resourceTypeName string, usedResourceConfig *db.UsedResourceConfig, interval time.Duration, immediate bool) (lock.Lock, bool, error) {
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.Lock()
	ret, specificReturn := fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall[len(fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall)]
	fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall = append(fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall, struct {
		logger             lager.Logger
		resourceTypeName   string
		usedResourceConfig *db.UsedResourceConfig
		interval           time.Duration
		immediate          bool
	}{logger, resourceTypeName, usedResourceConfig, interval, immediate})
	fake.recordInvocation("AcquireResourceTypeCheckingLockWithIntervalCheck", []interface{}{logger, resourceTypeName, usedResourceConfig, interval, immediate})
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.Unlock()
	if fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub != nil {
		return fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub(logger, resourceTypeName, usedResourceConfig, interval, immediate)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns.result1, fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns.result2, fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns.result3
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckCallCount() int {
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RUnlock()
	return len(fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall)
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckArgsForCall(i int) (lager.Logger, string, *db.UsedResourceConfig, time.Duration, bool) {
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RUnlock()
	return fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i].logger, fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i].resourceTypeName, fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i].usedResourceConfig, fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i].interval, fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i].immediate
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub = nil
	fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub = nil
	if fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall == nil {
		fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) LoadVersionsDB() (*algorithm.VersionsDB, error) {
	fake.loadVersionsDBMutex.Lock()
	ret, specificReturn := fake.loadVersionsDBReturnsOnCall[len(fake.loadVersionsDBArgsForCall)]
	fake.loadVersionsDBArgsForCall = append(fake.loadVersionsDBArgsForCall, struct{}{})
	fake.recordInvocation("LoadVersionsDB", []interface{}{})
	fake.loadVersionsDBMutex.Unlock()
	if fake.LoadVersionsDBStub != nil {
		return fake.LoadVersionsDBStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadVersionsDBReturns.result1, fake.loadVersionsDBReturns.result2
}

func (fake *FakePipeline) LoadVersionsDBCallCount() int {
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	return len(fake.loadVersionsDBArgsForCall)
}

func (fake *FakePipeline) LoadVersionsDBReturns(result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	fake.loadVersionsDBReturns = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) LoadVersionsDBReturnsOnCall(i int, result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	if fake.loadVersionsDBReturnsOnCall == nil {
		fake.loadVersionsDBReturnsOnCall = make(map[int]struct {
			result1 *algorithm.VersionsDB
			result2 error
		})
	}
	fake.loadVersionsDBReturnsOnCall[i] = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Resource(name string) (db.Resource, bool, error) {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Resource", []interface{}{name})
	fake.resourceMutex.Unlock()
	if fake.ResourceStub != nil {
		return fake.ResourceStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.resourceReturns.result1, fake.resourceReturns.result2, fake.resourceReturns.result3
}

func (fake *FakePipeline) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakePipeline) ResourceArgsForCall(i int) string {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return fake.resourceArgsForCall[i].name
}

func (fake *FakePipeline) ResourceReturns(result1 db.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceReturnsOnCall(i int, result1 db.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 db.Resource
			result2 bool
			result3 error
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Resources() (db.Resources, error) {
	fake.resourcesMutex.Lock()
	ret, specificReturn := fake.resourcesReturnsOnCall[len(fake.resourcesArgsForCall)]
	fake.resourcesArgsForCall = append(fake.resourcesArgsForCall, struct{}{})
	fake.recordInvocation("Resources", []interface{}{})
	fake.resourcesMutex.Unlock()
	if fake.ResourcesStub != nil {
		return fake.ResourcesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.resourcesReturns.result1, fake.resourcesReturns.result2
}

func (fake *FakePipeline) ResourcesCallCount() int {
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	return len(fake.resourcesArgsForCall)
}

func (fake *FakePipeline) ResourcesReturns(result1 db.Resources, result2 error) {
	fake.ResourcesStub = nil
	fake.resourcesReturns = struct {
		result1 db.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourcesReturnsOnCall(i int, result1 db.Resources, result2 error) {
	fake.ResourcesStub = nil
	if fake.resourcesReturnsOnCall == nil {
		fake.resourcesReturnsOnCall = make(map[int]struct {
			result1 db.Resources
			result2 error
		})
	}
	fake.resourcesReturnsOnCall[i] = struct {
		result1 db.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceTypes() (db.ResourceTypes, error) {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct{}{})
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if fake.ResourceTypesStub != nil {
		return fake.ResourceTypesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.resourceTypesReturns.result1, fake.resourceTypesReturns.result2
}

func (fake *FakePipeline) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakePipeline) ResourceTypesReturns(result1 db.ResourceTypes, result2 error) {
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 db.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceTypesReturnsOnCall(i int, result1 db.ResourceTypes, result2 error) {
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 db.ResourceTypes
			result2 error
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 db.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceType(name string) (db.ResourceType, bool, error) {
	fake.resourceTypeMutex.Lock()
	ret, specificReturn := fake.resourceTypeReturnsOnCall[len(fake.resourceTypeArgsForCall)]
	fake.resourceTypeArgsForCall = append(fake.resourceTypeArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("ResourceType", []interface{}{name})
	fake.resourceTypeMutex.Unlock()
	if fake.ResourceTypeStub != nil {
		return fake.ResourceTypeStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.resourceTypeReturns.result1, fake.resourceTypeReturns.result2, fake.resourceTypeReturns.result3
}

func (fake *FakePipeline) ResourceTypeCallCount() int {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	return len(fake.resourceTypeArgsForCall)
}

func (fake *FakePipeline) ResourceTypeArgsForCall(i int) string {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	return fake.resourceTypeArgsForCall[i].name
}

func (fake *FakePipeline) ResourceTypeReturns(result1 db.ResourceType, result2 bool, result3 error) {
	fake.ResourceTypeStub = nil
	fake.resourceTypeReturns = struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypeReturnsOnCall(i int, result1 db.ResourceType, result2 bool, result3 error) {
	fake.ResourceTypeStub = nil
	if fake.resourceTypeReturnsOnCall == nil {
		fake.resourceTypeReturnsOnCall = make(map[int]struct {
			result1 db.ResourceType
			result2 bool
			result3 error
		})
	}
	fake.resourceTypeReturnsOnCall[i] = struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Job(name string) (db.Job, bool, error) {
	fake.jobMutex.Lock()
	ret, specificReturn := fake.jobReturnsOnCall[len(fake.jobArgsForCall)]
	fake.jobArgsForCall = append(fake.jobArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Job", []interface{}{name})
	fake.jobMutex.Unlock()
	if fake.JobStub != nil {
		return fake.JobStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.jobReturns.result1, fake.jobReturns.result2, fake.jobReturns.result3
}

func (fake *FakePipeline) JobCallCount() int {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return len(fake.jobArgsForCall)
}

func (fake *FakePipeline) JobArgsForCall(i int) string {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return fake.jobArgsForCall[i].name
}

func (fake *FakePipeline) JobReturns(result1 db.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	fake.jobReturns = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) JobReturnsOnCall(i int, result1 db.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	if fake.jobReturnsOnCall == nil {
		fake.jobReturnsOnCall = make(map[int]struct {
			result1 db.Job
			result2 bool
			result3 error
		})
	}
	fake.jobReturnsOnCall[i] = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Jobs() (db.Jobs, error) {
	fake.jobsMutex.Lock()
	ret, specificReturn := fake.jobsReturnsOnCall[len(fake.jobsArgsForCall)]
	fake.jobsArgsForCall = append(fake.jobsArgsForCall, struct{}{})
	fake.recordInvocation("Jobs", []interface{}{})
	fake.jobsMutex.Unlock()
	if fake.JobsStub != nil {
		return fake.JobsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.jobsReturns.result1, fake.jobsReturns.result2
}

func (fake *FakePipeline) JobsCallCount() int {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	return len(fake.jobsArgsForCall)
}

func (fake *FakePipeline) JobsReturns(result1 db.Jobs, result2 error) {
	fake.JobsStub = nil
	fake.jobsReturns = struct {
		result1 db.Jobs
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) JobsReturnsOnCall(i int, result1 db.Jobs, result2 error) {
	fake.JobsStub = nil
	if fake.jobsReturnsOnCall == nil {
		fake.jobsReturnsOnCall = make(map[int]struct {
			result1 db.Jobs
			result2 error
		})
	}
	fake.jobsReturnsOnCall[i] = struct {
		result1 db.Jobs
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Dashboard(include string) (db.Dashboard, atc.GroupConfigs, error) {
	fake.dashboardMutex.Lock()
	ret, specificReturn := fake.dashboardReturnsOnCall[len(fake.dashboardArgsForCall)]
	fake.dashboardArgsForCall = append(fake.dashboardArgsForCall, struct {
		include string
	}{include})
	fake.recordInvocation("Dashboard", []interface{}{include})
	fake.dashboardMutex.Unlock()
	if fake.DashboardStub != nil {
		return fake.DashboardStub(include)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.dashboardReturns.result1, fake.dashboardReturns.result2, fake.dashboardReturns.result3
}

func (fake *FakePipeline) DashboardCallCount() int {
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	return len(fake.dashboardArgsForCall)
}

func (fake *FakePipeline) DashboardArgsForCall(i int) string {
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	return fake.dashboardArgsForCall[i].include
}

func (fake *FakePipeline) DashboardReturns(result1 db.Dashboard, result2 atc.GroupConfigs, result3 error) {
	fake.DashboardStub = nil
	fake.dashboardReturns = struct {
		result1 db.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) DashboardReturnsOnCall(i int, result1 db.Dashboard, result2 atc.GroupConfigs, result3 error) {
	fake.DashboardStub = nil
	if fake.dashboardReturnsOnCall == nil {
		fake.dashboardReturnsOnCall = make(map[int]struct {
			result1 db.Dashboard
			result2 atc.GroupConfigs
			result3 error
		})
	}
	fake.dashboardReturnsOnCall[i] = struct {
		result1 db.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Expose() error {
	fake.exposeMutex.Lock()
	ret, specificReturn := fake.exposeReturnsOnCall[len(fake.exposeArgsForCall)]
	fake.exposeArgsForCall = append(fake.exposeArgsForCall, struct{}{})
	fake.recordInvocation("Expose", []interface{}{})
	fake.exposeMutex.Unlock()
	if fake.ExposeStub != nil {
		return fake.ExposeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.exposeReturns.result1
}

func (fake *FakePipeline) ExposeCallCount() int {
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	return len(fake.exposeArgsForCall)
}

func (fake *FakePipeline) ExposeReturns(result1 error) {
	fake.ExposeStub = nil
	fake.exposeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ExposeReturnsOnCall(i int, result1 error) {
	fake.ExposeStub = nil
	if fake.exposeReturnsOnCall == nil {
		fake.exposeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exposeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Hide() error {
	fake.hideMutex.Lock()
	ret, specificReturn := fake.hideReturnsOnCall[len(fake.hideArgsForCall)]
	fake.hideArgsForCall = append(fake.hideArgsForCall, struct{}{})
	fake.recordInvocation("Hide", []interface{}{})
	fake.hideMutex.Unlock()
	if fake.HideStub != nil {
		return fake.HideStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hideReturns.result1
}

func (fake *FakePipeline) HideCallCount() int {
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	return len(fake.hideArgsForCall)
}

func (fake *FakePipeline) HideReturns(result1 error) {
	fake.HideStub = nil
	fake.hideReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) HideReturnsOnCall(i int, result1 error) {
	fake.HideStub = nil
	if fake.hideReturnsOnCall == nil {
		fake.hideReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.hideReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Pause() error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct{}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pauseReturns.result1
}

func (fake *FakePipeline) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakePipeline) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) PauseReturnsOnCall(i int, result1 error) {
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Unpause() error {
	fake.unpauseMutex.Lock()
	ret, specificReturn := fake.unpauseReturnsOnCall[len(fake.unpauseArgsForCall)]
	fake.unpauseArgsForCall = append(fake.unpauseArgsForCall, struct{}{})
	fake.recordInvocation("Unpause", []interface{}{})
	fake.unpauseMutex.Unlock()
	if fake.UnpauseStub != nil {
		return fake.UnpauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unpauseReturns.result1
}

func (fake *FakePipeline) UnpauseCallCount() int {
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	return len(fake.unpauseArgsForCall)
}

func (fake *FakePipeline) UnpauseReturns(result1 error) {
	fake.UnpauseStub = nil
	fake.unpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) UnpauseReturnsOnCall(i int, result1 error) {
	fake.UnpauseStub = nil
	if fake.unpauseReturnsOnCall == nil {
		fake.unpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct{}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyReturns.result1
}

func (fake *FakePipeline) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakePipeline) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DestroyReturnsOnCall(i int, result1 error) {
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Rename(arg1 string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Rename", []interface{}{arg1})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.renameReturns.result1
}

func (fake *FakePipeline) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakePipeline) RenameArgsForCall(i int) string {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return fake.renameArgsForCall[i].arg1
}

func (fake *FakePipeline) RenameReturns(result1 error) {
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) RenameReturnsOnCall(i int, result1 error) {
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) CreateOneOffBuild() (db.Build, error) {
	fake.createOneOffBuildMutex.Lock()
	ret, specificReturn := fake.createOneOffBuildReturnsOnCall[len(fake.createOneOffBuildArgsForCall)]
	fake.createOneOffBuildArgsForCall = append(fake.createOneOffBuildArgsForCall, struct{}{})
	fake.recordInvocation("CreateOneOffBuild", []interface{}{})
	fake.createOneOffBuildMutex.Unlock()
	if fake.CreateOneOffBuildStub != nil {
		return fake.CreateOneOffBuildStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createOneOffBuildReturns.result1, fake.createOneOffBuildReturns.result2
}

func (fake *FakePipeline) CreateOneOffBuildCallCount() int {
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	return len(fake.createOneOffBuildArgsForCall)
}

func (fake *FakePipeline) CreateOneOffBuildReturns(result1 db.Build, result2 error) {
	fake.CreateOneOffBuildStub = nil
	fake.createOneOffBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateOneOffBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.CreateOneOffBuildStub = nil
	if fake.createOneOffBuildReturnsOnCall == nil {
		fake.createOneOffBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createOneOffBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.groupsMutex.RLock()
	defer fake.groupsMutex.RUnlock()
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	fake.versionedResourceMutex.RLock()
	defer fake.versionedResourceMutex.RUnlock()
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RUnlock()
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePipeline) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Pipeline = new(FakePipeline)
