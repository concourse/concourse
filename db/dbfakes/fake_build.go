// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"encoding/json"
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/lock"
)

type FakeBuild struct {
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	JobIDStub        func() int
	jobIDMutex       sync.RWMutex
	jobIDArgsForCall []struct{}
	jobIDReturns     struct {
		result1 int
	}
	jobIDReturnsOnCall map[int]struct {
		result1 int
	}
	JobNameStub        func() string
	jobNameMutex       sync.RWMutex
	jobNameArgsForCall []struct{}
	jobNameReturns     struct {
		result1 string
	}
	jobNameReturnsOnCall map[int]struct {
		result1 string
	}
	PipelineIDStub        func() int
	pipelineIDMutex       sync.RWMutex
	pipelineIDArgsForCall []struct{}
	pipelineIDReturns     struct {
		result1 int
	}
	pipelineIDReturnsOnCall map[int]struct {
		result1 int
	}
	PipelineNameStub        func() string
	pipelineNameMutex       sync.RWMutex
	pipelineNameArgsForCall []struct{}
	pipelineNameReturns     struct {
		result1 string
	}
	pipelineNameReturnsOnCall map[int]struct {
		result1 string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct{}
	teamIDReturns     struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct{}
	teamNameReturns     struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	EngineStub        func() string
	engineMutex       sync.RWMutex
	engineArgsForCall []struct{}
	engineReturns     struct {
		result1 string
	}
	engineReturnsOnCall map[int]struct {
		result1 string
	}
	EngineMetadataStub        func() string
	engineMetadataMutex       sync.RWMutex
	engineMetadataArgsForCall []struct{}
	engineMetadataReturns     struct {
		result1 string
	}
	engineMetadataReturnsOnCall map[int]struct {
		result1 string
	}
	PublicPlanStub        func() *json.RawMessage
	publicPlanMutex       sync.RWMutex
	publicPlanArgsForCall []struct{}
	publicPlanReturns     struct {
		result1 *json.RawMessage
	}
	publicPlanReturnsOnCall map[int]struct {
		result1 *json.RawMessage
	}
	StatusStub        func() db.BuildStatus
	statusMutex       sync.RWMutex
	statusArgsForCall []struct{}
	statusReturns     struct {
		result1 db.BuildStatus
	}
	statusReturnsOnCall map[int]struct {
		result1 db.BuildStatus
	}
	StartTimeStub        func() time.Time
	startTimeMutex       sync.RWMutex
	startTimeArgsForCall []struct{}
	startTimeReturns     struct {
		result1 time.Time
	}
	startTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	EndTimeStub        func() time.Time
	endTimeMutex       sync.RWMutex
	endTimeArgsForCall []struct{}
	endTimeReturns     struct {
		result1 time.Time
	}
	endTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	ReapTimeStub        func() time.Time
	reapTimeMutex       sync.RWMutex
	reapTimeArgsForCall []struct{}
	reapTimeReturns     struct {
		result1 time.Time
	}
	reapTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	TrackerStub        func() string
	trackerMutex       sync.RWMutex
	trackerArgsForCall []struct{}
	trackerReturns     struct {
		result1 string
	}
	trackerReturnsOnCall map[int]struct {
		result1 string
	}
	IsManuallyTriggeredStub        func() bool
	isManuallyTriggeredMutex       sync.RWMutex
	isManuallyTriggeredArgsForCall []struct{}
	isManuallyTriggeredReturns     struct {
		result1 bool
	}
	isManuallyTriggeredReturnsOnCall map[int]struct {
		result1 bool
	}
	IsScheduledStub        func() bool
	isScheduledMutex       sync.RWMutex
	isScheduledArgsForCall []struct{}
	isScheduledReturns     struct {
		result1 bool
	}
	isScheduledReturnsOnCall map[int]struct {
		result1 bool
	}
	IsRunningStub        func() bool
	isRunningMutex       sync.RWMutex
	isRunningArgsForCall []struct{}
	isRunningReturns     struct {
		result1 bool
	}
	isRunningReturnsOnCall map[int]struct {
		result1 bool
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct{}
	reloadReturns     struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	AcquireTrackingLockStub        func(logger lager.Logger, interval time.Duration) (lock.Lock, bool, error)
	acquireTrackingLockMutex       sync.RWMutex
	acquireTrackingLockArgsForCall []struct {
		logger   lager.Logger
		interval time.Duration
	}
	acquireTrackingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireTrackingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	TrackedByStub        func(peerURL string) error
	trackedByMutex       sync.RWMutex
	trackedByArgsForCall []struct {
		peerURL string
	}
	trackedByReturns struct {
		result1 error
	}
	trackedByReturnsOnCall map[int]struct {
		result1 error
	}
	InterceptibleStub        func() (bool, error)
	interceptibleMutex       sync.RWMutex
	interceptibleArgsForCall []struct{}
	interceptibleReturns     struct {
		result1 bool
		result2 error
	}
	interceptibleReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PreparationStub        func() (db.BuildPreparation, bool, error)
	preparationMutex       sync.RWMutex
	preparationArgsForCall []struct{}
	preparationReturns     struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}
	preparationReturnsOnCall map[int]struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}
	StartStub        func(string, string, atc.Plan) (bool, error)
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 atc.Plan
	}
	startReturns struct {
		result1 bool
		result2 error
	}
	startReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FinishWithErrorStub        func(cause error) error
	finishWithErrorMutex       sync.RWMutex
	finishWithErrorArgsForCall []struct {
		cause error
	}
	finishWithErrorReturns struct {
		result1 error
	}
	finishWithErrorReturnsOnCall map[int]struct {
		result1 error
	}
	FinishStub        func(db.BuildStatus) error
	finishMutex       sync.RWMutex
	finishArgsForCall []struct {
		arg1 db.BuildStatus
	}
	finishReturns struct {
		result1 error
	}
	finishReturnsOnCall map[int]struct {
		result1 error
	}
	SetInterceptibleStub        func(bool) error
	setInterceptibleMutex       sync.RWMutex
	setInterceptibleArgsForCall []struct {
		arg1 bool
	}
	setInterceptibleReturns struct {
		result1 error
	}
	setInterceptibleReturnsOnCall map[int]struct {
		result1 error
	}
	EventsStub        func(uint) (db.EventSource, error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 uint
	}
	eventsReturns struct {
		result1 db.EventSource
		result2 error
	}
	eventsReturnsOnCall map[int]struct {
		result1 db.EventSource
		result2 error
	}
	SaveEventStub        func(event atc.Event) error
	saveEventMutex       sync.RWMutex
	saveEventArgsForCall []struct {
		event atc.Event
	}
	saveEventReturns struct {
		result1 error
	}
	saveEventReturnsOnCall map[int]struct {
		result1 error
	}
	SaveInputStub        func(input db.BuildInput) error
	saveInputMutex       sync.RWMutex
	saveInputArgsForCall []struct {
		input db.BuildInput
	}
	saveInputReturns struct {
		result1 error
	}
	saveInputReturnsOnCall map[int]struct {
		result1 error
	}
	SaveOutputStub        func(vr db.VersionedResource) error
	saveOutputMutex       sync.RWMutex
	saveOutputArgsForCall []struct {
		vr db.VersionedResource
	}
	saveOutputReturns struct {
		result1 error
	}
	saveOutputReturnsOnCall map[int]struct {
		result1 error
	}
	UseInputsStub        func(inputs []db.BuildInput) error
	useInputsMutex       sync.RWMutex
	useInputsArgsForCall []struct {
		inputs []db.BuildInput
	}
	useInputsReturns struct {
		result1 error
	}
	useInputsReturnsOnCall map[int]struct {
		result1 error
	}
	ResourcesStub        func() ([]db.BuildInput, []db.BuildOutput, error)
	resourcesMutex       sync.RWMutex
	resourcesArgsForCall []struct{}
	resourcesReturns     struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}
	resourcesReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}
	GetVersionedResourcesStub        func() (db.SavedVersionedResources, error)
	getVersionedResourcesMutex       sync.RWMutex
	getVersionedResourcesArgsForCall []struct{}
	getVersionedResourcesReturns     struct {
		result1 db.SavedVersionedResources
		result2 error
	}
	getVersionedResourcesReturnsOnCall map[int]struct {
		result1 db.SavedVersionedResources
		result2 error
	}
	SaveImageResourceVersionStub        func(db.UsedResourceCache) error
	saveImageResourceVersionMutex       sync.RWMutex
	saveImageResourceVersionArgsForCall []struct {
		arg1 db.UsedResourceCache
	}
	saveImageResourceVersionReturns struct {
		result1 error
	}
	saveImageResourceVersionReturnsOnCall map[int]struct {
		result1 error
	}
	PipelineStub        func() (db.Pipeline, bool, error)
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct{}
	pipelineReturns     struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	pipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	DeleteStub        func() (bool, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct{}
	deleteReturns     struct {
		result1 bool
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	MarkAsAbortedStub        func() error
	markAsAbortedMutex       sync.RWMutex
	markAsAbortedArgsForCall []struct{}
	markAsAbortedReturns     struct {
		result1 error
	}
	markAsAbortedReturnsOnCall map[int]struct {
		result1 error
	}
	AbortNotifierStub        func() (db.Notifier, error)
	abortNotifierMutex       sync.RWMutex
	abortNotifierArgsForCall []struct{}
	abortNotifierReturns     struct {
		result1 db.Notifier
		result2 error
	}
	abortNotifierReturnsOnCall map[int]struct {
		result1 db.Notifier
		result2 error
	}
	ScheduleStub        func() (bool, error)
	scheduleMutex       sync.RWMutex
	scheduleArgsForCall []struct{}
	scheduleReturns     struct {
		result1 bool
		result2 error
	}
	scheduleReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsDrainedStub        func() bool
	isDrainedMutex       sync.RWMutex
	isDrainedArgsForCall []struct{}
	isDrainedReturns     struct {
		result1 bool
	}
	isDrainedReturnsOnCall map[int]struct {
		result1 bool
	}
	SetDrainedStub        func(bool) error
	setDrainedMutex       sync.RWMutex
	setDrainedArgsForCall []struct {
		arg1 bool
	}
	setDrainedReturns struct {
		result1 error
	}
	setDrainedReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBuild) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeBuild) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeBuild) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakeBuild) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeBuild) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) JobID() int {
	fake.jobIDMutex.Lock()
	ret, specificReturn := fake.jobIDReturnsOnCall[len(fake.jobIDArgsForCall)]
	fake.jobIDArgsForCall = append(fake.jobIDArgsForCall, struct{}{})
	fake.recordInvocation("JobID", []interface{}{})
	fake.jobIDMutex.Unlock()
	if fake.JobIDStub != nil {
		return fake.JobIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.jobIDReturns.result1
}

func (fake *FakeBuild) JobIDCallCount() int {
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	return len(fake.jobIDArgsForCall)
}

func (fake *FakeBuild) JobIDReturns(result1 int) {
	fake.JobIDStub = nil
	fake.jobIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) JobIDReturnsOnCall(i int, result1 int) {
	fake.JobIDStub = nil
	if fake.jobIDReturnsOnCall == nil {
		fake.jobIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.jobIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) JobName() string {
	fake.jobNameMutex.Lock()
	ret, specificReturn := fake.jobNameReturnsOnCall[len(fake.jobNameArgsForCall)]
	fake.jobNameArgsForCall = append(fake.jobNameArgsForCall, struct{}{})
	fake.recordInvocation("JobName", []interface{}{})
	fake.jobNameMutex.Unlock()
	if fake.JobNameStub != nil {
		return fake.JobNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.jobNameReturns.result1
}

func (fake *FakeBuild) JobNameCallCount() int {
	fake.jobNameMutex.RLock()
	defer fake.jobNameMutex.RUnlock()
	return len(fake.jobNameArgsForCall)
}

func (fake *FakeBuild) JobNameReturns(result1 string) {
	fake.JobNameStub = nil
	fake.jobNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) JobNameReturnsOnCall(i int, result1 string) {
	fake.JobNameStub = nil
	if fake.jobNameReturnsOnCall == nil {
		fake.jobNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.jobNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) PipelineID() int {
	fake.pipelineIDMutex.Lock()
	ret, specificReturn := fake.pipelineIDReturnsOnCall[len(fake.pipelineIDArgsForCall)]
	fake.pipelineIDArgsForCall = append(fake.pipelineIDArgsForCall, struct{}{})
	fake.recordInvocation("PipelineID", []interface{}{})
	fake.pipelineIDMutex.Unlock()
	if fake.PipelineIDStub != nil {
		return fake.PipelineIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pipelineIDReturns.result1
}

func (fake *FakeBuild) PipelineIDCallCount() int {
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	return len(fake.pipelineIDArgsForCall)
}

func (fake *FakeBuild) PipelineIDReturns(result1 int) {
	fake.PipelineIDStub = nil
	fake.pipelineIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) PipelineIDReturnsOnCall(i int, result1 int) {
	fake.PipelineIDStub = nil
	if fake.pipelineIDReturnsOnCall == nil {
		fake.pipelineIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.pipelineIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) PipelineName() string {
	fake.pipelineNameMutex.Lock()
	ret, specificReturn := fake.pipelineNameReturnsOnCall[len(fake.pipelineNameArgsForCall)]
	fake.pipelineNameArgsForCall = append(fake.pipelineNameArgsForCall, struct{}{})
	fake.recordInvocation("PipelineName", []interface{}{})
	fake.pipelineNameMutex.Unlock()
	if fake.PipelineNameStub != nil {
		return fake.PipelineNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pipelineNameReturns.result1
}

func (fake *FakeBuild) PipelineNameCallCount() int {
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	return len(fake.pipelineNameArgsForCall)
}

func (fake *FakeBuild) PipelineNameReturns(result1 string) {
	fake.PipelineNameStub = nil
	fake.pipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) PipelineNameReturnsOnCall(i int, result1 string) {
	fake.PipelineNameStub = nil
	if fake.pipelineNameReturnsOnCall == nil {
		fake.pipelineNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pipelineNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct{}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamIDReturns.result1
}

func (fake *FakeBuild) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakeBuild) TeamIDReturns(result1 int) {
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) TeamIDReturnsOnCall(i int, result1 int) {
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct{}{})
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if fake.TeamNameStub != nil {
		return fake.TeamNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamNameReturns.result1
}

func (fake *FakeBuild) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakeBuild) TeamNameReturns(result1 string) {
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) TeamNameReturnsOnCall(i int, result1 string) {
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) Engine() string {
	fake.engineMutex.Lock()
	ret, specificReturn := fake.engineReturnsOnCall[len(fake.engineArgsForCall)]
	fake.engineArgsForCall = append(fake.engineArgsForCall, struct{}{})
	fake.recordInvocation("Engine", []interface{}{})
	fake.engineMutex.Unlock()
	if fake.EngineStub != nil {
		return fake.EngineStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.engineReturns.result1
}

func (fake *FakeBuild) EngineCallCount() int {
	fake.engineMutex.RLock()
	defer fake.engineMutex.RUnlock()
	return len(fake.engineArgsForCall)
}

func (fake *FakeBuild) EngineReturns(result1 string) {
	fake.EngineStub = nil
	fake.engineReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) EngineReturnsOnCall(i int, result1 string) {
	fake.EngineStub = nil
	if fake.engineReturnsOnCall == nil {
		fake.engineReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.engineReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) EngineMetadata() string {
	fake.engineMetadataMutex.Lock()
	ret, specificReturn := fake.engineMetadataReturnsOnCall[len(fake.engineMetadataArgsForCall)]
	fake.engineMetadataArgsForCall = append(fake.engineMetadataArgsForCall, struct{}{})
	fake.recordInvocation("EngineMetadata", []interface{}{})
	fake.engineMetadataMutex.Unlock()
	if fake.EngineMetadataStub != nil {
		return fake.EngineMetadataStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.engineMetadataReturns.result1
}

func (fake *FakeBuild) EngineMetadataCallCount() int {
	fake.engineMetadataMutex.RLock()
	defer fake.engineMetadataMutex.RUnlock()
	return len(fake.engineMetadataArgsForCall)
}

func (fake *FakeBuild) EngineMetadataReturns(result1 string) {
	fake.EngineMetadataStub = nil
	fake.engineMetadataReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) EngineMetadataReturnsOnCall(i int, result1 string) {
	fake.EngineMetadataStub = nil
	if fake.engineMetadataReturnsOnCall == nil {
		fake.engineMetadataReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.engineMetadataReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) PublicPlan() *json.RawMessage {
	fake.publicPlanMutex.Lock()
	ret, specificReturn := fake.publicPlanReturnsOnCall[len(fake.publicPlanArgsForCall)]
	fake.publicPlanArgsForCall = append(fake.publicPlanArgsForCall, struct{}{})
	fake.recordInvocation("PublicPlan", []interface{}{})
	fake.publicPlanMutex.Unlock()
	if fake.PublicPlanStub != nil {
		return fake.PublicPlanStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.publicPlanReturns.result1
}

func (fake *FakeBuild) PublicPlanCallCount() int {
	fake.publicPlanMutex.RLock()
	defer fake.publicPlanMutex.RUnlock()
	return len(fake.publicPlanArgsForCall)
}

func (fake *FakeBuild) PublicPlanReturns(result1 *json.RawMessage) {
	fake.PublicPlanStub = nil
	fake.publicPlanReturns = struct {
		result1 *json.RawMessage
	}{result1}
}

func (fake *FakeBuild) PublicPlanReturnsOnCall(i int, result1 *json.RawMessage) {
	fake.PublicPlanStub = nil
	if fake.publicPlanReturnsOnCall == nil {
		fake.publicPlanReturnsOnCall = make(map[int]struct {
			result1 *json.RawMessage
		})
	}
	fake.publicPlanReturnsOnCall[i] = struct {
		result1 *json.RawMessage
	}{result1}
}

func (fake *FakeBuild) Status() db.BuildStatus {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct{}{})
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if fake.StatusStub != nil {
		return fake.StatusStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.statusReturns.result1
}

func (fake *FakeBuild) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeBuild) StatusReturns(result1 db.BuildStatus) {
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 db.BuildStatus
	}{result1}
}

func (fake *FakeBuild) StatusReturnsOnCall(i int, result1 db.BuildStatus) {
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 db.BuildStatus
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 db.BuildStatus
	}{result1}
}

func (fake *FakeBuild) StartTime() time.Time {
	fake.startTimeMutex.Lock()
	ret, specificReturn := fake.startTimeReturnsOnCall[len(fake.startTimeArgsForCall)]
	fake.startTimeArgsForCall = append(fake.startTimeArgsForCall, struct{}{})
	fake.recordInvocation("StartTime", []interface{}{})
	fake.startTimeMutex.Unlock()
	if fake.StartTimeStub != nil {
		return fake.StartTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startTimeReturns.result1
}

func (fake *FakeBuild) StartTimeCallCount() int {
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	return len(fake.startTimeArgsForCall)
}

func (fake *FakeBuild) StartTimeReturns(result1 time.Time) {
	fake.StartTimeStub = nil
	fake.startTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) StartTimeReturnsOnCall(i int, result1 time.Time) {
	fake.StartTimeStub = nil
	if fake.startTimeReturnsOnCall == nil {
		fake.startTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.startTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) EndTime() time.Time {
	fake.endTimeMutex.Lock()
	ret, specificReturn := fake.endTimeReturnsOnCall[len(fake.endTimeArgsForCall)]
	fake.endTimeArgsForCall = append(fake.endTimeArgsForCall, struct{}{})
	fake.recordInvocation("EndTime", []interface{}{})
	fake.endTimeMutex.Unlock()
	if fake.EndTimeStub != nil {
		return fake.EndTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.endTimeReturns.result1
}

func (fake *FakeBuild) EndTimeCallCount() int {
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	return len(fake.endTimeArgsForCall)
}

func (fake *FakeBuild) EndTimeReturns(result1 time.Time) {
	fake.EndTimeStub = nil
	fake.endTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) EndTimeReturnsOnCall(i int, result1 time.Time) {
	fake.EndTimeStub = nil
	if fake.endTimeReturnsOnCall == nil {
		fake.endTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.endTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) ReapTime() time.Time {
	fake.reapTimeMutex.Lock()
	ret, specificReturn := fake.reapTimeReturnsOnCall[len(fake.reapTimeArgsForCall)]
	fake.reapTimeArgsForCall = append(fake.reapTimeArgsForCall, struct{}{})
	fake.recordInvocation("ReapTime", []interface{}{})
	fake.reapTimeMutex.Unlock()
	if fake.ReapTimeStub != nil {
		return fake.ReapTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reapTimeReturns.result1
}

func (fake *FakeBuild) ReapTimeCallCount() int {
	fake.reapTimeMutex.RLock()
	defer fake.reapTimeMutex.RUnlock()
	return len(fake.reapTimeArgsForCall)
}

func (fake *FakeBuild) ReapTimeReturns(result1 time.Time) {
	fake.ReapTimeStub = nil
	fake.reapTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) ReapTimeReturnsOnCall(i int, result1 time.Time) {
	fake.ReapTimeStub = nil
	if fake.reapTimeReturnsOnCall == nil {
		fake.reapTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.reapTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) Tracker() string {
	fake.trackerMutex.Lock()
	ret, specificReturn := fake.trackerReturnsOnCall[len(fake.trackerArgsForCall)]
	fake.trackerArgsForCall = append(fake.trackerArgsForCall, struct{}{})
	fake.recordInvocation("Tracker", []interface{}{})
	fake.trackerMutex.Unlock()
	if fake.TrackerStub != nil {
		return fake.TrackerStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.trackerReturns.result1
}

func (fake *FakeBuild) TrackerCallCount() int {
	fake.trackerMutex.RLock()
	defer fake.trackerMutex.RUnlock()
	return len(fake.trackerArgsForCall)
}

func (fake *FakeBuild) TrackerReturns(result1 string) {
	fake.TrackerStub = nil
	fake.trackerReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) TrackerReturnsOnCall(i int, result1 string) {
	fake.TrackerStub = nil
	if fake.trackerReturnsOnCall == nil {
		fake.trackerReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.trackerReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) IsManuallyTriggered() bool {
	fake.isManuallyTriggeredMutex.Lock()
	ret, specificReturn := fake.isManuallyTriggeredReturnsOnCall[len(fake.isManuallyTriggeredArgsForCall)]
	fake.isManuallyTriggeredArgsForCall = append(fake.isManuallyTriggeredArgsForCall, struct{}{})
	fake.recordInvocation("IsManuallyTriggered", []interface{}{})
	fake.isManuallyTriggeredMutex.Unlock()
	if fake.IsManuallyTriggeredStub != nil {
		return fake.IsManuallyTriggeredStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isManuallyTriggeredReturns.result1
}

func (fake *FakeBuild) IsManuallyTriggeredCallCount() int {
	fake.isManuallyTriggeredMutex.RLock()
	defer fake.isManuallyTriggeredMutex.RUnlock()
	return len(fake.isManuallyTriggeredArgsForCall)
}

func (fake *FakeBuild) IsManuallyTriggeredReturns(result1 bool) {
	fake.IsManuallyTriggeredStub = nil
	fake.isManuallyTriggeredReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsManuallyTriggeredReturnsOnCall(i int, result1 bool) {
	fake.IsManuallyTriggeredStub = nil
	if fake.isManuallyTriggeredReturnsOnCall == nil {
		fake.isManuallyTriggeredReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isManuallyTriggeredReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsScheduled() bool {
	fake.isScheduledMutex.Lock()
	ret, specificReturn := fake.isScheduledReturnsOnCall[len(fake.isScheduledArgsForCall)]
	fake.isScheduledArgsForCall = append(fake.isScheduledArgsForCall, struct{}{})
	fake.recordInvocation("IsScheduled", []interface{}{})
	fake.isScheduledMutex.Unlock()
	if fake.IsScheduledStub != nil {
		return fake.IsScheduledStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isScheduledReturns.result1
}

func (fake *FakeBuild) IsScheduledCallCount() int {
	fake.isScheduledMutex.RLock()
	defer fake.isScheduledMutex.RUnlock()
	return len(fake.isScheduledArgsForCall)
}

func (fake *FakeBuild) IsScheduledReturns(result1 bool) {
	fake.IsScheduledStub = nil
	fake.isScheduledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsScheduledReturnsOnCall(i int, result1 bool) {
	fake.IsScheduledStub = nil
	if fake.isScheduledReturnsOnCall == nil {
		fake.isScheduledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isScheduledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsRunning() bool {
	fake.isRunningMutex.Lock()
	ret, specificReturn := fake.isRunningReturnsOnCall[len(fake.isRunningArgsForCall)]
	fake.isRunningArgsForCall = append(fake.isRunningArgsForCall, struct{}{})
	fake.recordInvocation("IsRunning", []interface{}{})
	fake.isRunningMutex.Unlock()
	if fake.IsRunningStub != nil {
		return fake.IsRunningStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isRunningReturns.result1
}

func (fake *FakeBuild) IsRunningCallCount() int {
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	return len(fake.isRunningArgsForCall)
}

func (fake *FakeBuild) IsRunningReturns(result1 bool) {
	fake.IsRunningStub = nil
	fake.isRunningReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsRunningReturnsOnCall(i int, result1 bool) {
	fake.IsRunningStub = nil
	if fake.isRunningReturnsOnCall == nil {
		fake.isRunningReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRunningReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct{}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.reloadReturns.result1, fake.reloadReturns.result2
}

func (fake *FakeBuild) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakeBuild) ReloadReturns(result1 bool, result2 error) {
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) AcquireTrackingLock(logger lager.Logger, interval time.Duration) (lock.Lock, bool, error) {
	fake.acquireTrackingLockMutex.Lock()
	ret, specificReturn := fake.acquireTrackingLockReturnsOnCall[len(fake.acquireTrackingLockArgsForCall)]
	fake.acquireTrackingLockArgsForCall = append(fake.acquireTrackingLockArgsForCall, struct {
		logger   lager.Logger
		interval time.Duration
	}{logger, interval})
	fake.recordInvocation("AcquireTrackingLock", []interface{}{logger, interval})
	fake.acquireTrackingLockMutex.Unlock()
	if fake.AcquireTrackingLockStub != nil {
		return fake.AcquireTrackingLockStub(logger, interval)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireTrackingLockReturns.result1, fake.acquireTrackingLockReturns.result2, fake.acquireTrackingLockReturns.result3
}

func (fake *FakeBuild) AcquireTrackingLockCallCount() int {
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	return len(fake.acquireTrackingLockArgsForCall)
}

func (fake *FakeBuild) AcquireTrackingLockArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	return fake.acquireTrackingLockArgsForCall[i].logger, fake.acquireTrackingLockArgsForCall[i].interval
}

func (fake *FakeBuild) AcquireTrackingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireTrackingLockStub = nil
	fake.acquireTrackingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) AcquireTrackingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireTrackingLockStub = nil
	if fake.acquireTrackingLockReturnsOnCall == nil {
		fake.acquireTrackingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireTrackingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) TrackedBy(peerURL string) error {
	fake.trackedByMutex.Lock()
	ret, specificReturn := fake.trackedByReturnsOnCall[len(fake.trackedByArgsForCall)]
	fake.trackedByArgsForCall = append(fake.trackedByArgsForCall, struct {
		peerURL string
	}{peerURL})
	fake.recordInvocation("TrackedBy", []interface{}{peerURL})
	fake.trackedByMutex.Unlock()
	if fake.TrackedByStub != nil {
		return fake.TrackedByStub(peerURL)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.trackedByReturns.result1
}

func (fake *FakeBuild) TrackedByCallCount() int {
	fake.trackedByMutex.RLock()
	defer fake.trackedByMutex.RUnlock()
	return len(fake.trackedByArgsForCall)
}

func (fake *FakeBuild) TrackedByArgsForCall(i int) string {
	fake.trackedByMutex.RLock()
	defer fake.trackedByMutex.RUnlock()
	return fake.trackedByArgsForCall[i].peerURL
}

func (fake *FakeBuild) TrackedByReturns(result1 error) {
	fake.TrackedByStub = nil
	fake.trackedByReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) TrackedByReturnsOnCall(i int, result1 error) {
	fake.TrackedByStub = nil
	if fake.trackedByReturnsOnCall == nil {
		fake.trackedByReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.trackedByReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) Interceptible() (bool, error) {
	fake.interceptibleMutex.Lock()
	ret, specificReturn := fake.interceptibleReturnsOnCall[len(fake.interceptibleArgsForCall)]
	fake.interceptibleArgsForCall = append(fake.interceptibleArgsForCall, struct{}{})
	fake.recordInvocation("Interceptible", []interface{}{})
	fake.interceptibleMutex.Unlock()
	if fake.InterceptibleStub != nil {
		return fake.InterceptibleStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.interceptibleReturns.result1, fake.interceptibleReturns.result2
}

func (fake *FakeBuild) InterceptibleCallCount() int {
	fake.interceptibleMutex.RLock()
	defer fake.interceptibleMutex.RUnlock()
	return len(fake.interceptibleArgsForCall)
}

func (fake *FakeBuild) InterceptibleReturns(result1 bool, result2 error) {
	fake.InterceptibleStub = nil
	fake.interceptibleReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) InterceptibleReturnsOnCall(i int, result1 bool, result2 error) {
	fake.InterceptibleStub = nil
	if fake.interceptibleReturnsOnCall == nil {
		fake.interceptibleReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.interceptibleReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) Preparation() (db.BuildPreparation, bool, error) {
	fake.preparationMutex.Lock()
	ret, specificReturn := fake.preparationReturnsOnCall[len(fake.preparationArgsForCall)]
	fake.preparationArgsForCall = append(fake.preparationArgsForCall, struct{}{})
	fake.recordInvocation("Preparation", []interface{}{})
	fake.preparationMutex.Unlock()
	if fake.PreparationStub != nil {
		return fake.PreparationStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.preparationReturns.result1, fake.preparationReturns.result2, fake.preparationReturns.result3
}

func (fake *FakeBuild) PreparationCallCount() int {
	fake.preparationMutex.RLock()
	defer fake.preparationMutex.RUnlock()
	return len(fake.preparationArgsForCall)
}

func (fake *FakeBuild) PreparationReturns(result1 db.BuildPreparation, result2 bool, result3 error) {
	fake.PreparationStub = nil
	fake.preparationReturns = struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) PreparationReturnsOnCall(i int, result1 db.BuildPreparation, result2 bool, result3 error) {
	fake.PreparationStub = nil
	if fake.preparationReturnsOnCall == nil {
		fake.preparationReturnsOnCall = make(map[int]struct {
			result1 db.BuildPreparation
			result2 bool
			result3 error
		})
	}
	fake.preparationReturnsOnCall[i] = struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) Start(arg1 string, arg2 string, arg3 atc.Plan) (bool, error) {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 atc.Plan
	}{arg1, arg2, arg3})
	fake.recordInvocation("Start", []interface{}{arg1, arg2, arg3})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.startReturns.result1, fake.startReturns.result2
}

func (fake *FakeBuild) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeBuild) StartArgsForCall(i int) (string, string, atc.Plan) {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return fake.startArgsForCall[i].arg1, fake.startArgsForCall[i].arg2, fake.startArgsForCall[i].arg3
}

func (fake *FakeBuild) StartReturns(result1 bool, result2 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) StartReturnsOnCall(i int, result1 bool, result2 error) {
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) FinishWithError(cause error) error {
	fake.finishWithErrorMutex.Lock()
	ret, specificReturn := fake.finishWithErrorReturnsOnCall[len(fake.finishWithErrorArgsForCall)]
	fake.finishWithErrorArgsForCall = append(fake.finishWithErrorArgsForCall, struct {
		cause error
	}{cause})
	fake.recordInvocation("FinishWithError", []interface{}{cause})
	fake.finishWithErrorMutex.Unlock()
	if fake.FinishWithErrorStub != nil {
		return fake.FinishWithErrorStub(cause)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.finishWithErrorReturns.result1
}

func (fake *FakeBuild) FinishWithErrorCallCount() int {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	return len(fake.finishWithErrorArgsForCall)
}

func (fake *FakeBuild) FinishWithErrorArgsForCall(i int) error {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	return fake.finishWithErrorArgsForCall[i].cause
}

func (fake *FakeBuild) FinishWithErrorReturns(result1 error) {
	fake.FinishWithErrorStub = nil
	fake.finishWithErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) FinishWithErrorReturnsOnCall(i int, result1 error) {
	fake.FinishWithErrorStub = nil
	if fake.finishWithErrorReturnsOnCall == nil {
		fake.finishWithErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishWithErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) Finish(arg1 db.BuildStatus) error {
	fake.finishMutex.Lock()
	ret, specificReturn := fake.finishReturnsOnCall[len(fake.finishArgsForCall)]
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct {
		arg1 db.BuildStatus
	}{arg1})
	fake.recordInvocation("Finish", []interface{}{arg1})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		return fake.FinishStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.finishReturns.result1
}

func (fake *FakeBuild) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeBuild) FinishArgsForCall(i int) db.BuildStatus {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return fake.finishArgsForCall[i].arg1
}

func (fake *FakeBuild) FinishReturns(result1 error) {
	fake.FinishStub = nil
	fake.finishReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) FinishReturnsOnCall(i int, result1 error) {
	fake.FinishStub = nil
	if fake.finishReturnsOnCall == nil {
		fake.finishReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SetInterceptible(arg1 bool) error {
	fake.setInterceptibleMutex.Lock()
	ret, specificReturn := fake.setInterceptibleReturnsOnCall[len(fake.setInterceptibleArgsForCall)]
	fake.setInterceptibleArgsForCall = append(fake.setInterceptibleArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("SetInterceptible", []interface{}{arg1})
	fake.setInterceptibleMutex.Unlock()
	if fake.SetInterceptibleStub != nil {
		return fake.SetInterceptibleStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setInterceptibleReturns.result1
}

func (fake *FakeBuild) SetInterceptibleCallCount() int {
	fake.setInterceptibleMutex.RLock()
	defer fake.setInterceptibleMutex.RUnlock()
	return len(fake.setInterceptibleArgsForCall)
}

func (fake *FakeBuild) SetInterceptibleArgsForCall(i int) bool {
	fake.setInterceptibleMutex.RLock()
	defer fake.setInterceptibleMutex.RUnlock()
	return fake.setInterceptibleArgsForCall[i].arg1
}

func (fake *FakeBuild) SetInterceptibleReturns(result1 error) {
	fake.SetInterceptibleStub = nil
	fake.setInterceptibleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SetInterceptibleReturnsOnCall(i int, result1 error) {
	fake.SetInterceptibleStub = nil
	if fake.setInterceptibleReturnsOnCall == nil {
		fake.setInterceptibleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setInterceptibleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) Events(arg1 uint) (db.EventSource, error) {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 uint
	}{arg1})
	fake.recordInvocation("Events", []interface{}{arg1})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.eventsReturns.result1, fake.eventsReturns.result2
}

func (fake *FakeBuild) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeBuild) EventsArgsForCall(i int) uint {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return fake.eventsArgsForCall[i].arg1
}

func (fake *FakeBuild) EventsReturns(result1 db.EventSource, result2 error) {
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 db.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) EventsReturnsOnCall(i int, result1 db.EventSource, result2 error) {
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 db.EventSource
			result2 error
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 db.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) SaveEvent(event atc.Event) error {
	fake.saveEventMutex.Lock()
	ret, specificReturn := fake.saveEventReturnsOnCall[len(fake.saveEventArgsForCall)]
	fake.saveEventArgsForCall = append(fake.saveEventArgsForCall, struct {
		event atc.Event
	}{event})
	fake.recordInvocation("SaveEvent", []interface{}{event})
	fake.saveEventMutex.Unlock()
	if fake.SaveEventStub != nil {
		return fake.SaveEventStub(event)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveEventReturns.result1
}

func (fake *FakeBuild) SaveEventCallCount() int {
	fake.saveEventMutex.RLock()
	defer fake.saveEventMutex.RUnlock()
	return len(fake.saveEventArgsForCall)
}

func (fake *FakeBuild) SaveEventArgsForCall(i int) atc.Event {
	fake.saveEventMutex.RLock()
	defer fake.saveEventMutex.RUnlock()
	return fake.saveEventArgsForCall[i].event
}

func (fake *FakeBuild) SaveEventReturns(result1 error) {
	fake.SaveEventStub = nil
	fake.saveEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveEventReturnsOnCall(i int, result1 error) {
	fake.SaveEventStub = nil
	if fake.saveEventReturnsOnCall == nil {
		fake.saveEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveInput(input db.BuildInput) error {
	fake.saveInputMutex.Lock()
	ret, specificReturn := fake.saveInputReturnsOnCall[len(fake.saveInputArgsForCall)]
	fake.saveInputArgsForCall = append(fake.saveInputArgsForCall, struct {
		input db.BuildInput
	}{input})
	fake.recordInvocation("SaveInput", []interface{}{input})
	fake.saveInputMutex.Unlock()
	if fake.SaveInputStub != nil {
		return fake.SaveInputStub(input)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveInputReturns.result1
}

func (fake *FakeBuild) SaveInputCallCount() int {
	fake.saveInputMutex.RLock()
	defer fake.saveInputMutex.RUnlock()
	return len(fake.saveInputArgsForCall)
}

func (fake *FakeBuild) SaveInputArgsForCall(i int) db.BuildInput {
	fake.saveInputMutex.RLock()
	defer fake.saveInputMutex.RUnlock()
	return fake.saveInputArgsForCall[i].input
}

func (fake *FakeBuild) SaveInputReturns(result1 error) {
	fake.SaveInputStub = nil
	fake.saveInputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveInputReturnsOnCall(i int, result1 error) {
	fake.SaveInputStub = nil
	if fake.saveInputReturnsOnCall == nil {
		fake.saveInputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveInputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveOutput(vr db.VersionedResource) error {
	fake.saveOutputMutex.Lock()
	ret, specificReturn := fake.saveOutputReturnsOnCall[len(fake.saveOutputArgsForCall)]
	fake.saveOutputArgsForCall = append(fake.saveOutputArgsForCall, struct {
		vr db.VersionedResource
	}{vr})
	fake.recordInvocation("SaveOutput", []interface{}{vr})
	fake.saveOutputMutex.Unlock()
	if fake.SaveOutputStub != nil {
		return fake.SaveOutputStub(vr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveOutputReturns.result1
}

func (fake *FakeBuild) SaveOutputCallCount() int {
	fake.saveOutputMutex.RLock()
	defer fake.saveOutputMutex.RUnlock()
	return len(fake.saveOutputArgsForCall)
}

func (fake *FakeBuild) SaveOutputArgsForCall(i int) db.VersionedResource {
	fake.saveOutputMutex.RLock()
	defer fake.saveOutputMutex.RUnlock()
	return fake.saveOutputArgsForCall[i].vr
}

func (fake *FakeBuild) SaveOutputReturns(result1 error) {
	fake.SaveOutputStub = nil
	fake.saveOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveOutputReturnsOnCall(i int, result1 error) {
	fake.SaveOutputStub = nil
	if fake.saveOutputReturnsOnCall == nil {
		fake.saveOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) UseInputs(inputs []db.BuildInput) error {
	var inputsCopy []db.BuildInput
	if inputs != nil {
		inputsCopy = make([]db.BuildInput, len(inputs))
		copy(inputsCopy, inputs)
	}
	fake.useInputsMutex.Lock()
	ret, specificReturn := fake.useInputsReturnsOnCall[len(fake.useInputsArgsForCall)]
	fake.useInputsArgsForCall = append(fake.useInputsArgsForCall, struct {
		inputs []db.BuildInput
	}{inputsCopy})
	fake.recordInvocation("UseInputs", []interface{}{inputsCopy})
	fake.useInputsMutex.Unlock()
	if fake.UseInputsStub != nil {
		return fake.UseInputsStub(inputs)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.useInputsReturns.result1
}

func (fake *FakeBuild) UseInputsCallCount() int {
	fake.useInputsMutex.RLock()
	defer fake.useInputsMutex.RUnlock()
	return len(fake.useInputsArgsForCall)
}

func (fake *FakeBuild) UseInputsArgsForCall(i int) []db.BuildInput {
	fake.useInputsMutex.RLock()
	defer fake.useInputsMutex.RUnlock()
	return fake.useInputsArgsForCall[i].inputs
}

func (fake *FakeBuild) UseInputsReturns(result1 error) {
	fake.UseInputsStub = nil
	fake.useInputsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) UseInputsReturnsOnCall(i int, result1 error) {
	fake.UseInputsStub = nil
	if fake.useInputsReturnsOnCall == nil {
		fake.useInputsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.useInputsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) Resources() ([]db.BuildInput, []db.BuildOutput, error) {
	fake.resourcesMutex.Lock()
	ret, specificReturn := fake.resourcesReturnsOnCall[len(fake.resourcesArgsForCall)]
	fake.resourcesArgsForCall = append(fake.resourcesArgsForCall, struct{}{})
	fake.recordInvocation("Resources", []interface{}{})
	fake.resourcesMutex.Unlock()
	if fake.ResourcesStub != nil {
		return fake.ResourcesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.resourcesReturns.result1, fake.resourcesReturns.result2, fake.resourcesReturns.result3
}

func (fake *FakeBuild) ResourcesCallCount() int {
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	return len(fake.resourcesArgsForCall)
}

func (fake *FakeBuild) ResourcesReturns(result1 []db.BuildInput, result2 []db.BuildOutput, result3 error) {
	fake.ResourcesStub = nil
	fake.resourcesReturns = struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) ResourcesReturnsOnCall(i int, result1 []db.BuildInput, result2 []db.BuildOutput, result3 error) {
	fake.ResourcesStub = nil
	if fake.resourcesReturnsOnCall == nil {
		fake.resourcesReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 []db.BuildOutput
			result3 error
		})
	}
	fake.resourcesReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) GetVersionedResources() (db.SavedVersionedResources, error) {
	fake.getVersionedResourcesMutex.Lock()
	ret, specificReturn := fake.getVersionedResourcesReturnsOnCall[len(fake.getVersionedResourcesArgsForCall)]
	fake.getVersionedResourcesArgsForCall = append(fake.getVersionedResourcesArgsForCall, struct{}{})
	fake.recordInvocation("GetVersionedResources", []interface{}{})
	fake.getVersionedResourcesMutex.Unlock()
	if fake.GetVersionedResourcesStub != nil {
		return fake.GetVersionedResourcesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVersionedResourcesReturns.result1, fake.getVersionedResourcesReturns.result2
}

func (fake *FakeBuild) GetVersionedResourcesCallCount() int {
	fake.getVersionedResourcesMutex.RLock()
	defer fake.getVersionedResourcesMutex.RUnlock()
	return len(fake.getVersionedResourcesArgsForCall)
}

func (fake *FakeBuild) GetVersionedResourcesReturns(result1 db.SavedVersionedResources, result2 error) {
	fake.GetVersionedResourcesStub = nil
	fake.getVersionedResourcesReturns = struct {
		result1 db.SavedVersionedResources
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) GetVersionedResourcesReturnsOnCall(i int, result1 db.SavedVersionedResources, result2 error) {
	fake.GetVersionedResourcesStub = nil
	if fake.getVersionedResourcesReturnsOnCall == nil {
		fake.getVersionedResourcesReturnsOnCall = make(map[int]struct {
			result1 db.SavedVersionedResources
			result2 error
		})
	}
	fake.getVersionedResourcesReturnsOnCall[i] = struct {
		result1 db.SavedVersionedResources
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) SaveImageResourceVersion(arg1 db.UsedResourceCache) error {
	fake.saveImageResourceVersionMutex.Lock()
	ret, specificReturn := fake.saveImageResourceVersionReturnsOnCall[len(fake.saveImageResourceVersionArgsForCall)]
	fake.saveImageResourceVersionArgsForCall = append(fake.saveImageResourceVersionArgsForCall, struct {
		arg1 db.UsedResourceCache
	}{arg1})
	fake.recordInvocation("SaveImageResourceVersion", []interface{}{arg1})
	fake.saveImageResourceVersionMutex.Unlock()
	if fake.SaveImageResourceVersionStub != nil {
		return fake.SaveImageResourceVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveImageResourceVersionReturns.result1
}

func (fake *FakeBuild) SaveImageResourceVersionCallCount() int {
	fake.saveImageResourceVersionMutex.RLock()
	defer fake.saveImageResourceVersionMutex.RUnlock()
	return len(fake.saveImageResourceVersionArgsForCall)
}

func (fake *FakeBuild) SaveImageResourceVersionArgsForCall(i int) db.UsedResourceCache {
	fake.saveImageResourceVersionMutex.RLock()
	defer fake.saveImageResourceVersionMutex.RUnlock()
	return fake.saveImageResourceVersionArgsForCall[i].arg1
}

func (fake *FakeBuild) SaveImageResourceVersionReturns(result1 error) {
	fake.SaveImageResourceVersionStub = nil
	fake.saveImageResourceVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveImageResourceVersionReturnsOnCall(i int, result1 error) {
	fake.SaveImageResourceVersionStub = nil
	if fake.saveImageResourceVersionReturnsOnCall == nil {
		fake.saveImageResourceVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveImageResourceVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) Pipeline() (db.Pipeline, bool, error) {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct{}{})
	fake.recordInvocation("Pipeline", []interface{}{})
	fake.pipelineMutex.Unlock()
	if fake.PipelineStub != nil {
		return fake.PipelineStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.pipelineReturns.result1, fake.pipelineReturns.result2, fake.pipelineReturns.result3
}

func (fake *FakeBuild) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeBuild) PipelineReturns(result1 db.Pipeline, result2 bool, result3 error) {
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) PipelineReturnsOnCall(i int, result1 db.Pipeline, result2 bool, result3 error) {
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) Delete() (bool, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct{}{})
	fake.recordInvocation("Delete", []interface{}{})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteReturns.result1, fake.deleteReturns.result2
}

func (fake *FakeBuild) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeBuild) DeleteReturns(result1 bool, result2 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) DeleteReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) MarkAsAborted() error {
	fake.markAsAbortedMutex.Lock()
	ret, specificReturn := fake.markAsAbortedReturnsOnCall[len(fake.markAsAbortedArgsForCall)]
	fake.markAsAbortedArgsForCall = append(fake.markAsAbortedArgsForCall, struct{}{})
	fake.recordInvocation("MarkAsAborted", []interface{}{})
	fake.markAsAbortedMutex.Unlock()
	if fake.MarkAsAbortedStub != nil {
		return fake.MarkAsAbortedStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.markAsAbortedReturns.result1
}

func (fake *FakeBuild) MarkAsAbortedCallCount() int {
	fake.markAsAbortedMutex.RLock()
	defer fake.markAsAbortedMutex.RUnlock()
	return len(fake.markAsAbortedArgsForCall)
}

func (fake *FakeBuild) MarkAsAbortedReturns(result1 error) {
	fake.MarkAsAbortedStub = nil
	fake.markAsAbortedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) MarkAsAbortedReturnsOnCall(i int, result1 error) {
	fake.MarkAsAbortedStub = nil
	if fake.markAsAbortedReturnsOnCall == nil {
		fake.markAsAbortedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.markAsAbortedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) AbortNotifier() (db.Notifier, error) {
	fake.abortNotifierMutex.Lock()
	ret, specificReturn := fake.abortNotifierReturnsOnCall[len(fake.abortNotifierArgsForCall)]
	fake.abortNotifierArgsForCall = append(fake.abortNotifierArgsForCall, struct{}{})
	fake.recordInvocation("AbortNotifier", []interface{}{})
	fake.abortNotifierMutex.Unlock()
	if fake.AbortNotifierStub != nil {
		return fake.AbortNotifierStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.abortNotifierReturns.result1, fake.abortNotifierReturns.result2
}

func (fake *FakeBuild) AbortNotifierCallCount() int {
	fake.abortNotifierMutex.RLock()
	defer fake.abortNotifierMutex.RUnlock()
	return len(fake.abortNotifierArgsForCall)
}

func (fake *FakeBuild) AbortNotifierReturns(result1 db.Notifier, result2 error) {
	fake.AbortNotifierStub = nil
	fake.abortNotifierReturns = struct {
		result1 db.Notifier
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) AbortNotifierReturnsOnCall(i int, result1 db.Notifier, result2 error) {
	fake.AbortNotifierStub = nil
	if fake.abortNotifierReturnsOnCall == nil {
		fake.abortNotifierReturnsOnCall = make(map[int]struct {
			result1 db.Notifier
			result2 error
		})
	}
	fake.abortNotifierReturnsOnCall[i] = struct {
		result1 db.Notifier
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) Schedule() (bool, error) {
	fake.scheduleMutex.Lock()
	ret, specificReturn := fake.scheduleReturnsOnCall[len(fake.scheduleArgsForCall)]
	fake.scheduleArgsForCall = append(fake.scheduleArgsForCall, struct{}{})
	fake.recordInvocation("Schedule", []interface{}{})
	fake.scheduleMutex.Unlock()
	if fake.ScheduleStub != nil {
		return fake.ScheduleStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.scheduleReturns.result1, fake.scheduleReturns.result2
}

func (fake *FakeBuild) ScheduleCallCount() int {
	fake.scheduleMutex.RLock()
	defer fake.scheduleMutex.RUnlock()
	return len(fake.scheduleArgsForCall)
}

func (fake *FakeBuild) ScheduleReturns(result1 bool, result2 error) {
	fake.ScheduleStub = nil
	fake.scheduleReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) ScheduleReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ScheduleStub = nil
	if fake.scheduleReturnsOnCall == nil {
		fake.scheduleReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.scheduleReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) IsDrained() bool {
	fake.isDrainedMutex.Lock()
	ret, specificReturn := fake.isDrainedReturnsOnCall[len(fake.isDrainedArgsForCall)]
	fake.isDrainedArgsForCall = append(fake.isDrainedArgsForCall, struct{}{})
	fake.recordInvocation("IsDrained", []interface{}{})
	fake.isDrainedMutex.Unlock()
	if fake.IsDrainedStub != nil {
		return fake.IsDrainedStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isDrainedReturns.result1
}

func (fake *FakeBuild) IsDrainedCallCount() int {
	fake.isDrainedMutex.RLock()
	defer fake.isDrainedMutex.RUnlock()
	return len(fake.isDrainedArgsForCall)
}

func (fake *FakeBuild) IsDrainedReturns(result1 bool) {
	fake.IsDrainedStub = nil
	fake.isDrainedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsDrainedReturnsOnCall(i int, result1 bool) {
	fake.IsDrainedStub = nil
	if fake.isDrainedReturnsOnCall == nil {
		fake.isDrainedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDrainedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) SetDrained(arg1 bool) error {
	fake.setDrainedMutex.Lock()
	ret, specificReturn := fake.setDrainedReturnsOnCall[len(fake.setDrainedArgsForCall)]
	fake.setDrainedArgsForCall = append(fake.setDrainedArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("SetDrained", []interface{}{arg1})
	fake.setDrainedMutex.Unlock()
	if fake.SetDrainedStub != nil {
		return fake.SetDrainedStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setDrainedReturns.result1
}

func (fake *FakeBuild) SetDrainedCallCount() int {
	fake.setDrainedMutex.RLock()
	defer fake.setDrainedMutex.RUnlock()
	return len(fake.setDrainedArgsForCall)
}

func (fake *FakeBuild) SetDrainedArgsForCall(i int) bool {
	fake.setDrainedMutex.RLock()
	defer fake.setDrainedMutex.RUnlock()
	return fake.setDrainedArgsForCall[i].arg1
}

func (fake *FakeBuild) SetDrainedReturns(result1 error) {
	fake.SetDrainedStub = nil
	fake.setDrainedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SetDrainedReturnsOnCall(i int, result1 error) {
	fake.SetDrainedStub = nil
	if fake.setDrainedReturnsOnCall == nil {
		fake.setDrainedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setDrainedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	fake.jobNameMutex.RLock()
	defer fake.jobNameMutex.RUnlock()
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.engineMutex.RLock()
	defer fake.engineMutex.RUnlock()
	fake.engineMetadataMutex.RLock()
	defer fake.engineMetadataMutex.RUnlock()
	fake.publicPlanMutex.RLock()
	defer fake.publicPlanMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	fake.reapTimeMutex.RLock()
	defer fake.reapTimeMutex.RUnlock()
	fake.trackerMutex.RLock()
	defer fake.trackerMutex.RUnlock()
	fake.isManuallyTriggeredMutex.RLock()
	defer fake.isManuallyTriggeredMutex.RUnlock()
	fake.isScheduledMutex.RLock()
	defer fake.isScheduledMutex.RUnlock()
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	fake.trackedByMutex.RLock()
	defer fake.trackedByMutex.RUnlock()
	fake.interceptibleMutex.RLock()
	defer fake.interceptibleMutex.RUnlock()
	fake.preparationMutex.RLock()
	defer fake.preparationMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	fake.setInterceptibleMutex.RLock()
	defer fake.setInterceptibleMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.saveEventMutex.RLock()
	defer fake.saveEventMutex.RUnlock()
	fake.saveInputMutex.RLock()
	defer fake.saveInputMutex.RUnlock()
	fake.saveOutputMutex.RLock()
	defer fake.saveOutputMutex.RUnlock()
	fake.useInputsMutex.RLock()
	defer fake.useInputsMutex.RUnlock()
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	fake.getVersionedResourcesMutex.RLock()
	defer fake.getVersionedResourcesMutex.RUnlock()
	fake.saveImageResourceVersionMutex.RLock()
	defer fake.saveImageResourceVersionMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.markAsAbortedMutex.RLock()
	defer fake.markAsAbortedMutex.RUnlock()
	fake.abortNotifierMutex.RLock()
	defer fake.abortNotifierMutex.RUnlock()
	fake.scheduleMutex.RLock()
	defer fake.scheduleMutex.RUnlock()
	fake.isDrainedMutex.RLock()
	defer fake.isDrainedMutex.RUnlock()
	fake.setDrainedMutex.RLock()
	defer fake.setDrainedMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBuild) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Build = new(FakeBuild)
