// This file was generated by counterfeiter
package dbfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/algorithm"
	"github.com/concourse/atc/db/lock"
)

type FakePipelineDB struct {
	PipelineStub        func() db.SavedPipeline
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct{}
	pipelineReturns     struct {
		result1 db.SavedPipeline
	}
	GetPipelineNameStub        func() string
	getPipelineNameMutex       sync.RWMutex
	getPipelineNameArgsForCall []struct{}
	getPipelineNameReturns     struct {
		result1 string
	}
	GetPipelineIDStub        func() int
	getPipelineIDMutex       sync.RWMutex
	getPipelineIDArgsForCall []struct{}
	getPipelineIDReturns     struct {
		result1 int
	}
	ScopedNameStub        func(string) string
	scopedNameMutex       sync.RWMutex
	scopedNameArgsForCall []struct {
		arg1 string
	}
	scopedNameReturns struct {
		result1 string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct{}
	teamIDReturns     struct {
		result1 int
	}
	ConfigStub        func() atc.Config
	configMutex       sync.RWMutex
	configArgsForCall []struct{}
	configReturns     struct {
		result1 atc.Config
	}
	ConfigVersionStub        func() db.ConfigVersion
	configVersionMutex       sync.RWMutex
	configVersionArgsForCall []struct{}
	configVersionReturns     struct {
		result1 db.ConfigVersion
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct{}
	reloadReturns     struct {
		result1 bool
		result2 error
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct{}
	pauseReturns     struct {
		result1 error
	}
	UnpauseStub        func() error
	unpauseMutex       sync.RWMutex
	unpauseArgsForCall []struct{}
	unpauseReturns     struct {
		result1 error
	}
	IsPausedStub        func() (bool, error)
	isPausedMutex       sync.RWMutex
	isPausedArgsForCall []struct{}
	isPausedReturns     struct {
		result1 bool
		result2 error
	}
	IsPublicStub        func() bool
	isPublicMutex       sync.RWMutex
	isPublicArgsForCall []struct{}
	isPublicReturns     struct {
		result1 bool
	}
	UpdateNameStub        func(string) error
	updateNameMutex       sync.RWMutex
	updateNameArgsForCall []struct {
		arg1 string
	}
	updateNameReturns struct {
		result1 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct{}
	destroyReturns     struct {
		result1 error
	}
	AcquireSchedulingLockStub        func(lager.Logger, time.Duration) (lock.Lock, bool, error)
	acquireSchedulingLockMutex       sync.RWMutex
	acquireSchedulingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	acquireSchedulingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	GetResourceStub        func(resourceName string) (db.SavedResource, bool, error)
	getResourceMutex       sync.RWMutex
	getResourceArgsForCall []struct {
		resourceName string
	}
	getResourceReturns struct {
		result1 db.SavedResource
		result2 bool
		result3 error
	}
	GetResourcesStub        func() ([]db.SavedResource, bool, error)
	getResourcesMutex       sync.RWMutex
	getResourcesArgsForCall []struct{}
	getResourcesReturns     struct {
		result1 []db.SavedResource
		result2 bool
		result3 error
	}
	GetResourceTypeStub        func(resourceTypeName string) (db.SavedResourceType, bool, error)
	getResourceTypeMutex       sync.RWMutex
	getResourceTypeArgsForCall []struct {
		resourceTypeName string
	}
	getResourceTypeReturns struct {
		result1 db.SavedResourceType
		result2 bool
		result3 error
	}
	GetResourceVersionsStub        func(resourceName string, page db.Page) ([]db.SavedVersionedResource, db.Pagination, bool, error)
	getResourceVersionsMutex       sync.RWMutex
	getResourceVersionsArgsForCall []struct {
		resourceName string
		page         db.Page
	}
	getResourceVersionsReturns struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}
	PauseResourceStub        func(resourceName string) error
	pauseResourceMutex       sync.RWMutex
	pauseResourceArgsForCall []struct {
		resourceName string
	}
	pauseResourceReturns struct {
		result1 error
	}
	UnpauseResourceStub        func(resourceName string) error
	unpauseResourceMutex       sync.RWMutex
	unpauseResourceArgsForCall []struct {
		resourceName string
	}
	unpauseResourceReturns struct {
		result1 error
	}
	SaveResourceVersionsStub        func(atc.ResourceConfig, []atc.Version) error
	saveResourceVersionsMutex       sync.RWMutex
	saveResourceVersionsArgsForCall []struct {
		arg1 atc.ResourceConfig
		arg2 []atc.Version
	}
	saveResourceVersionsReturns struct {
		result1 error
	}
	SaveResourceTypeVersionStub        func(atc.ResourceType, atc.Version) error
	saveResourceTypeVersionMutex       sync.RWMutex
	saveResourceTypeVersionArgsForCall []struct {
		arg1 atc.ResourceType
		arg2 atc.Version
	}
	saveResourceTypeVersionReturns struct {
		result1 error
	}
	GetLatestVersionedResourceStub        func(resourceName string) (db.SavedVersionedResource, bool, error)
	getLatestVersionedResourceMutex       sync.RWMutex
	getLatestVersionedResourceArgsForCall []struct {
		resourceName string
	}
	getLatestVersionedResourceReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	GetLatestEnabledVersionedResourceStub        func(resourceName string) (db.SavedVersionedResource, bool, error)
	getLatestEnabledVersionedResourceMutex       sync.RWMutex
	getLatestEnabledVersionedResourceArgsForCall []struct {
		resourceName string
	}
	getLatestEnabledVersionedResourceReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	EnableVersionedResourceStub        func(versionedResourceID int) error
	enableVersionedResourceMutex       sync.RWMutex
	enableVersionedResourceArgsForCall []struct {
		versionedResourceID int
	}
	enableVersionedResourceReturns struct {
		result1 error
	}
	DisableVersionedResourceStub        func(versionedResourceID int) error
	disableVersionedResourceMutex       sync.RWMutex
	disableVersionedResourceArgsForCall []struct {
		versionedResourceID int
	}
	disableVersionedResourceReturns struct {
		result1 error
	}
	SetResourceCheckErrorStub        func(resource db.SavedResource, err error) error
	setResourceCheckErrorMutex       sync.RWMutex
	setResourceCheckErrorArgsForCall []struct {
		resource db.SavedResource
		err      error
	}
	setResourceCheckErrorReturns struct {
		result1 error
	}
	AcquireResourceCheckingLockStub        func(logger lager.Logger, resource db.SavedResource, length time.Duration, immediate bool) (lock.Lock, bool, error)
	acquireResourceCheckingLockMutex       sync.RWMutex
	acquireResourceCheckingLockArgsForCall []struct {
		logger    lager.Logger
		resource  db.SavedResource
		length    time.Duration
		immediate bool
	}
	acquireResourceCheckingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AcquireResourceTypeCheckingLockStub        func(logger lager.Logger, resourceType db.SavedResourceType, length time.Duration, immediate bool) (lock.Lock, bool, error)
	acquireResourceTypeCheckingLockMutex       sync.RWMutex
	acquireResourceTypeCheckingLockArgsForCall []struct {
		logger       lager.Logger
		resourceType db.SavedResourceType
		length       time.Duration
		immediate    bool
	}
	acquireResourceTypeCheckingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	GetJobsStub        func() ([]db.SavedJob, error)
	getJobsMutex       sync.RWMutex
	getJobsArgsForCall []struct{}
	getJobsReturns     struct {
		result1 []db.SavedJob
		result2 error
	}
	GetJobStub        func(job string) (db.SavedJob, bool, error)
	getJobMutex       sync.RWMutex
	getJobArgsForCall []struct {
		job string
	}
	getJobReturns struct {
		result1 db.SavedJob
		result2 bool
		result3 error
	}
	PauseJobStub        func(job string) error
	pauseJobMutex       sync.RWMutex
	pauseJobArgsForCall []struct {
		job string
	}
	pauseJobReturns struct {
		result1 error
	}
	UnpauseJobStub        func(job string) error
	unpauseJobMutex       sync.RWMutex
	unpauseJobArgsForCall []struct {
		job string
	}
	unpauseJobReturns struct {
		result1 error
	}
	SetMaxInFlightReachedStub        func(string, bool) error
	setMaxInFlightReachedMutex       sync.RWMutex
	setMaxInFlightReachedArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	setMaxInFlightReachedReturns struct {
		result1 error
	}
	UpdateFirstLoggedBuildIDStub        func(job string, newFirstLoggedBuildID int) error
	updateFirstLoggedBuildIDMutex       sync.RWMutex
	updateFirstLoggedBuildIDArgsForCall []struct {
		job                   string
		newFirstLoggedBuildID int
	}
	updateFirstLoggedBuildIDReturns struct {
		result1 error
	}
	GetJobFinishedAndNextBuildStub        func(job string) (db.Build, db.Build, error)
	getJobFinishedAndNextBuildMutex       sync.RWMutex
	getJobFinishedAndNextBuildArgsForCall []struct {
		job string
	}
	getJobFinishedAndNextBuildReturns struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}
	GetJobBuildsStub        func(job string, page db.Page) ([]db.Build, db.Pagination, error)
	getJobBuildsMutex       sync.RWMutex
	getJobBuildsArgsForCall []struct {
		job  string
		page db.Page
	}
	getJobBuildsReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	GetAllJobBuildsStub        func(job string) ([]db.Build, error)
	getAllJobBuildsMutex       sync.RWMutex
	getAllJobBuildsArgsForCall []struct {
		job string
	}
	getAllJobBuildsReturns struct {
		result1 []db.Build
		result2 error
	}
	GetJobBuildStub        func(job string, build string) (db.Build, bool, error)
	getJobBuildMutex       sync.RWMutex
	getJobBuildArgsForCall []struct {
		job   string
		build string
	}
	getJobBuildReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	CreateJobBuildStub        func(job string) (db.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		job string
	}
	createJobBuildReturns struct {
		result1 db.Build
		result2 error
	}
	EnsurePendingBuildExistsStub        func(jobName string) error
	ensurePendingBuildExistsMutex       sync.RWMutex
	ensurePendingBuildExistsArgsForCall []struct {
		jobName string
	}
	ensurePendingBuildExistsReturns struct {
		result1 error
	}
	GetPendingBuildsForJobStub        func(jobName string) ([]db.Build, error)
	getPendingBuildsForJobMutex       sync.RWMutex
	getPendingBuildsForJobArgsForCall []struct {
		jobName string
	}
	getPendingBuildsForJobReturns struct {
		result1 []db.Build
		result2 error
	}
	GetAllPendingBuildsStub        func() (map[string][]db.Build, error)
	getAllPendingBuildsMutex       sync.RWMutex
	getAllPendingBuildsArgsForCall []struct{}
	getAllPendingBuildsReturns     struct {
		result1 map[string][]db.Build
		result2 error
	}
	UseInputsForBuildStub        func(buildID int, inputs []db.BuildInput) error
	useInputsForBuildMutex       sync.RWMutex
	useInputsForBuildArgsForCall []struct {
		buildID int
		inputs  []db.BuildInput
	}
	useInputsForBuildReturns struct {
		result1 error
	}
	LoadVersionsDBStub        func() (*algorithm.VersionsDB, error)
	loadVersionsDBMutex       sync.RWMutex
	loadVersionsDBArgsForCall []struct{}
	loadVersionsDBReturns     struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	GetVersionedResourceByVersionStub        func(atcVersion atc.Version, resourceName string) (db.SavedVersionedResource, bool, error)
	getVersionedResourceByVersionMutex       sync.RWMutex
	getVersionedResourceByVersionArgsForCall []struct {
		atcVersion   atc.Version
		resourceName string
	}
	getVersionedResourceByVersionReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	SaveIndependentInputMappingStub        func(inputMapping algorithm.InputMapping, jobName string) error
	saveIndependentInputMappingMutex       sync.RWMutex
	saveIndependentInputMappingArgsForCall []struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}
	saveIndependentInputMappingReturns struct {
		result1 error
	}
	GetIndependentBuildInputsStub        func(jobName string) ([]db.BuildInput, error)
	getIndependentBuildInputsMutex       sync.RWMutex
	getIndependentBuildInputsArgsForCall []struct {
		jobName string
	}
	getIndependentBuildInputsReturns struct {
		result1 []db.BuildInput
		result2 error
	}
	SaveNextInputMappingStub        func(inputMapping algorithm.InputMapping, jobName string) error
	saveNextInputMappingMutex       sync.RWMutex
	saveNextInputMappingArgsForCall []struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}
	saveNextInputMappingReturns struct {
		result1 error
	}
	GetNextBuildInputsStub        func(jobName string) ([]db.BuildInput, bool, error)
	getNextBuildInputsMutex       sync.RWMutex
	getNextBuildInputsArgsForCall []struct {
		jobName string
	}
	getNextBuildInputsReturns struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	DeleteNextInputMappingStub        func(jobName string) error
	deleteNextInputMappingMutex       sync.RWMutex
	deleteNextInputMappingArgsForCall []struct {
		jobName string
	}
	deleteNextInputMappingReturns struct {
		result1 error
	}
	GetRunningBuildsBySerialGroupStub        func(jobName string, serialGroups []string) ([]db.Build, error)
	getRunningBuildsBySerialGroupMutex       sync.RWMutex
	getRunningBuildsBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getRunningBuildsBySerialGroupReturns struct {
		result1 []db.Build
		result2 error
	}
	GetNextPendingBuildBySerialGroupStub        func(jobName string, serialGroups []string) (db.Build, bool, error)
	getNextPendingBuildBySerialGroupMutex       sync.RWMutex
	getNextPendingBuildBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getNextPendingBuildBySerialGroupReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	UpdateBuildToScheduledStub        func(buildID int) (bool, error)
	updateBuildToScheduledMutex       sync.RWMutex
	updateBuildToScheduledArgsForCall []struct {
		buildID int
	}
	updateBuildToScheduledReturns struct {
		result1 bool
		result2 error
	}
	SaveInputStub        func(buildID int, input db.BuildInput) (db.SavedVersionedResource, error)
	saveInputMutex       sync.RWMutex
	saveInputArgsForCall []struct {
		buildID int
		input   db.BuildInput
	}
	saveInputReturns struct {
		result1 db.SavedVersionedResource
		result2 error
	}
	SaveOutputStub        func(buildID int, vr db.VersionedResource, explicit bool) (db.SavedVersionedResource, error)
	saveOutputMutex       sync.RWMutex
	saveOutputArgsForCall []struct {
		buildID  int
		vr       db.VersionedResource
		explicit bool
	}
	saveOutputReturns struct {
		result1 db.SavedVersionedResource
		result2 error
	}
	GetBuildsWithVersionAsInputStub        func(versionedResourceID int) ([]db.Build, error)
	getBuildsWithVersionAsInputMutex       sync.RWMutex
	getBuildsWithVersionAsInputArgsForCall []struct {
		versionedResourceID int
	}
	getBuildsWithVersionAsInputReturns struct {
		result1 []db.Build
		result2 error
	}
	GetBuildsWithVersionAsOutputStub        func(versionedResourceID int) ([]db.Build, error)
	getBuildsWithVersionAsOutputMutex       sync.RWMutex
	getBuildsWithVersionAsOutputArgsForCall []struct {
		versionedResourceID int
	}
	getBuildsWithVersionAsOutputReturns struct {
		result1 []db.Build
		result2 error
	}
	GetDashboardStub        func() (db.Dashboard, atc.GroupConfigs, error)
	getDashboardMutex       sync.RWMutex
	getDashboardArgsForCall []struct{}
	getDashboardReturns     struct {
		result1 db.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}
	ExposeStub        func() error
	exposeMutex       sync.RWMutex
	exposeArgsForCall []struct{}
	exposeReturns     struct {
		result1 error
	}
	HideStub        func() error
	hideMutex       sync.RWMutex
	hideArgsForCall []struct{}
	hideReturns     struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePipelineDB) Pipeline() db.SavedPipeline {
	fake.pipelineMutex.Lock()
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct{}{})
	fake.recordInvocation("Pipeline", []interface{}{})
	fake.pipelineMutex.Unlock()
	if fake.PipelineStub != nil {
		return fake.PipelineStub()
	} else {
		return fake.pipelineReturns.result1
	}
}

func (fake *FakePipelineDB) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakePipelineDB) PipelineReturns(result1 db.SavedPipeline) {
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 db.SavedPipeline
	}{result1}
}

func (fake *FakePipelineDB) GetPipelineName() string {
	fake.getPipelineNameMutex.Lock()
	fake.getPipelineNameArgsForCall = append(fake.getPipelineNameArgsForCall, struct{}{})
	fake.recordInvocation("GetPipelineName", []interface{}{})
	fake.getPipelineNameMutex.Unlock()
	if fake.GetPipelineNameStub != nil {
		return fake.GetPipelineNameStub()
	} else {
		return fake.getPipelineNameReturns.result1
	}
}

func (fake *FakePipelineDB) GetPipelineNameCallCount() int {
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	return len(fake.getPipelineNameArgsForCall)
}

func (fake *FakePipelineDB) GetPipelineNameReturns(result1 string) {
	fake.GetPipelineNameStub = nil
	fake.getPipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipelineDB) GetPipelineID() int {
	fake.getPipelineIDMutex.Lock()
	fake.getPipelineIDArgsForCall = append(fake.getPipelineIDArgsForCall, struct{}{})
	fake.recordInvocation("GetPipelineID", []interface{}{})
	fake.getPipelineIDMutex.Unlock()
	if fake.GetPipelineIDStub != nil {
		return fake.GetPipelineIDStub()
	} else {
		return fake.getPipelineIDReturns.result1
	}
}

func (fake *FakePipelineDB) GetPipelineIDCallCount() int {
	fake.getPipelineIDMutex.RLock()
	defer fake.getPipelineIDMutex.RUnlock()
	return len(fake.getPipelineIDArgsForCall)
}

func (fake *FakePipelineDB) GetPipelineIDReturns(result1 int) {
	fake.GetPipelineIDStub = nil
	fake.getPipelineIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipelineDB) ScopedName(arg1 string) string {
	fake.scopedNameMutex.Lock()
	fake.scopedNameArgsForCall = append(fake.scopedNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ScopedName", []interface{}{arg1})
	fake.scopedNameMutex.Unlock()
	if fake.ScopedNameStub != nil {
		return fake.ScopedNameStub(arg1)
	} else {
		return fake.scopedNameReturns.result1
	}
}

func (fake *FakePipelineDB) ScopedNameCallCount() int {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	return len(fake.scopedNameArgsForCall)
}

func (fake *FakePipelineDB) ScopedNameArgsForCall(i int) string {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	return fake.scopedNameArgsForCall[i].arg1
}

func (fake *FakePipelineDB) ScopedNameReturns(result1 string) {
	fake.ScopedNameStub = nil
	fake.scopedNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipelineDB) TeamID() int {
	fake.teamIDMutex.Lock()
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct{}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	} else {
		return fake.teamIDReturns.result1
	}
}

func (fake *FakePipelineDB) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakePipelineDB) TeamIDReturns(result1 int) {
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipelineDB) Config() atc.Config {
	fake.configMutex.Lock()
	fake.configArgsForCall = append(fake.configArgsForCall, struct{}{})
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if fake.ConfigStub != nil {
		return fake.ConfigStub()
	} else {
		return fake.configReturns.result1
	}
}

func (fake *FakePipelineDB) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakePipelineDB) ConfigReturns(result1 atc.Config) {
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 atc.Config
	}{result1}
}

func (fake *FakePipelineDB) ConfigVersion() db.ConfigVersion {
	fake.configVersionMutex.Lock()
	fake.configVersionArgsForCall = append(fake.configVersionArgsForCall, struct{}{})
	fake.recordInvocation("ConfigVersion", []interface{}{})
	fake.configVersionMutex.Unlock()
	if fake.ConfigVersionStub != nil {
		return fake.ConfigVersionStub()
	} else {
		return fake.configVersionReturns.result1
	}
}

func (fake *FakePipelineDB) ConfigVersionCallCount() int {
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	return len(fake.configVersionArgsForCall)
}

func (fake *FakePipelineDB) ConfigVersionReturns(result1 db.ConfigVersion) {
	fake.ConfigVersionStub = nil
	fake.configVersionReturns = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipelineDB) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct{}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	} else {
		return fake.reloadReturns.result1, fake.reloadReturns.result2
	}
}

func (fake *FakePipelineDB) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakePipelineDB) ReloadReturns(result1 bool, result2 error) {
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) Pause() error {
	fake.pauseMutex.Lock()
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct{}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	} else {
		return fake.pauseReturns.result1
	}
}

func (fake *FakePipelineDB) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakePipelineDB) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) Unpause() error {
	fake.unpauseMutex.Lock()
	fake.unpauseArgsForCall = append(fake.unpauseArgsForCall, struct{}{})
	fake.recordInvocation("Unpause", []interface{}{})
	fake.unpauseMutex.Unlock()
	if fake.UnpauseStub != nil {
		return fake.UnpauseStub()
	} else {
		return fake.unpauseReturns.result1
	}
}

func (fake *FakePipelineDB) UnpauseCallCount() int {
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	return len(fake.unpauseArgsForCall)
}

func (fake *FakePipelineDB) UnpauseReturns(result1 error) {
	fake.UnpauseStub = nil
	fake.unpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) IsPaused() (bool, error) {
	fake.isPausedMutex.Lock()
	fake.isPausedArgsForCall = append(fake.isPausedArgsForCall, struct{}{})
	fake.recordInvocation("IsPaused", []interface{}{})
	fake.isPausedMutex.Unlock()
	if fake.IsPausedStub != nil {
		return fake.IsPausedStub()
	} else {
		return fake.isPausedReturns.result1, fake.isPausedReturns.result2
	}
}

func (fake *FakePipelineDB) IsPausedCallCount() int {
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	return len(fake.isPausedArgsForCall)
}

func (fake *FakePipelineDB) IsPausedReturns(result1 bool, result2 error) {
	fake.IsPausedStub = nil
	fake.isPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) IsPublic() bool {
	fake.isPublicMutex.Lock()
	fake.isPublicArgsForCall = append(fake.isPublicArgsForCall, struct{}{})
	fake.recordInvocation("IsPublic", []interface{}{})
	fake.isPublicMutex.Unlock()
	if fake.IsPublicStub != nil {
		return fake.IsPublicStub()
	} else {
		return fake.isPublicReturns.result1
	}
}

func (fake *FakePipelineDB) IsPublicCallCount() int {
	fake.isPublicMutex.RLock()
	defer fake.isPublicMutex.RUnlock()
	return len(fake.isPublicArgsForCall)
}

func (fake *FakePipelineDB) IsPublicReturns(result1 bool) {
	fake.IsPublicStub = nil
	fake.isPublicReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipelineDB) UpdateName(arg1 string) error {
	fake.updateNameMutex.Lock()
	fake.updateNameArgsForCall = append(fake.updateNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("UpdateName", []interface{}{arg1})
	fake.updateNameMutex.Unlock()
	if fake.UpdateNameStub != nil {
		return fake.UpdateNameStub(arg1)
	} else {
		return fake.updateNameReturns.result1
	}
}

func (fake *FakePipelineDB) UpdateNameCallCount() int {
	fake.updateNameMutex.RLock()
	defer fake.updateNameMutex.RUnlock()
	return len(fake.updateNameArgsForCall)
}

func (fake *FakePipelineDB) UpdateNameArgsForCall(i int) string {
	fake.updateNameMutex.RLock()
	defer fake.updateNameMutex.RUnlock()
	return fake.updateNameArgsForCall[i].arg1
}

func (fake *FakePipelineDB) UpdateNameReturns(result1 error) {
	fake.UpdateNameStub = nil
	fake.updateNameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) Destroy() error {
	fake.destroyMutex.Lock()
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct{}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	} else {
		return fake.destroyReturns.result1
	}
}

func (fake *FakePipelineDB) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakePipelineDB) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) AcquireSchedulingLock(arg1 lager.Logger, arg2 time.Duration) (lock.Lock, bool, error) {
	fake.acquireSchedulingLockMutex.Lock()
	fake.acquireSchedulingLockArgsForCall = append(fake.acquireSchedulingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("AcquireSchedulingLock", []interface{}{arg1, arg2})
	fake.acquireSchedulingLockMutex.Unlock()
	if fake.AcquireSchedulingLockStub != nil {
		return fake.AcquireSchedulingLockStub(arg1, arg2)
	} else {
		return fake.acquireSchedulingLockReturns.result1, fake.acquireSchedulingLockReturns.result2, fake.acquireSchedulingLockReturns.result3
	}
}

func (fake *FakePipelineDB) AcquireSchedulingLockCallCount() int {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return len(fake.acquireSchedulingLockArgsForCall)
}

func (fake *FakePipelineDB) AcquireSchedulingLockArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return fake.acquireSchedulingLockArgsForCall[i].arg1, fake.acquireSchedulingLockArgsForCall[i].arg2
}

func (fake *FakePipelineDB) AcquireSchedulingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireSchedulingLockStub = nil
	fake.acquireSchedulingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetResource(resourceName string) (db.SavedResource, bool, error) {
	fake.getResourceMutex.Lock()
	fake.getResourceArgsForCall = append(fake.getResourceArgsForCall, struct {
		resourceName string
	}{resourceName})
	fake.recordInvocation("GetResource", []interface{}{resourceName})
	fake.getResourceMutex.Unlock()
	if fake.GetResourceStub != nil {
		return fake.GetResourceStub(resourceName)
	} else {
		return fake.getResourceReturns.result1, fake.getResourceReturns.result2, fake.getResourceReturns.result3
	}
}

func (fake *FakePipelineDB) GetResourceCallCount() int {
	fake.getResourceMutex.RLock()
	defer fake.getResourceMutex.RUnlock()
	return len(fake.getResourceArgsForCall)
}

func (fake *FakePipelineDB) GetResourceArgsForCall(i int) string {
	fake.getResourceMutex.RLock()
	defer fake.getResourceMutex.RUnlock()
	return fake.getResourceArgsForCall[i].resourceName
}

func (fake *FakePipelineDB) GetResourceReturns(result1 db.SavedResource, result2 bool, result3 error) {
	fake.GetResourceStub = nil
	fake.getResourceReturns = struct {
		result1 db.SavedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetResources() ([]db.SavedResource, bool, error) {
	fake.getResourcesMutex.Lock()
	fake.getResourcesArgsForCall = append(fake.getResourcesArgsForCall, struct{}{})
	fake.recordInvocation("GetResources", []interface{}{})
	fake.getResourcesMutex.Unlock()
	if fake.GetResourcesStub != nil {
		return fake.GetResourcesStub()
	} else {
		return fake.getResourcesReturns.result1, fake.getResourcesReturns.result2, fake.getResourcesReturns.result3
	}
}

func (fake *FakePipelineDB) GetResourcesCallCount() int {
	fake.getResourcesMutex.RLock()
	defer fake.getResourcesMutex.RUnlock()
	return len(fake.getResourcesArgsForCall)
}

func (fake *FakePipelineDB) GetResourcesReturns(result1 []db.SavedResource, result2 bool, result3 error) {
	fake.GetResourcesStub = nil
	fake.getResourcesReturns = struct {
		result1 []db.SavedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetResourceType(resourceTypeName string) (db.SavedResourceType, bool, error) {
	fake.getResourceTypeMutex.Lock()
	fake.getResourceTypeArgsForCall = append(fake.getResourceTypeArgsForCall, struct {
		resourceTypeName string
	}{resourceTypeName})
	fake.recordInvocation("GetResourceType", []interface{}{resourceTypeName})
	fake.getResourceTypeMutex.Unlock()
	if fake.GetResourceTypeStub != nil {
		return fake.GetResourceTypeStub(resourceTypeName)
	} else {
		return fake.getResourceTypeReturns.result1, fake.getResourceTypeReturns.result2, fake.getResourceTypeReturns.result3
	}
}

func (fake *FakePipelineDB) GetResourceTypeCallCount() int {
	fake.getResourceTypeMutex.RLock()
	defer fake.getResourceTypeMutex.RUnlock()
	return len(fake.getResourceTypeArgsForCall)
}

func (fake *FakePipelineDB) GetResourceTypeArgsForCall(i int) string {
	fake.getResourceTypeMutex.RLock()
	defer fake.getResourceTypeMutex.RUnlock()
	return fake.getResourceTypeArgsForCall[i].resourceTypeName
}

func (fake *FakePipelineDB) GetResourceTypeReturns(result1 db.SavedResourceType, result2 bool, result3 error) {
	fake.GetResourceTypeStub = nil
	fake.getResourceTypeReturns = struct {
		result1 db.SavedResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetResourceVersions(resourceName string, page db.Page) ([]db.SavedVersionedResource, db.Pagination, bool, error) {
	fake.getResourceVersionsMutex.Lock()
	fake.getResourceVersionsArgsForCall = append(fake.getResourceVersionsArgsForCall, struct {
		resourceName string
		page         db.Page
	}{resourceName, page})
	fake.recordInvocation("GetResourceVersions", []interface{}{resourceName, page})
	fake.getResourceVersionsMutex.Unlock()
	if fake.GetResourceVersionsStub != nil {
		return fake.GetResourceVersionsStub(resourceName, page)
	} else {
		return fake.getResourceVersionsReturns.result1, fake.getResourceVersionsReturns.result2, fake.getResourceVersionsReturns.result3, fake.getResourceVersionsReturns.result4
	}
}

func (fake *FakePipelineDB) GetResourceVersionsCallCount() int {
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	return len(fake.getResourceVersionsArgsForCall)
}

func (fake *FakePipelineDB) GetResourceVersionsArgsForCall(i int) (string, db.Page) {
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	return fake.getResourceVersionsArgsForCall[i].resourceName, fake.getResourceVersionsArgsForCall[i].page
}

func (fake *FakePipelineDB) GetResourceVersionsReturns(result1 []db.SavedVersionedResource, result2 db.Pagination, result3 bool, result4 error) {
	fake.GetResourceVersionsStub = nil
	fake.getResourceVersionsReturns = struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePipelineDB) PauseResource(resourceName string) error {
	fake.pauseResourceMutex.Lock()
	fake.pauseResourceArgsForCall = append(fake.pauseResourceArgsForCall, struct {
		resourceName string
	}{resourceName})
	fake.recordInvocation("PauseResource", []interface{}{resourceName})
	fake.pauseResourceMutex.Unlock()
	if fake.PauseResourceStub != nil {
		return fake.PauseResourceStub(resourceName)
	} else {
		return fake.pauseResourceReturns.result1
	}
}

func (fake *FakePipelineDB) PauseResourceCallCount() int {
	fake.pauseResourceMutex.RLock()
	defer fake.pauseResourceMutex.RUnlock()
	return len(fake.pauseResourceArgsForCall)
}

func (fake *FakePipelineDB) PauseResourceArgsForCall(i int) string {
	fake.pauseResourceMutex.RLock()
	defer fake.pauseResourceMutex.RUnlock()
	return fake.pauseResourceArgsForCall[i].resourceName
}

func (fake *FakePipelineDB) PauseResourceReturns(result1 error) {
	fake.PauseResourceStub = nil
	fake.pauseResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) UnpauseResource(resourceName string) error {
	fake.unpauseResourceMutex.Lock()
	fake.unpauseResourceArgsForCall = append(fake.unpauseResourceArgsForCall, struct {
		resourceName string
	}{resourceName})
	fake.recordInvocation("UnpauseResource", []interface{}{resourceName})
	fake.unpauseResourceMutex.Unlock()
	if fake.UnpauseResourceStub != nil {
		return fake.UnpauseResourceStub(resourceName)
	} else {
		return fake.unpauseResourceReturns.result1
	}
}

func (fake *FakePipelineDB) UnpauseResourceCallCount() int {
	fake.unpauseResourceMutex.RLock()
	defer fake.unpauseResourceMutex.RUnlock()
	return len(fake.unpauseResourceArgsForCall)
}

func (fake *FakePipelineDB) UnpauseResourceArgsForCall(i int) string {
	fake.unpauseResourceMutex.RLock()
	defer fake.unpauseResourceMutex.RUnlock()
	return fake.unpauseResourceArgsForCall[i].resourceName
}

func (fake *FakePipelineDB) UnpauseResourceReturns(result1 error) {
	fake.UnpauseResourceStub = nil
	fake.unpauseResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SaveResourceVersions(arg1 atc.ResourceConfig, arg2 []atc.Version) error {
	var arg2Copy []atc.Version
	if arg2 != nil {
		arg2Copy = make([]atc.Version, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.saveResourceVersionsMutex.Lock()
	fake.saveResourceVersionsArgsForCall = append(fake.saveResourceVersionsArgsForCall, struct {
		arg1 atc.ResourceConfig
		arg2 []atc.Version
	}{arg1, arg2Copy})
	fake.recordInvocation("SaveResourceVersions", []interface{}{arg1, arg2Copy})
	fake.saveResourceVersionsMutex.Unlock()
	if fake.SaveResourceVersionsStub != nil {
		return fake.SaveResourceVersionsStub(arg1, arg2)
	} else {
		return fake.saveResourceVersionsReturns.result1
	}
}

func (fake *FakePipelineDB) SaveResourceVersionsCallCount() int {
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	return len(fake.saveResourceVersionsArgsForCall)
}

func (fake *FakePipelineDB) SaveResourceVersionsArgsForCall(i int) (atc.ResourceConfig, []atc.Version) {
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	return fake.saveResourceVersionsArgsForCall[i].arg1, fake.saveResourceVersionsArgsForCall[i].arg2
}

func (fake *FakePipelineDB) SaveResourceVersionsReturns(result1 error) {
	fake.SaveResourceVersionsStub = nil
	fake.saveResourceVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SaveResourceTypeVersion(arg1 atc.ResourceType, arg2 atc.Version) error {
	fake.saveResourceTypeVersionMutex.Lock()
	fake.saveResourceTypeVersionArgsForCall = append(fake.saveResourceTypeVersionArgsForCall, struct {
		arg1 atc.ResourceType
		arg2 atc.Version
	}{arg1, arg2})
	fake.recordInvocation("SaveResourceTypeVersion", []interface{}{arg1, arg2})
	fake.saveResourceTypeVersionMutex.Unlock()
	if fake.SaveResourceTypeVersionStub != nil {
		return fake.SaveResourceTypeVersionStub(arg1, arg2)
	} else {
		return fake.saveResourceTypeVersionReturns.result1
	}
}

func (fake *FakePipelineDB) SaveResourceTypeVersionCallCount() int {
	fake.saveResourceTypeVersionMutex.RLock()
	defer fake.saveResourceTypeVersionMutex.RUnlock()
	return len(fake.saveResourceTypeVersionArgsForCall)
}

func (fake *FakePipelineDB) SaveResourceTypeVersionArgsForCall(i int) (atc.ResourceType, atc.Version) {
	fake.saveResourceTypeVersionMutex.RLock()
	defer fake.saveResourceTypeVersionMutex.RUnlock()
	return fake.saveResourceTypeVersionArgsForCall[i].arg1, fake.saveResourceTypeVersionArgsForCall[i].arg2
}

func (fake *FakePipelineDB) SaveResourceTypeVersionReturns(result1 error) {
	fake.SaveResourceTypeVersionStub = nil
	fake.saveResourceTypeVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) GetLatestVersionedResource(resourceName string) (db.SavedVersionedResource, bool, error) {
	fake.getLatestVersionedResourceMutex.Lock()
	fake.getLatestVersionedResourceArgsForCall = append(fake.getLatestVersionedResourceArgsForCall, struct {
		resourceName string
	}{resourceName})
	fake.recordInvocation("GetLatestVersionedResource", []interface{}{resourceName})
	fake.getLatestVersionedResourceMutex.Unlock()
	if fake.GetLatestVersionedResourceStub != nil {
		return fake.GetLatestVersionedResourceStub(resourceName)
	} else {
		return fake.getLatestVersionedResourceReturns.result1, fake.getLatestVersionedResourceReturns.result2, fake.getLatestVersionedResourceReturns.result3
	}
}

func (fake *FakePipelineDB) GetLatestVersionedResourceCallCount() int {
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	return len(fake.getLatestVersionedResourceArgsForCall)
}

func (fake *FakePipelineDB) GetLatestVersionedResourceArgsForCall(i int) string {
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	return fake.getLatestVersionedResourceArgsForCall[i].resourceName
}

func (fake *FakePipelineDB) GetLatestVersionedResourceReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetLatestVersionedResourceStub = nil
	fake.getLatestVersionedResourceReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetLatestEnabledVersionedResource(resourceName string) (db.SavedVersionedResource, bool, error) {
	fake.getLatestEnabledVersionedResourceMutex.Lock()
	fake.getLatestEnabledVersionedResourceArgsForCall = append(fake.getLatestEnabledVersionedResourceArgsForCall, struct {
		resourceName string
	}{resourceName})
	fake.recordInvocation("GetLatestEnabledVersionedResource", []interface{}{resourceName})
	fake.getLatestEnabledVersionedResourceMutex.Unlock()
	if fake.GetLatestEnabledVersionedResourceStub != nil {
		return fake.GetLatestEnabledVersionedResourceStub(resourceName)
	} else {
		return fake.getLatestEnabledVersionedResourceReturns.result1, fake.getLatestEnabledVersionedResourceReturns.result2, fake.getLatestEnabledVersionedResourceReturns.result3
	}
}

func (fake *FakePipelineDB) GetLatestEnabledVersionedResourceCallCount() int {
	fake.getLatestEnabledVersionedResourceMutex.RLock()
	defer fake.getLatestEnabledVersionedResourceMutex.RUnlock()
	return len(fake.getLatestEnabledVersionedResourceArgsForCall)
}

func (fake *FakePipelineDB) GetLatestEnabledVersionedResourceArgsForCall(i int) string {
	fake.getLatestEnabledVersionedResourceMutex.RLock()
	defer fake.getLatestEnabledVersionedResourceMutex.RUnlock()
	return fake.getLatestEnabledVersionedResourceArgsForCall[i].resourceName
}

func (fake *FakePipelineDB) GetLatestEnabledVersionedResourceReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetLatestEnabledVersionedResourceStub = nil
	fake.getLatestEnabledVersionedResourceReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) EnableVersionedResource(versionedResourceID int) error {
	fake.enableVersionedResourceMutex.Lock()
	fake.enableVersionedResourceArgsForCall = append(fake.enableVersionedResourceArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("EnableVersionedResource", []interface{}{versionedResourceID})
	fake.enableVersionedResourceMutex.Unlock()
	if fake.EnableVersionedResourceStub != nil {
		return fake.EnableVersionedResourceStub(versionedResourceID)
	} else {
		return fake.enableVersionedResourceReturns.result1
	}
}

func (fake *FakePipelineDB) EnableVersionedResourceCallCount() int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	return len(fake.enableVersionedResourceArgsForCall)
}

func (fake *FakePipelineDB) EnableVersionedResourceArgsForCall(i int) int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	return fake.enableVersionedResourceArgsForCall[i].versionedResourceID
}

func (fake *FakePipelineDB) EnableVersionedResourceReturns(result1 error) {
	fake.EnableVersionedResourceStub = nil
	fake.enableVersionedResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) DisableVersionedResource(versionedResourceID int) error {
	fake.disableVersionedResourceMutex.Lock()
	fake.disableVersionedResourceArgsForCall = append(fake.disableVersionedResourceArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("DisableVersionedResource", []interface{}{versionedResourceID})
	fake.disableVersionedResourceMutex.Unlock()
	if fake.DisableVersionedResourceStub != nil {
		return fake.DisableVersionedResourceStub(versionedResourceID)
	} else {
		return fake.disableVersionedResourceReturns.result1
	}
}

func (fake *FakePipelineDB) DisableVersionedResourceCallCount() int {
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	return len(fake.disableVersionedResourceArgsForCall)
}

func (fake *FakePipelineDB) DisableVersionedResourceArgsForCall(i int) int {
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	return fake.disableVersionedResourceArgsForCall[i].versionedResourceID
}

func (fake *FakePipelineDB) DisableVersionedResourceReturns(result1 error) {
	fake.DisableVersionedResourceStub = nil
	fake.disableVersionedResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SetResourceCheckError(resource db.SavedResource, err error) error {
	fake.setResourceCheckErrorMutex.Lock()
	fake.setResourceCheckErrorArgsForCall = append(fake.setResourceCheckErrorArgsForCall, struct {
		resource db.SavedResource
		err      error
	}{resource, err})
	fake.recordInvocation("SetResourceCheckError", []interface{}{resource, err})
	fake.setResourceCheckErrorMutex.Unlock()
	if fake.SetResourceCheckErrorStub != nil {
		return fake.SetResourceCheckErrorStub(resource, err)
	} else {
		return fake.setResourceCheckErrorReturns.result1
	}
}

func (fake *FakePipelineDB) SetResourceCheckErrorCallCount() int {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	return len(fake.setResourceCheckErrorArgsForCall)
}

func (fake *FakePipelineDB) SetResourceCheckErrorArgsForCall(i int) (db.SavedResource, error) {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	return fake.setResourceCheckErrorArgsForCall[i].resource, fake.setResourceCheckErrorArgsForCall[i].err
}

func (fake *FakePipelineDB) SetResourceCheckErrorReturns(result1 error) {
	fake.SetResourceCheckErrorStub = nil
	fake.setResourceCheckErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) AcquireResourceCheckingLock(logger lager.Logger, resource db.SavedResource, length time.Duration, immediate bool) (lock.Lock, bool, error) {
	fake.acquireResourceCheckingLockMutex.Lock()
	fake.acquireResourceCheckingLockArgsForCall = append(fake.acquireResourceCheckingLockArgsForCall, struct {
		logger    lager.Logger
		resource  db.SavedResource
		length    time.Duration
		immediate bool
	}{logger, resource, length, immediate})
	fake.recordInvocation("AcquireResourceCheckingLock", []interface{}{logger, resource, length, immediate})
	fake.acquireResourceCheckingLockMutex.Unlock()
	if fake.AcquireResourceCheckingLockStub != nil {
		return fake.AcquireResourceCheckingLockStub(logger, resource, length, immediate)
	} else {
		return fake.acquireResourceCheckingLockReturns.result1, fake.acquireResourceCheckingLockReturns.result2, fake.acquireResourceCheckingLockReturns.result3
	}
}

func (fake *FakePipelineDB) AcquireResourceCheckingLockCallCount() int {
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	return len(fake.acquireResourceCheckingLockArgsForCall)
}

func (fake *FakePipelineDB) AcquireResourceCheckingLockArgsForCall(i int) (lager.Logger, db.SavedResource, time.Duration, bool) {
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	return fake.acquireResourceCheckingLockArgsForCall[i].logger, fake.acquireResourceCheckingLockArgsForCall[i].resource, fake.acquireResourceCheckingLockArgsForCall[i].length, fake.acquireResourceCheckingLockArgsForCall[i].immediate
}

func (fake *FakePipelineDB) AcquireResourceCheckingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockStub = nil
	fake.acquireResourceCheckingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) AcquireResourceTypeCheckingLock(logger lager.Logger, resourceType db.SavedResourceType, length time.Duration, immediate bool) (lock.Lock, bool, error) {
	fake.acquireResourceTypeCheckingLockMutex.Lock()
	fake.acquireResourceTypeCheckingLockArgsForCall = append(fake.acquireResourceTypeCheckingLockArgsForCall, struct {
		logger       lager.Logger
		resourceType db.SavedResourceType
		length       time.Duration
		immediate    bool
	}{logger, resourceType, length, immediate})
	fake.recordInvocation("AcquireResourceTypeCheckingLock", []interface{}{logger, resourceType, length, immediate})
	fake.acquireResourceTypeCheckingLockMutex.Unlock()
	if fake.AcquireResourceTypeCheckingLockStub != nil {
		return fake.AcquireResourceTypeCheckingLockStub(logger, resourceType, length, immediate)
	} else {
		return fake.acquireResourceTypeCheckingLockReturns.result1, fake.acquireResourceTypeCheckingLockReturns.result2, fake.acquireResourceTypeCheckingLockReturns.result3
	}
}

func (fake *FakePipelineDB) AcquireResourceTypeCheckingLockCallCount() int {
	fake.acquireResourceTypeCheckingLockMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockMutex.RUnlock()
	return len(fake.acquireResourceTypeCheckingLockArgsForCall)
}

func (fake *FakePipelineDB) AcquireResourceTypeCheckingLockArgsForCall(i int) (lager.Logger, db.SavedResourceType, time.Duration, bool) {
	fake.acquireResourceTypeCheckingLockMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockMutex.RUnlock()
	return fake.acquireResourceTypeCheckingLockArgsForCall[i].logger, fake.acquireResourceTypeCheckingLockArgsForCall[i].resourceType, fake.acquireResourceTypeCheckingLockArgsForCall[i].length, fake.acquireResourceTypeCheckingLockArgsForCall[i].immediate
}

func (fake *FakePipelineDB) AcquireResourceTypeCheckingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceTypeCheckingLockStub = nil
	fake.acquireResourceTypeCheckingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetJobs() ([]db.SavedJob, error) {
	fake.getJobsMutex.Lock()
	fake.getJobsArgsForCall = append(fake.getJobsArgsForCall, struct{}{})
	fake.recordInvocation("GetJobs", []interface{}{})
	fake.getJobsMutex.Unlock()
	if fake.GetJobsStub != nil {
		return fake.GetJobsStub()
	} else {
		return fake.getJobsReturns.result1, fake.getJobsReturns.result2
	}
}

func (fake *FakePipelineDB) GetJobsCallCount() int {
	fake.getJobsMutex.RLock()
	defer fake.getJobsMutex.RUnlock()
	return len(fake.getJobsArgsForCall)
}

func (fake *FakePipelineDB) GetJobsReturns(result1 []db.SavedJob, result2 error) {
	fake.GetJobsStub = nil
	fake.getJobsReturns = struct {
		result1 []db.SavedJob
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetJob(job string) (db.SavedJob, bool, error) {
	fake.getJobMutex.Lock()
	fake.getJobArgsForCall = append(fake.getJobArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetJob", []interface{}{job})
	fake.getJobMutex.Unlock()
	if fake.GetJobStub != nil {
		return fake.GetJobStub(job)
	} else {
		return fake.getJobReturns.result1, fake.getJobReturns.result2, fake.getJobReturns.result3
	}
}

func (fake *FakePipelineDB) GetJobCallCount() int {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return len(fake.getJobArgsForCall)
}

func (fake *FakePipelineDB) GetJobArgsForCall(i int) string {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return fake.getJobArgsForCall[i].job
}

func (fake *FakePipelineDB) GetJobReturns(result1 db.SavedJob, result2 bool, result3 error) {
	fake.GetJobStub = nil
	fake.getJobReturns = struct {
		result1 db.SavedJob
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) PauseJob(job string) error {
	fake.pauseJobMutex.Lock()
	fake.pauseJobArgsForCall = append(fake.pauseJobArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("PauseJob", []interface{}{job})
	fake.pauseJobMutex.Unlock()
	if fake.PauseJobStub != nil {
		return fake.PauseJobStub(job)
	} else {
		return fake.pauseJobReturns.result1
	}
}

func (fake *FakePipelineDB) PauseJobCallCount() int {
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	return len(fake.pauseJobArgsForCall)
}

func (fake *FakePipelineDB) PauseJobArgsForCall(i int) string {
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	return fake.pauseJobArgsForCall[i].job
}

func (fake *FakePipelineDB) PauseJobReturns(result1 error) {
	fake.PauseJobStub = nil
	fake.pauseJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) UnpauseJob(job string) error {
	fake.unpauseJobMutex.Lock()
	fake.unpauseJobArgsForCall = append(fake.unpauseJobArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("UnpauseJob", []interface{}{job})
	fake.unpauseJobMutex.Unlock()
	if fake.UnpauseJobStub != nil {
		return fake.UnpauseJobStub(job)
	} else {
		return fake.unpauseJobReturns.result1
	}
}

func (fake *FakePipelineDB) UnpauseJobCallCount() int {
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	return len(fake.unpauseJobArgsForCall)
}

func (fake *FakePipelineDB) UnpauseJobArgsForCall(i int) string {
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	return fake.unpauseJobArgsForCall[i].job
}

func (fake *FakePipelineDB) UnpauseJobReturns(result1 error) {
	fake.UnpauseJobStub = nil
	fake.unpauseJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SetMaxInFlightReached(arg1 string, arg2 bool) error {
	fake.setMaxInFlightReachedMutex.Lock()
	fake.setMaxInFlightReachedArgsForCall = append(fake.setMaxInFlightReachedArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("SetMaxInFlightReached", []interface{}{arg1, arg2})
	fake.setMaxInFlightReachedMutex.Unlock()
	if fake.SetMaxInFlightReachedStub != nil {
		return fake.SetMaxInFlightReachedStub(arg1, arg2)
	} else {
		return fake.setMaxInFlightReachedReturns.result1
	}
}

func (fake *FakePipelineDB) SetMaxInFlightReachedCallCount() int {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return len(fake.setMaxInFlightReachedArgsForCall)
}

func (fake *FakePipelineDB) SetMaxInFlightReachedArgsForCall(i int) (string, bool) {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return fake.setMaxInFlightReachedArgsForCall[i].arg1, fake.setMaxInFlightReachedArgsForCall[i].arg2
}

func (fake *FakePipelineDB) SetMaxInFlightReachedReturns(result1 error) {
	fake.SetMaxInFlightReachedStub = nil
	fake.setMaxInFlightReachedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) UpdateFirstLoggedBuildID(job string, newFirstLoggedBuildID int) error {
	fake.updateFirstLoggedBuildIDMutex.Lock()
	fake.updateFirstLoggedBuildIDArgsForCall = append(fake.updateFirstLoggedBuildIDArgsForCall, struct {
		job                   string
		newFirstLoggedBuildID int
	}{job, newFirstLoggedBuildID})
	fake.recordInvocation("UpdateFirstLoggedBuildID", []interface{}{job, newFirstLoggedBuildID})
	fake.updateFirstLoggedBuildIDMutex.Unlock()
	if fake.UpdateFirstLoggedBuildIDStub != nil {
		return fake.UpdateFirstLoggedBuildIDStub(job, newFirstLoggedBuildID)
	} else {
		return fake.updateFirstLoggedBuildIDReturns.result1
	}
}

func (fake *FakePipelineDB) UpdateFirstLoggedBuildIDCallCount() int {
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	return len(fake.updateFirstLoggedBuildIDArgsForCall)
}

func (fake *FakePipelineDB) UpdateFirstLoggedBuildIDArgsForCall(i int) (string, int) {
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	return fake.updateFirstLoggedBuildIDArgsForCall[i].job, fake.updateFirstLoggedBuildIDArgsForCall[i].newFirstLoggedBuildID
}

func (fake *FakePipelineDB) UpdateFirstLoggedBuildIDReturns(result1 error) {
	fake.UpdateFirstLoggedBuildIDStub = nil
	fake.updateFirstLoggedBuildIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) GetJobFinishedAndNextBuild(job string) (db.Build, db.Build, error) {
	fake.getJobFinishedAndNextBuildMutex.Lock()
	fake.getJobFinishedAndNextBuildArgsForCall = append(fake.getJobFinishedAndNextBuildArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetJobFinishedAndNextBuild", []interface{}{job})
	fake.getJobFinishedAndNextBuildMutex.Unlock()
	if fake.GetJobFinishedAndNextBuildStub != nil {
		return fake.GetJobFinishedAndNextBuildStub(job)
	} else {
		return fake.getJobFinishedAndNextBuildReturns.result1, fake.getJobFinishedAndNextBuildReturns.result2, fake.getJobFinishedAndNextBuildReturns.result3
	}
}

func (fake *FakePipelineDB) GetJobFinishedAndNextBuildCallCount() int {
	fake.getJobFinishedAndNextBuildMutex.RLock()
	defer fake.getJobFinishedAndNextBuildMutex.RUnlock()
	return len(fake.getJobFinishedAndNextBuildArgsForCall)
}

func (fake *FakePipelineDB) GetJobFinishedAndNextBuildArgsForCall(i int) string {
	fake.getJobFinishedAndNextBuildMutex.RLock()
	defer fake.getJobFinishedAndNextBuildMutex.RUnlock()
	return fake.getJobFinishedAndNextBuildArgsForCall[i].job
}

func (fake *FakePipelineDB) GetJobFinishedAndNextBuildReturns(result1 db.Build, result2 db.Build, result3 error) {
	fake.GetJobFinishedAndNextBuildStub = nil
	fake.getJobFinishedAndNextBuildReturns = struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetJobBuilds(job string, page db.Page) ([]db.Build, db.Pagination, error) {
	fake.getJobBuildsMutex.Lock()
	fake.getJobBuildsArgsForCall = append(fake.getJobBuildsArgsForCall, struct {
		job  string
		page db.Page
	}{job, page})
	fake.recordInvocation("GetJobBuilds", []interface{}{job, page})
	fake.getJobBuildsMutex.Unlock()
	if fake.GetJobBuildsStub != nil {
		return fake.GetJobBuildsStub(job, page)
	} else {
		return fake.getJobBuildsReturns.result1, fake.getJobBuildsReturns.result2, fake.getJobBuildsReturns.result3
	}
}

func (fake *FakePipelineDB) GetJobBuildsCallCount() int {
	fake.getJobBuildsMutex.RLock()
	defer fake.getJobBuildsMutex.RUnlock()
	return len(fake.getJobBuildsArgsForCall)
}

func (fake *FakePipelineDB) GetJobBuildsArgsForCall(i int) (string, db.Page) {
	fake.getJobBuildsMutex.RLock()
	defer fake.getJobBuildsMutex.RUnlock()
	return fake.getJobBuildsArgsForCall[i].job, fake.getJobBuildsArgsForCall[i].page
}

func (fake *FakePipelineDB) GetJobBuildsReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.GetJobBuildsStub = nil
	fake.getJobBuildsReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetAllJobBuilds(job string) ([]db.Build, error) {
	fake.getAllJobBuildsMutex.Lock()
	fake.getAllJobBuildsArgsForCall = append(fake.getAllJobBuildsArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetAllJobBuilds", []interface{}{job})
	fake.getAllJobBuildsMutex.Unlock()
	if fake.GetAllJobBuildsStub != nil {
		return fake.GetAllJobBuildsStub(job)
	} else {
		return fake.getAllJobBuildsReturns.result1, fake.getAllJobBuildsReturns.result2
	}
}

func (fake *FakePipelineDB) GetAllJobBuildsCallCount() int {
	fake.getAllJobBuildsMutex.RLock()
	defer fake.getAllJobBuildsMutex.RUnlock()
	return len(fake.getAllJobBuildsArgsForCall)
}

func (fake *FakePipelineDB) GetAllJobBuildsArgsForCall(i int) string {
	fake.getAllJobBuildsMutex.RLock()
	defer fake.getAllJobBuildsMutex.RUnlock()
	return fake.getAllJobBuildsArgsForCall[i].job
}

func (fake *FakePipelineDB) GetAllJobBuildsReturns(result1 []db.Build, result2 error) {
	fake.GetAllJobBuildsStub = nil
	fake.getAllJobBuildsReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetJobBuild(job string, build string) (db.Build, bool, error) {
	fake.getJobBuildMutex.Lock()
	fake.getJobBuildArgsForCall = append(fake.getJobBuildArgsForCall, struct {
		job   string
		build string
	}{job, build})
	fake.recordInvocation("GetJobBuild", []interface{}{job, build})
	fake.getJobBuildMutex.Unlock()
	if fake.GetJobBuildStub != nil {
		return fake.GetJobBuildStub(job, build)
	} else {
		return fake.getJobBuildReturns.result1, fake.getJobBuildReturns.result2, fake.getJobBuildReturns.result3
	}
}

func (fake *FakePipelineDB) GetJobBuildCallCount() int {
	fake.getJobBuildMutex.RLock()
	defer fake.getJobBuildMutex.RUnlock()
	return len(fake.getJobBuildArgsForCall)
}

func (fake *FakePipelineDB) GetJobBuildArgsForCall(i int) (string, string) {
	fake.getJobBuildMutex.RLock()
	defer fake.getJobBuildMutex.RUnlock()
	return fake.getJobBuildArgsForCall[i].job, fake.getJobBuildArgsForCall[i].build
}

func (fake *FakePipelineDB) GetJobBuildReturns(result1 db.Build, result2 bool, result3 error) {
	fake.GetJobBuildStub = nil
	fake.getJobBuildReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) CreateJobBuild(job string) (db.Build, error) {
	fake.createJobBuildMutex.Lock()
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("CreateJobBuild", []interface{}{job})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(job)
	} else {
		return fake.createJobBuildReturns.result1, fake.createJobBuildReturns.result2
	}
}

func (fake *FakePipelineDB) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakePipelineDB) CreateJobBuildArgsForCall(i int) string {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return fake.createJobBuildArgsForCall[i].job
}

func (fake *FakePipelineDB) CreateJobBuildReturns(result1 db.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) EnsurePendingBuildExists(jobName string) error {
	fake.ensurePendingBuildExistsMutex.Lock()
	fake.ensurePendingBuildExistsArgsForCall = append(fake.ensurePendingBuildExistsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("EnsurePendingBuildExists", []interface{}{jobName})
	fake.ensurePendingBuildExistsMutex.Unlock()
	if fake.EnsurePendingBuildExistsStub != nil {
		return fake.EnsurePendingBuildExistsStub(jobName)
	} else {
		return fake.ensurePendingBuildExistsReturns.result1
	}
}

func (fake *FakePipelineDB) EnsurePendingBuildExistsCallCount() int {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return len(fake.ensurePendingBuildExistsArgsForCall)
}

func (fake *FakePipelineDB) EnsurePendingBuildExistsArgsForCall(i int) string {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return fake.ensurePendingBuildExistsArgsForCall[i].jobName
}

func (fake *FakePipelineDB) EnsurePendingBuildExistsReturns(result1 error) {
	fake.EnsurePendingBuildExistsStub = nil
	fake.ensurePendingBuildExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) GetPendingBuildsForJob(jobName string) ([]db.Build, error) {
	fake.getPendingBuildsForJobMutex.Lock()
	fake.getPendingBuildsForJobArgsForCall = append(fake.getPendingBuildsForJobArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetPendingBuildsForJob", []interface{}{jobName})
	fake.getPendingBuildsForJobMutex.Unlock()
	if fake.GetPendingBuildsForJobStub != nil {
		return fake.GetPendingBuildsForJobStub(jobName)
	} else {
		return fake.getPendingBuildsForJobReturns.result1, fake.getPendingBuildsForJobReturns.result2
	}
}

func (fake *FakePipelineDB) GetPendingBuildsForJobCallCount() int {
	fake.getPendingBuildsForJobMutex.RLock()
	defer fake.getPendingBuildsForJobMutex.RUnlock()
	return len(fake.getPendingBuildsForJobArgsForCall)
}

func (fake *FakePipelineDB) GetPendingBuildsForJobArgsForCall(i int) string {
	fake.getPendingBuildsForJobMutex.RLock()
	defer fake.getPendingBuildsForJobMutex.RUnlock()
	return fake.getPendingBuildsForJobArgsForCall[i].jobName
}

func (fake *FakePipelineDB) GetPendingBuildsForJobReturns(result1 []db.Build, result2 error) {
	fake.GetPendingBuildsForJobStub = nil
	fake.getPendingBuildsForJobReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetAllPendingBuilds() (map[string][]db.Build, error) {
	fake.getAllPendingBuildsMutex.Lock()
	fake.getAllPendingBuildsArgsForCall = append(fake.getAllPendingBuildsArgsForCall, struct{}{})
	fake.recordInvocation("GetAllPendingBuilds", []interface{}{})
	fake.getAllPendingBuildsMutex.Unlock()
	if fake.GetAllPendingBuildsStub != nil {
		return fake.GetAllPendingBuildsStub()
	} else {
		return fake.getAllPendingBuildsReturns.result1, fake.getAllPendingBuildsReturns.result2
	}
}

func (fake *FakePipelineDB) GetAllPendingBuildsCallCount() int {
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	return len(fake.getAllPendingBuildsArgsForCall)
}

func (fake *FakePipelineDB) GetAllPendingBuildsReturns(result1 map[string][]db.Build, result2 error) {
	fake.GetAllPendingBuildsStub = nil
	fake.getAllPendingBuildsReturns = struct {
		result1 map[string][]db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) UseInputsForBuild(buildID int, inputs []db.BuildInput) error {
	var inputsCopy []db.BuildInput
	if inputs != nil {
		inputsCopy = make([]db.BuildInput, len(inputs))
		copy(inputsCopy, inputs)
	}
	fake.useInputsForBuildMutex.Lock()
	fake.useInputsForBuildArgsForCall = append(fake.useInputsForBuildArgsForCall, struct {
		buildID int
		inputs  []db.BuildInput
	}{buildID, inputsCopy})
	fake.recordInvocation("UseInputsForBuild", []interface{}{buildID, inputsCopy})
	fake.useInputsForBuildMutex.Unlock()
	if fake.UseInputsForBuildStub != nil {
		return fake.UseInputsForBuildStub(buildID, inputs)
	} else {
		return fake.useInputsForBuildReturns.result1
	}
}

func (fake *FakePipelineDB) UseInputsForBuildCallCount() int {
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return len(fake.useInputsForBuildArgsForCall)
}

func (fake *FakePipelineDB) UseInputsForBuildArgsForCall(i int) (int, []db.BuildInput) {
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return fake.useInputsForBuildArgsForCall[i].buildID, fake.useInputsForBuildArgsForCall[i].inputs
}

func (fake *FakePipelineDB) UseInputsForBuildReturns(result1 error) {
	fake.UseInputsForBuildStub = nil
	fake.useInputsForBuildReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) LoadVersionsDB() (*algorithm.VersionsDB, error) {
	fake.loadVersionsDBMutex.Lock()
	fake.loadVersionsDBArgsForCall = append(fake.loadVersionsDBArgsForCall, struct{}{})
	fake.recordInvocation("LoadVersionsDB", []interface{}{})
	fake.loadVersionsDBMutex.Unlock()
	if fake.LoadVersionsDBStub != nil {
		return fake.LoadVersionsDBStub()
	} else {
		return fake.loadVersionsDBReturns.result1, fake.loadVersionsDBReturns.result2
	}
}

func (fake *FakePipelineDB) LoadVersionsDBCallCount() int {
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	return len(fake.loadVersionsDBArgsForCall)
}

func (fake *FakePipelineDB) LoadVersionsDBReturns(result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	fake.loadVersionsDBReturns = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetVersionedResourceByVersion(atcVersion atc.Version, resourceName string) (db.SavedVersionedResource, bool, error) {
	fake.getVersionedResourceByVersionMutex.Lock()
	fake.getVersionedResourceByVersionArgsForCall = append(fake.getVersionedResourceByVersionArgsForCall, struct {
		atcVersion   atc.Version
		resourceName string
	}{atcVersion, resourceName})
	fake.recordInvocation("GetVersionedResourceByVersion", []interface{}{atcVersion, resourceName})
	fake.getVersionedResourceByVersionMutex.Unlock()
	if fake.GetVersionedResourceByVersionStub != nil {
		return fake.GetVersionedResourceByVersionStub(atcVersion, resourceName)
	} else {
		return fake.getVersionedResourceByVersionReturns.result1, fake.getVersionedResourceByVersionReturns.result2, fake.getVersionedResourceByVersionReturns.result3
	}
}

func (fake *FakePipelineDB) GetVersionedResourceByVersionCallCount() int {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	return len(fake.getVersionedResourceByVersionArgsForCall)
}

func (fake *FakePipelineDB) GetVersionedResourceByVersionArgsForCall(i int) (atc.Version, string) {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	return fake.getVersionedResourceByVersionArgsForCall[i].atcVersion, fake.getVersionedResourceByVersionArgsForCall[i].resourceName
}

func (fake *FakePipelineDB) GetVersionedResourceByVersionReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetVersionedResourceByVersionStub = nil
	fake.getVersionedResourceByVersionReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) SaveIndependentInputMapping(inputMapping algorithm.InputMapping, jobName string) error {
	fake.saveIndependentInputMappingMutex.Lock()
	fake.saveIndependentInputMappingArgsForCall = append(fake.saveIndependentInputMappingArgsForCall, struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}{inputMapping, jobName})
	fake.recordInvocation("SaveIndependentInputMapping", []interface{}{inputMapping, jobName})
	fake.saveIndependentInputMappingMutex.Unlock()
	if fake.SaveIndependentInputMappingStub != nil {
		return fake.SaveIndependentInputMappingStub(inputMapping, jobName)
	} else {
		return fake.saveIndependentInputMappingReturns.result1
	}
}

func (fake *FakePipelineDB) SaveIndependentInputMappingCallCount() int {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return len(fake.saveIndependentInputMappingArgsForCall)
}

func (fake *FakePipelineDB) SaveIndependentInputMappingArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return fake.saveIndependentInputMappingArgsForCall[i].inputMapping, fake.saveIndependentInputMappingArgsForCall[i].jobName
}

func (fake *FakePipelineDB) SaveIndependentInputMappingReturns(result1 error) {
	fake.SaveIndependentInputMappingStub = nil
	fake.saveIndependentInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) GetIndependentBuildInputs(jobName string) ([]db.BuildInput, error) {
	fake.getIndependentBuildInputsMutex.Lock()
	fake.getIndependentBuildInputsArgsForCall = append(fake.getIndependentBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetIndependentBuildInputs", []interface{}{jobName})
	fake.getIndependentBuildInputsMutex.Unlock()
	if fake.GetIndependentBuildInputsStub != nil {
		return fake.GetIndependentBuildInputsStub(jobName)
	} else {
		return fake.getIndependentBuildInputsReturns.result1, fake.getIndependentBuildInputsReturns.result2
	}
}

func (fake *FakePipelineDB) GetIndependentBuildInputsCallCount() int {
	fake.getIndependentBuildInputsMutex.RLock()
	defer fake.getIndependentBuildInputsMutex.RUnlock()
	return len(fake.getIndependentBuildInputsArgsForCall)
}

func (fake *FakePipelineDB) GetIndependentBuildInputsArgsForCall(i int) string {
	fake.getIndependentBuildInputsMutex.RLock()
	defer fake.getIndependentBuildInputsMutex.RUnlock()
	return fake.getIndependentBuildInputsArgsForCall[i].jobName
}

func (fake *FakePipelineDB) GetIndependentBuildInputsReturns(result1 []db.BuildInput, result2 error) {
	fake.GetIndependentBuildInputsStub = nil
	fake.getIndependentBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) SaveNextInputMapping(inputMapping algorithm.InputMapping, jobName string) error {
	fake.saveNextInputMappingMutex.Lock()
	fake.saveNextInputMappingArgsForCall = append(fake.saveNextInputMappingArgsForCall, struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}{inputMapping, jobName})
	fake.recordInvocation("SaveNextInputMapping", []interface{}{inputMapping, jobName})
	fake.saveNextInputMappingMutex.Unlock()
	if fake.SaveNextInputMappingStub != nil {
		return fake.SaveNextInputMappingStub(inputMapping, jobName)
	} else {
		return fake.saveNextInputMappingReturns.result1
	}
}

func (fake *FakePipelineDB) SaveNextInputMappingCallCount() int {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return len(fake.saveNextInputMappingArgsForCall)
}

func (fake *FakePipelineDB) SaveNextInputMappingArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return fake.saveNextInputMappingArgsForCall[i].inputMapping, fake.saveNextInputMappingArgsForCall[i].jobName
}

func (fake *FakePipelineDB) SaveNextInputMappingReturns(result1 error) {
	fake.SaveNextInputMappingStub = nil
	fake.saveNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) GetNextBuildInputs(jobName string) ([]db.BuildInput, bool, error) {
	fake.getNextBuildInputsMutex.Lock()
	fake.getNextBuildInputsArgsForCall = append(fake.getNextBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetNextBuildInputs", []interface{}{jobName})
	fake.getNextBuildInputsMutex.Unlock()
	if fake.GetNextBuildInputsStub != nil {
		return fake.GetNextBuildInputsStub(jobName)
	} else {
		return fake.getNextBuildInputsReturns.result1, fake.getNextBuildInputsReturns.result2, fake.getNextBuildInputsReturns.result3
	}
}

func (fake *FakePipelineDB) GetNextBuildInputsCallCount() int {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return len(fake.getNextBuildInputsArgsForCall)
}

func (fake *FakePipelineDB) GetNextBuildInputsArgsForCall(i int) string {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return fake.getNextBuildInputsArgsForCall[i].jobName
}

func (fake *FakePipelineDB) GetNextBuildInputsReturns(result1 []db.BuildInput, result2 bool, result3 error) {
	fake.GetNextBuildInputsStub = nil
	fake.getNextBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) DeleteNextInputMapping(jobName string) error {
	fake.deleteNextInputMappingMutex.Lock()
	fake.deleteNextInputMappingArgsForCall = append(fake.deleteNextInputMappingArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("DeleteNextInputMapping", []interface{}{jobName})
	fake.deleteNextInputMappingMutex.Unlock()
	if fake.DeleteNextInputMappingStub != nil {
		return fake.DeleteNextInputMappingStub(jobName)
	} else {
		return fake.deleteNextInputMappingReturns.result1
	}
}

func (fake *FakePipelineDB) DeleteNextInputMappingCallCount() int {
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	return len(fake.deleteNextInputMappingArgsForCall)
}

func (fake *FakePipelineDB) DeleteNextInputMappingArgsForCall(i int) string {
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	return fake.deleteNextInputMappingArgsForCall[i].jobName
}

func (fake *FakePipelineDB) DeleteNextInputMappingReturns(result1 error) {
	fake.DeleteNextInputMappingStub = nil
	fake.deleteNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) GetRunningBuildsBySerialGroup(jobName string, serialGroups []string) ([]db.Build, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getRunningBuildsBySerialGroupMutex.Lock()
	fake.getRunningBuildsBySerialGroupArgsForCall = append(fake.getRunningBuildsBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetRunningBuildsBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getRunningBuildsBySerialGroupMutex.Unlock()
	if fake.GetRunningBuildsBySerialGroupStub != nil {
		return fake.GetRunningBuildsBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getRunningBuildsBySerialGroupReturns.result1, fake.getRunningBuildsBySerialGroupReturns.result2
	}
}

func (fake *FakePipelineDB) GetRunningBuildsBySerialGroupCallCount() int {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return len(fake.getRunningBuildsBySerialGroupArgsForCall)
}

func (fake *FakePipelineDB) GetRunningBuildsBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return fake.getRunningBuildsBySerialGroupArgsForCall[i].jobName, fake.getRunningBuildsBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakePipelineDB) GetRunningBuildsBySerialGroupReturns(result1 []db.Build, result2 error) {
	fake.GetRunningBuildsBySerialGroupStub = nil
	fake.getRunningBuildsBySerialGroupReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetNextPendingBuildBySerialGroup(jobName string, serialGroups []string) (db.Build, bool, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getNextPendingBuildBySerialGroupMutex.Lock()
	fake.getNextPendingBuildBySerialGroupArgsForCall = append(fake.getNextPendingBuildBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetNextPendingBuildBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getNextPendingBuildBySerialGroupMutex.Unlock()
	if fake.GetNextPendingBuildBySerialGroupStub != nil {
		return fake.GetNextPendingBuildBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getNextPendingBuildBySerialGroupReturns.result1, fake.getNextPendingBuildBySerialGroupReturns.result2, fake.getNextPendingBuildBySerialGroupReturns.result3
	}
}

func (fake *FakePipelineDB) GetNextPendingBuildBySerialGroupCallCount() int {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return len(fake.getNextPendingBuildBySerialGroupArgsForCall)
}

func (fake *FakePipelineDB) GetNextPendingBuildBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return fake.getNextPendingBuildBySerialGroupArgsForCall[i].jobName, fake.getNextPendingBuildBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakePipelineDB) GetNextPendingBuildBySerialGroupReturns(result1 db.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildBySerialGroupStub = nil
	fake.getNextPendingBuildBySerialGroupReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) UpdateBuildToScheduled(buildID int) (bool, error) {
	fake.updateBuildToScheduledMutex.Lock()
	fake.updateBuildToScheduledArgsForCall = append(fake.updateBuildToScheduledArgsForCall, struct {
		buildID int
	}{buildID})
	fake.recordInvocation("UpdateBuildToScheduled", []interface{}{buildID})
	fake.updateBuildToScheduledMutex.Unlock()
	if fake.UpdateBuildToScheduledStub != nil {
		return fake.UpdateBuildToScheduledStub(buildID)
	} else {
		return fake.updateBuildToScheduledReturns.result1, fake.updateBuildToScheduledReturns.result2
	}
}

func (fake *FakePipelineDB) UpdateBuildToScheduledCallCount() int {
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	return len(fake.updateBuildToScheduledArgsForCall)
}

func (fake *FakePipelineDB) UpdateBuildToScheduledArgsForCall(i int) int {
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	return fake.updateBuildToScheduledArgsForCall[i].buildID
}

func (fake *FakePipelineDB) UpdateBuildToScheduledReturns(result1 bool, result2 error) {
	fake.UpdateBuildToScheduledStub = nil
	fake.updateBuildToScheduledReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) SaveInput(buildID int, input db.BuildInput) (db.SavedVersionedResource, error) {
	fake.saveInputMutex.Lock()
	fake.saveInputArgsForCall = append(fake.saveInputArgsForCall, struct {
		buildID int
		input   db.BuildInput
	}{buildID, input})
	fake.recordInvocation("SaveInput", []interface{}{buildID, input})
	fake.saveInputMutex.Unlock()
	if fake.SaveInputStub != nil {
		return fake.SaveInputStub(buildID, input)
	} else {
		return fake.saveInputReturns.result1, fake.saveInputReturns.result2
	}
}

func (fake *FakePipelineDB) SaveInputCallCount() int {
	fake.saveInputMutex.RLock()
	defer fake.saveInputMutex.RUnlock()
	return len(fake.saveInputArgsForCall)
}

func (fake *FakePipelineDB) SaveInputArgsForCall(i int) (int, db.BuildInput) {
	fake.saveInputMutex.RLock()
	defer fake.saveInputMutex.RUnlock()
	return fake.saveInputArgsForCall[i].buildID, fake.saveInputArgsForCall[i].input
}

func (fake *FakePipelineDB) SaveInputReturns(result1 db.SavedVersionedResource, result2 error) {
	fake.SaveInputStub = nil
	fake.saveInputReturns = struct {
		result1 db.SavedVersionedResource
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) SaveOutput(buildID int, vr db.VersionedResource, explicit bool) (db.SavedVersionedResource, error) {
	fake.saveOutputMutex.Lock()
	fake.saveOutputArgsForCall = append(fake.saveOutputArgsForCall, struct {
		buildID  int
		vr       db.VersionedResource
		explicit bool
	}{buildID, vr, explicit})
	fake.recordInvocation("SaveOutput", []interface{}{buildID, vr, explicit})
	fake.saveOutputMutex.Unlock()
	if fake.SaveOutputStub != nil {
		return fake.SaveOutputStub(buildID, vr, explicit)
	} else {
		return fake.saveOutputReturns.result1, fake.saveOutputReturns.result2
	}
}

func (fake *FakePipelineDB) SaveOutputCallCount() int {
	fake.saveOutputMutex.RLock()
	defer fake.saveOutputMutex.RUnlock()
	return len(fake.saveOutputArgsForCall)
}

func (fake *FakePipelineDB) SaveOutputArgsForCall(i int) (int, db.VersionedResource, bool) {
	fake.saveOutputMutex.RLock()
	defer fake.saveOutputMutex.RUnlock()
	return fake.saveOutputArgsForCall[i].buildID, fake.saveOutputArgsForCall[i].vr, fake.saveOutputArgsForCall[i].explicit
}

func (fake *FakePipelineDB) SaveOutputReturns(result1 db.SavedVersionedResource, result2 error) {
	fake.SaveOutputStub = nil
	fake.saveOutputReturns = struct {
		result1 db.SavedVersionedResource
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsInput(versionedResourceID int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	fake.getBuildsWithVersionAsInputArgsForCall = append(fake.getBuildsWithVersionAsInputArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("GetBuildsWithVersionAsInput", []interface{}{versionedResourceID})
	fake.getBuildsWithVersionAsInputMutex.Unlock()
	if fake.GetBuildsWithVersionAsInputStub != nil {
		return fake.GetBuildsWithVersionAsInputStub(versionedResourceID)
	} else {
		return fake.getBuildsWithVersionAsInputReturns.result1, fake.getBuildsWithVersionAsInputReturns.result2
	}
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsInputCallCount() int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsInputArgsForCall)
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsInputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return fake.getBuildsWithVersionAsInputArgsForCall[i].versionedResourceID
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsInputReturns(result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsInputStub = nil
	fake.getBuildsWithVersionAsInputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsOutput(versionedResourceID int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	fake.getBuildsWithVersionAsOutputArgsForCall = append(fake.getBuildsWithVersionAsOutputArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("GetBuildsWithVersionAsOutput", []interface{}{versionedResourceID})
	fake.getBuildsWithVersionAsOutputMutex.Unlock()
	if fake.GetBuildsWithVersionAsOutputStub != nil {
		return fake.GetBuildsWithVersionAsOutputStub(versionedResourceID)
	} else {
		return fake.getBuildsWithVersionAsOutputReturns.result1, fake.getBuildsWithVersionAsOutputReturns.result2
	}
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsOutputCallCount() int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsOutputArgsForCall)
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsOutputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return fake.getBuildsWithVersionAsOutputArgsForCall[i].versionedResourceID
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsOutputReturns(result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsOutputStub = nil
	fake.getBuildsWithVersionAsOutputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetDashboard() (db.Dashboard, atc.GroupConfigs, error) {
	fake.getDashboardMutex.Lock()
	fake.getDashboardArgsForCall = append(fake.getDashboardArgsForCall, struct{}{})
	fake.recordInvocation("GetDashboard", []interface{}{})
	fake.getDashboardMutex.Unlock()
	if fake.GetDashboardStub != nil {
		return fake.GetDashboardStub()
	} else {
		return fake.getDashboardReturns.result1, fake.getDashboardReturns.result2, fake.getDashboardReturns.result3
	}
}

func (fake *FakePipelineDB) GetDashboardCallCount() int {
	fake.getDashboardMutex.RLock()
	defer fake.getDashboardMutex.RUnlock()
	return len(fake.getDashboardArgsForCall)
}

func (fake *FakePipelineDB) GetDashboardReturns(result1 db.Dashboard, result2 atc.GroupConfigs, result3 error) {
	fake.GetDashboardStub = nil
	fake.getDashboardReturns = struct {
		result1 db.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) Expose() error {
	fake.exposeMutex.Lock()
	fake.exposeArgsForCall = append(fake.exposeArgsForCall, struct{}{})
	fake.recordInvocation("Expose", []interface{}{})
	fake.exposeMutex.Unlock()
	if fake.ExposeStub != nil {
		return fake.ExposeStub()
	} else {
		return fake.exposeReturns.result1
	}
}

func (fake *FakePipelineDB) ExposeCallCount() int {
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	return len(fake.exposeArgsForCall)
}

func (fake *FakePipelineDB) ExposeReturns(result1 error) {
	fake.ExposeStub = nil
	fake.exposeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) Hide() error {
	fake.hideMutex.Lock()
	fake.hideArgsForCall = append(fake.hideArgsForCall, struct{}{})
	fake.recordInvocation("Hide", []interface{}{})
	fake.hideMutex.Unlock()
	if fake.HideStub != nil {
		return fake.HideStub()
	} else {
		return fake.hideReturns.result1
	}
}

func (fake *FakePipelineDB) HideCallCount() int {
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	return len(fake.hideArgsForCall)
}

func (fake *FakePipelineDB) HideReturns(result1 error) {
	fake.HideStub = nil
	fake.hideReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	fake.getPipelineIDMutex.RLock()
	defer fake.getPipelineIDMutex.RUnlock()
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	fake.isPublicMutex.RLock()
	defer fake.isPublicMutex.RUnlock()
	fake.updateNameMutex.RLock()
	defer fake.updateNameMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	fake.getResourceMutex.RLock()
	defer fake.getResourceMutex.RUnlock()
	fake.getResourcesMutex.RLock()
	defer fake.getResourcesMutex.RUnlock()
	fake.getResourceTypeMutex.RLock()
	defer fake.getResourceTypeMutex.RUnlock()
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	fake.pauseResourceMutex.RLock()
	defer fake.pauseResourceMutex.RUnlock()
	fake.unpauseResourceMutex.RLock()
	defer fake.unpauseResourceMutex.RUnlock()
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	fake.saveResourceTypeVersionMutex.RLock()
	defer fake.saveResourceTypeVersionMutex.RUnlock()
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	fake.getLatestEnabledVersionedResourceMutex.RLock()
	defer fake.getLatestEnabledVersionedResourceMutex.RUnlock()
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	fake.acquireResourceTypeCheckingLockMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockMutex.RUnlock()
	fake.getJobsMutex.RLock()
	defer fake.getJobsMutex.RUnlock()
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	fake.getJobFinishedAndNextBuildMutex.RLock()
	defer fake.getJobFinishedAndNextBuildMutex.RUnlock()
	fake.getJobBuildsMutex.RLock()
	defer fake.getJobBuildsMutex.RUnlock()
	fake.getAllJobBuildsMutex.RLock()
	defer fake.getAllJobBuildsMutex.RUnlock()
	fake.getJobBuildMutex.RLock()
	defer fake.getJobBuildMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	fake.getPendingBuildsForJobMutex.RLock()
	defer fake.getPendingBuildsForJobMutex.RUnlock()
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	fake.getIndependentBuildInputsMutex.RLock()
	defer fake.getIndependentBuildInputsMutex.RUnlock()
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	fake.saveInputMutex.RLock()
	defer fake.saveInputMutex.RUnlock()
	fake.saveOutputMutex.RLock()
	defer fake.saveOutputMutex.RUnlock()
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	fake.getDashboardMutex.RLock()
	defer fake.getDashboardMutex.RUnlock()
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePipelineDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.PipelineDB = new(FakePipelineDB)
