// Code generated by counterfeiter. DO NOT EDIT.
package concoursefakes

import (
	"sync"

	"github.com/concourse/atc"
	"github.com/concourse/go-concourse/concourse"
	"github.com/concourse/skymarshal/provider"
)

type FakeTeam struct {
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ListAuthMethodsStub        func() ([]provider.AuthMethod, error)
	listAuthMethodsMutex       sync.RWMutex
	listAuthMethodsArgsForCall []struct{}
	listAuthMethodsReturns     struct {
		result1 []provider.AuthMethod
		result2 error
	}
	listAuthMethodsReturnsOnCall map[int]struct {
		result1 []provider.AuthMethod
		result2 error
	}
	AuthTokenStub        func() (provider.AuthToken, error)
	authTokenMutex       sync.RWMutex
	authTokenArgsForCall []struct{}
	authTokenReturns     struct {
		result1 provider.AuthToken
		result2 error
	}
	authTokenReturnsOnCall map[int]struct {
		result1 provider.AuthToken
		result2 error
	}
	CreateOrUpdateStub        func(team atc.Team) (atc.Team, bool, bool, error)
	createOrUpdateMutex       sync.RWMutex
	createOrUpdateArgsForCall []struct {
		team atc.Team
	}
	createOrUpdateReturns struct {
		result1 atc.Team
		result2 bool
		result3 bool
		result4 error
	}
	createOrUpdateReturnsOnCall map[int]struct {
		result1 atc.Team
		result2 bool
		result3 bool
		result4 error
	}
	RenameTeamStub        func(teamName, name string) (bool, error)
	renameTeamMutex       sync.RWMutex
	renameTeamArgsForCall []struct {
		teamName string
		name     string
	}
	renameTeamReturns struct {
		result1 bool
		result2 error
	}
	renameTeamReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DestroyTeamStub        func(teamName string) error
	destroyTeamMutex       sync.RWMutex
	destroyTeamArgsForCall []struct {
		teamName string
	}
	destroyTeamReturns struct {
		result1 error
	}
	destroyTeamReturnsOnCall map[int]struct {
		result1 error
	}
	PipelineStub        func(name string) (atc.Pipeline, bool, error)
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct {
		name string
	}
	pipelineReturns struct {
		result1 atc.Pipeline
		result2 bool
		result3 error
	}
	pipelineReturnsOnCall map[int]struct {
		result1 atc.Pipeline
		result2 bool
		result3 error
	}
	DeletePipelineStub        func(pipelineName string) (bool, error)
	deletePipelineMutex       sync.RWMutex
	deletePipelineArgsForCall []struct {
		pipelineName string
	}
	deletePipelineReturns struct {
		result1 bool
		result2 error
	}
	deletePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PausePipelineStub        func(pipelineName string) (bool, error)
	pausePipelineMutex       sync.RWMutex
	pausePipelineArgsForCall []struct {
		pipelineName string
	}
	pausePipelineReturns struct {
		result1 bool
		result2 error
	}
	pausePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UnpausePipelineStub        func(pipelineName string) (bool, error)
	unpausePipelineMutex       sync.RWMutex
	unpausePipelineArgsForCall []struct {
		pipelineName string
	}
	unpausePipelineReturns struct {
		result1 bool
		result2 error
	}
	unpausePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ExposePipelineStub        func(pipelineName string) (bool, error)
	exposePipelineMutex       sync.RWMutex
	exposePipelineArgsForCall []struct {
		pipelineName string
	}
	exposePipelineReturns struct {
		result1 bool
		result2 error
	}
	exposePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	HidePipelineStub        func(pipelineName string) (bool, error)
	hidePipelineMutex       sync.RWMutex
	hidePipelineArgsForCall []struct {
		pipelineName string
	}
	hidePipelineReturns struct {
		result1 bool
		result2 error
	}
	hidePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RenamePipelineStub        func(pipelineName, name string) (bool, error)
	renamePipelineMutex       sync.RWMutex
	renamePipelineArgsForCall []struct {
		pipelineName string
		name         string
	}
	renamePipelineReturns struct {
		result1 bool
		result2 error
	}
	renamePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PauseResourceStub        func(pipelineName string, resourceName string) (bool, error)
	pauseResourceMutex       sync.RWMutex
	pauseResourceArgsForCall []struct {
		pipelineName string
		resourceName string
	}
	pauseResourceReturns struct {
		result1 bool
		result2 error
	}
	pauseResourceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UnpauseResourceStub        func(pipelineName string, resourceName string) (bool, error)
	unpauseResourceMutex       sync.RWMutex
	unpauseResourceArgsForCall []struct {
		pipelineName string
		resourceName string
	}
	unpauseResourceReturns struct {
		result1 bool
		result2 error
	}
	unpauseResourceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ListPipelinesStub        func() ([]atc.Pipeline, error)
	listPipelinesMutex       sync.RWMutex
	listPipelinesArgsForCall []struct{}
	listPipelinesReturns     struct {
		result1 []atc.Pipeline
		result2 error
	}
	listPipelinesReturnsOnCall map[int]struct {
		result1 []atc.Pipeline
		result2 error
	}
	PipelineConfigStub        func(pipelineName string) (atc.Config, atc.RawConfig, string, bool, error)
	pipelineConfigMutex       sync.RWMutex
	pipelineConfigArgsForCall []struct {
		pipelineName string
	}
	pipelineConfigReturns struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}
	pipelineConfigReturnsOnCall map[int]struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}
	CreateOrUpdatePipelineConfigStub        func(pipelineName string, configVersion string, passedConfig []byte) (bool, bool, []concourse.ConfigWarning, error)
	createOrUpdatePipelineConfigMutex       sync.RWMutex
	createOrUpdatePipelineConfigArgsForCall []struct {
		pipelineName  string
		configVersion string
		passedConfig  []byte
	}
	createOrUpdatePipelineConfigReturns struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}
	createOrUpdatePipelineConfigReturnsOnCall map[int]struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}
	CreatePipelineBuildStub        func(pipelineName string, plan atc.Plan) (atc.Build, error)
	createPipelineBuildMutex       sync.RWMutex
	createPipelineBuildArgsForCall []struct {
		pipelineName string
		plan         atc.Plan
	}
	createPipelineBuildReturns struct {
		result1 atc.Build
		result2 error
	}
	createPipelineBuildReturnsOnCall map[int]struct {
		result1 atc.Build
		result2 error
	}
	BuildInputsForJobStub        func(pipelineName string, jobName string) ([]atc.BuildInput, bool, error)
	buildInputsForJobMutex       sync.RWMutex
	buildInputsForJobArgsForCall []struct {
		pipelineName string
		jobName      string
	}
	buildInputsForJobReturns struct {
		result1 []atc.BuildInput
		result2 bool
		result3 error
	}
	buildInputsForJobReturnsOnCall map[int]struct {
		result1 []atc.BuildInput
		result2 bool
		result3 error
	}
	JobStub        func(pipelineName, jobName string) (atc.Job, bool, error)
	jobMutex       sync.RWMutex
	jobArgsForCall []struct {
		pipelineName string
		jobName      string
	}
	jobReturns struct {
		result1 atc.Job
		result2 bool
		result3 error
	}
	jobReturnsOnCall map[int]struct {
		result1 atc.Job
		result2 bool
		result3 error
	}
	JobBuildStub        func(pipelineName, jobName, buildName string) (atc.Build, bool, error)
	jobBuildMutex       sync.RWMutex
	jobBuildArgsForCall []struct {
		pipelineName string
		jobName      string
		buildName    string
	}
	jobBuildReturns struct {
		result1 atc.Build
		result2 bool
		result3 error
	}
	jobBuildReturnsOnCall map[int]struct {
		result1 atc.Build
		result2 bool
		result3 error
	}
	JobBuildsStub        func(pipelineName string, jobName string, page concourse.Page) ([]atc.Build, concourse.Pagination, bool, error)
	jobBuildsMutex       sync.RWMutex
	jobBuildsArgsForCall []struct {
		pipelineName string
		jobName      string
		page         concourse.Page
	}
	jobBuildsReturns struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	jobBuildsReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	CreateJobBuildStub        func(pipelineName string, jobName string) (atc.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		pipelineName string
		jobName      string
	}
	createJobBuildReturns struct {
		result1 atc.Build
		result2 error
	}
	createJobBuildReturnsOnCall map[int]struct {
		result1 atc.Build
		result2 error
	}
	ListJobsStub        func(pipelineName string) ([]atc.Job, error)
	listJobsMutex       sync.RWMutex
	listJobsArgsForCall []struct {
		pipelineName string
	}
	listJobsReturns struct {
		result1 []atc.Job
		result2 error
	}
	listJobsReturnsOnCall map[int]struct {
		result1 []atc.Job
		result2 error
	}
	PauseJobStub        func(pipelineName string, jobName string) (bool, error)
	pauseJobMutex       sync.RWMutex
	pauseJobArgsForCall []struct {
		pipelineName string
		jobName      string
	}
	pauseJobReturns struct {
		result1 bool
		result2 error
	}
	pauseJobReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UnpauseJobStub        func(pipelineName string, jobName string) (bool, error)
	unpauseJobMutex       sync.RWMutex
	unpauseJobArgsForCall []struct {
		pipelineName string
		jobName      string
	}
	unpauseJobReturns struct {
		result1 bool
		result2 error
	}
	unpauseJobReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ResourceStub        func(pipelineName string, resourceName string) (atc.Resource, bool, error)
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
		pipelineName string
		resourceName string
	}
	resourceReturns struct {
		result1 atc.Resource
		result2 bool
		result3 error
	}
	resourceReturnsOnCall map[int]struct {
		result1 atc.Resource
		result2 bool
		result3 error
	}
	ResourceVersionsStub        func(pipelineName string, resourceName string, page concourse.Page) ([]atc.VersionedResource, concourse.Pagination, bool, error)
	resourceVersionsMutex       sync.RWMutex
	resourceVersionsArgsForCall []struct {
		pipelineName string
		resourceName string
		page         concourse.Page
	}
	resourceVersionsReturns struct {
		result1 []atc.VersionedResource
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	resourceVersionsReturnsOnCall map[int]struct {
		result1 []atc.VersionedResource
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	CheckResourceStub        func(pipelineName string, resourceName string, version atc.Version) (bool, error)
	checkResourceMutex       sync.RWMutex
	checkResourceArgsForCall []struct {
		pipelineName string
		resourceName string
		version      atc.Version
	}
	checkResourceReturns struct {
		result1 bool
		result2 error
	}
	checkResourceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	BuildsWithVersionAsInputStub        func(pipelineName string, resourceName string, resourceVersionID int) ([]atc.Build, bool, error)
	buildsWithVersionAsInputMutex       sync.RWMutex
	buildsWithVersionAsInputArgsForCall []struct {
		pipelineName      string
		resourceName      string
		resourceVersionID int
	}
	buildsWithVersionAsInputReturns struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}
	buildsWithVersionAsInputReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}
	BuildsWithVersionAsOutputStub        func(pipelineName string, resourceName string, resourceVersionID int) ([]atc.Build, bool, error)
	buildsWithVersionAsOutputMutex       sync.RWMutex
	buildsWithVersionAsOutputArgsForCall []struct {
		pipelineName      string
		resourceName      string
		resourceVersionID int
	}
	buildsWithVersionAsOutputReturns struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}
	buildsWithVersionAsOutputReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTeam) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakeTeam) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeTeam) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeam) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeam) ListAuthMethods() ([]provider.AuthMethod, error) {
	fake.listAuthMethodsMutex.Lock()
	ret, specificReturn := fake.listAuthMethodsReturnsOnCall[len(fake.listAuthMethodsArgsForCall)]
	fake.listAuthMethodsArgsForCall = append(fake.listAuthMethodsArgsForCall, struct{}{})
	fake.recordInvocation("ListAuthMethods", []interface{}{})
	fake.listAuthMethodsMutex.Unlock()
	if fake.ListAuthMethodsStub != nil {
		return fake.ListAuthMethodsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listAuthMethodsReturns.result1, fake.listAuthMethodsReturns.result2
}

func (fake *FakeTeam) ListAuthMethodsCallCount() int {
	fake.listAuthMethodsMutex.RLock()
	defer fake.listAuthMethodsMutex.RUnlock()
	return len(fake.listAuthMethodsArgsForCall)
}

func (fake *FakeTeam) ListAuthMethodsReturns(result1 []provider.AuthMethod, result2 error) {
	fake.ListAuthMethodsStub = nil
	fake.listAuthMethodsReturns = struct {
		result1 []provider.AuthMethod
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListAuthMethodsReturnsOnCall(i int, result1 []provider.AuthMethod, result2 error) {
	fake.ListAuthMethodsStub = nil
	if fake.listAuthMethodsReturnsOnCall == nil {
		fake.listAuthMethodsReturnsOnCall = make(map[int]struct {
			result1 []provider.AuthMethod
			result2 error
		})
	}
	fake.listAuthMethodsReturnsOnCall[i] = struct {
		result1 []provider.AuthMethod
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) AuthToken() (provider.AuthToken, error) {
	fake.authTokenMutex.Lock()
	ret, specificReturn := fake.authTokenReturnsOnCall[len(fake.authTokenArgsForCall)]
	fake.authTokenArgsForCall = append(fake.authTokenArgsForCall, struct{}{})
	fake.recordInvocation("AuthToken", []interface{}{})
	fake.authTokenMutex.Unlock()
	if fake.AuthTokenStub != nil {
		return fake.AuthTokenStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.authTokenReturns.result1, fake.authTokenReturns.result2
}

func (fake *FakeTeam) AuthTokenCallCount() int {
	fake.authTokenMutex.RLock()
	defer fake.authTokenMutex.RUnlock()
	return len(fake.authTokenArgsForCall)
}

func (fake *FakeTeam) AuthTokenReturns(result1 provider.AuthToken, result2 error) {
	fake.AuthTokenStub = nil
	fake.authTokenReturns = struct {
		result1 provider.AuthToken
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) AuthTokenReturnsOnCall(i int, result1 provider.AuthToken, result2 error) {
	fake.AuthTokenStub = nil
	if fake.authTokenReturnsOnCall == nil {
		fake.authTokenReturnsOnCall = make(map[int]struct {
			result1 provider.AuthToken
			result2 error
		})
	}
	fake.authTokenReturnsOnCall[i] = struct {
		result1 provider.AuthToken
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateOrUpdate(team atc.Team) (atc.Team, bool, bool, error) {
	fake.createOrUpdateMutex.Lock()
	ret, specificReturn := fake.createOrUpdateReturnsOnCall[len(fake.createOrUpdateArgsForCall)]
	fake.createOrUpdateArgsForCall = append(fake.createOrUpdateArgsForCall, struct {
		team atc.Team
	}{team})
	fake.recordInvocation("CreateOrUpdate", []interface{}{team})
	fake.createOrUpdateMutex.Unlock()
	if fake.CreateOrUpdateStub != nil {
		return fake.CreateOrUpdateStub(team)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.createOrUpdateReturns.result1, fake.createOrUpdateReturns.result2, fake.createOrUpdateReturns.result3, fake.createOrUpdateReturns.result4
}

func (fake *FakeTeam) CreateOrUpdateCallCount() int {
	fake.createOrUpdateMutex.RLock()
	defer fake.createOrUpdateMutex.RUnlock()
	return len(fake.createOrUpdateArgsForCall)
}

func (fake *FakeTeam) CreateOrUpdateArgsForCall(i int) atc.Team {
	fake.createOrUpdateMutex.RLock()
	defer fake.createOrUpdateMutex.RUnlock()
	return fake.createOrUpdateArgsForCall[i].team
}

func (fake *FakeTeam) CreateOrUpdateReturns(result1 atc.Team, result2 bool, result3 bool, result4 error) {
	fake.CreateOrUpdateStub = nil
	fake.createOrUpdateReturns = struct {
		result1 atc.Team
		result2 bool
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) CreateOrUpdateReturnsOnCall(i int, result1 atc.Team, result2 bool, result3 bool, result4 error) {
	fake.CreateOrUpdateStub = nil
	if fake.createOrUpdateReturnsOnCall == nil {
		fake.createOrUpdateReturnsOnCall = make(map[int]struct {
			result1 atc.Team
			result2 bool
			result3 bool
			result4 error
		})
	}
	fake.createOrUpdateReturnsOnCall[i] = struct {
		result1 atc.Team
		result2 bool
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) RenameTeam(teamName string, name string) (bool, error) {
	fake.renameTeamMutex.Lock()
	ret, specificReturn := fake.renameTeamReturnsOnCall[len(fake.renameTeamArgsForCall)]
	fake.renameTeamArgsForCall = append(fake.renameTeamArgsForCall, struct {
		teamName string
		name     string
	}{teamName, name})
	fake.recordInvocation("RenameTeam", []interface{}{teamName, name})
	fake.renameTeamMutex.Unlock()
	if fake.RenameTeamStub != nil {
		return fake.RenameTeamStub(teamName, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.renameTeamReturns.result1, fake.renameTeamReturns.result2
}

func (fake *FakeTeam) RenameTeamCallCount() int {
	fake.renameTeamMutex.RLock()
	defer fake.renameTeamMutex.RUnlock()
	return len(fake.renameTeamArgsForCall)
}

func (fake *FakeTeam) RenameTeamArgsForCall(i int) (string, string) {
	fake.renameTeamMutex.RLock()
	defer fake.renameTeamMutex.RUnlock()
	return fake.renameTeamArgsForCall[i].teamName, fake.renameTeamArgsForCall[i].name
}

func (fake *FakeTeam) RenameTeamReturns(result1 bool, result2 error) {
	fake.RenameTeamStub = nil
	fake.renameTeamReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) RenameTeamReturnsOnCall(i int, result1 bool, result2 error) {
	fake.RenameTeamStub = nil
	if fake.renameTeamReturnsOnCall == nil {
		fake.renameTeamReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.renameTeamReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) DestroyTeam(teamName string) error {
	fake.destroyTeamMutex.Lock()
	ret, specificReturn := fake.destroyTeamReturnsOnCall[len(fake.destroyTeamArgsForCall)]
	fake.destroyTeamArgsForCall = append(fake.destroyTeamArgsForCall, struct {
		teamName string
	}{teamName})
	fake.recordInvocation("DestroyTeam", []interface{}{teamName})
	fake.destroyTeamMutex.Unlock()
	if fake.DestroyTeamStub != nil {
		return fake.DestroyTeamStub(teamName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyTeamReturns.result1
}

func (fake *FakeTeam) DestroyTeamCallCount() int {
	fake.destroyTeamMutex.RLock()
	defer fake.destroyTeamMutex.RUnlock()
	return len(fake.destroyTeamArgsForCall)
}

func (fake *FakeTeam) DestroyTeamArgsForCall(i int) string {
	fake.destroyTeamMutex.RLock()
	defer fake.destroyTeamMutex.RUnlock()
	return fake.destroyTeamArgsForCall[i].teamName
}

func (fake *FakeTeam) DestroyTeamReturns(result1 error) {
	fake.DestroyTeamStub = nil
	fake.destroyTeamReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) DestroyTeamReturnsOnCall(i int, result1 error) {
	fake.DestroyTeamStub = nil
	if fake.destroyTeamReturnsOnCall == nil {
		fake.destroyTeamReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyTeamReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) Pipeline(name string) (atc.Pipeline, bool, error) {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Pipeline", []interface{}{name})
	fake.pipelineMutex.Unlock()
	if fake.PipelineStub != nil {
		return fake.PipelineStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.pipelineReturns.result1, fake.pipelineReturns.result2, fake.pipelineReturns.result3
}

func (fake *FakeTeam) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeTeam) PipelineArgsForCall(i int) string {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return fake.pipelineArgsForCall[i].name
}

func (fake *FakeTeam) PipelineReturns(result1 atc.Pipeline, result2 bool, result3 error) {
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 atc.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) PipelineReturnsOnCall(i int, result1 atc.Pipeline, result2 bool, result3 error) {
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 atc.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 atc.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) DeletePipeline(pipelineName string) (bool, error) {
	fake.deletePipelineMutex.Lock()
	ret, specificReturn := fake.deletePipelineReturnsOnCall[len(fake.deletePipelineArgsForCall)]
	fake.deletePipelineArgsForCall = append(fake.deletePipelineArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("DeletePipeline", []interface{}{pipelineName})
	fake.deletePipelineMutex.Unlock()
	if fake.DeletePipelineStub != nil {
		return fake.DeletePipelineStub(pipelineName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deletePipelineReturns.result1, fake.deletePipelineReturns.result2
}

func (fake *FakeTeam) DeletePipelineCallCount() int {
	fake.deletePipelineMutex.RLock()
	defer fake.deletePipelineMutex.RUnlock()
	return len(fake.deletePipelineArgsForCall)
}

func (fake *FakeTeam) DeletePipelineArgsForCall(i int) string {
	fake.deletePipelineMutex.RLock()
	defer fake.deletePipelineMutex.RUnlock()
	return fake.deletePipelineArgsForCall[i].pipelineName
}

func (fake *FakeTeam) DeletePipelineReturns(result1 bool, result2 error) {
	fake.DeletePipelineStub = nil
	fake.deletePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) DeletePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeletePipelineStub = nil
	if fake.deletePipelineReturnsOnCall == nil {
		fake.deletePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deletePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PausePipeline(pipelineName string) (bool, error) {
	fake.pausePipelineMutex.Lock()
	ret, specificReturn := fake.pausePipelineReturnsOnCall[len(fake.pausePipelineArgsForCall)]
	fake.pausePipelineArgsForCall = append(fake.pausePipelineArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("PausePipeline", []interface{}{pipelineName})
	fake.pausePipelineMutex.Unlock()
	if fake.PausePipelineStub != nil {
		return fake.PausePipelineStub(pipelineName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pausePipelineReturns.result1, fake.pausePipelineReturns.result2
}

func (fake *FakeTeam) PausePipelineCallCount() int {
	fake.pausePipelineMutex.RLock()
	defer fake.pausePipelineMutex.RUnlock()
	return len(fake.pausePipelineArgsForCall)
}

func (fake *FakeTeam) PausePipelineArgsForCall(i int) string {
	fake.pausePipelineMutex.RLock()
	defer fake.pausePipelineMutex.RUnlock()
	return fake.pausePipelineArgsForCall[i].pipelineName
}

func (fake *FakeTeam) PausePipelineReturns(result1 bool, result2 error) {
	fake.PausePipelineStub = nil
	fake.pausePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PausePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.PausePipelineStub = nil
	if fake.pausePipelineReturnsOnCall == nil {
		fake.pausePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pausePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpausePipeline(pipelineName string) (bool, error) {
	fake.unpausePipelineMutex.Lock()
	ret, specificReturn := fake.unpausePipelineReturnsOnCall[len(fake.unpausePipelineArgsForCall)]
	fake.unpausePipelineArgsForCall = append(fake.unpausePipelineArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("UnpausePipeline", []interface{}{pipelineName})
	fake.unpausePipelineMutex.Unlock()
	if fake.UnpausePipelineStub != nil {
		return fake.UnpausePipelineStub(pipelineName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.unpausePipelineReturns.result1, fake.unpausePipelineReturns.result2
}

func (fake *FakeTeam) UnpausePipelineCallCount() int {
	fake.unpausePipelineMutex.RLock()
	defer fake.unpausePipelineMutex.RUnlock()
	return len(fake.unpausePipelineArgsForCall)
}

func (fake *FakeTeam) UnpausePipelineArgsForCall(i int) string {
	fake.unpausePipelineMutex.RLock()
	defer fake.unpausePipelineMutex.RUnlock()
	return fake.unpausePipelineArgsForCall[i].pipelineName
}

func (fake *FakeTeam) UnpausePipelineReturns(result1 bool, result2 error) {
	fake.UnpausePipelineStub = nil
	fake.unpausePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpausePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.UnpausePipelineStub = nil
	if fake.unpausePipelineReturnsOnCall == nil {
		fake.unpausePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unpausePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ExposePipeline(pipelineName string) (bool, error) {
	fake.exposePipelineMutex.Lock()
	ret, specificReturn := fake.exposePipelineReturnsOnCall[len(fake.exposePipelineArgsForCall)]
	fake.exposePipelineArgsForCall = append(fake.exposePipelineArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("ExposePipeline", []interface{}{pipelineName})
	fake.exposePipelineMutex.Unlock()
	if fake.ExposePipelineStub != nil {
		return fake.ExposePipelineStub(pipelineName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.exposePipelineReturns.result1, fake.exposePipelineReturns.result2
}

func (fake *FakeTeam) ExposePipelineCallCount() int {
	fake.exposePipelineMutex.RLock()
	defer fake.exposePipelineMutex.RUnlock()
	return len(fake.exposePipelineArgsForCall)
}

func (fake *FakeTeam) ExposePipelineArgsForCall(i int) string {
	fake.exposePipelineMutex.RLock()
	defer fake.exposePipelineMutex.RUnlock()
	return fake.exposePipelineArgsForCall[i].pipelineName
}

func (fake *FakeTeam) ExposePipelineReturns(result1 bool, result2 error) {
	fake.ExposePipelineStub = nil
	fake.exposePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ExposePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ExposePipelineStub = nil
	if fake.exposePipelineReturnsOnCall == nil {
		fake.exposePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.exposePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) HidePipeline(pipelineName string) (bool, error) {
	fake.hidePipelineMutex.Lock()
	ret, specificReturn := fake.hidePipelineReturnsOnCall[len(fake.hidePipelineArgsForCall)]
	fake.hidePipelineArgsForCall = append(fake.hidePipelineArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("HidePipeline", []interface{}{pipelineName})
	fake.hidePipelineMutex.Unlock()
	if fake.HidePipelineStub != nil {
		return fake.HidePipelineStub(pipelineName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hidePipelineReturns.result1, fake.hidePipelineReturns.result2
}

func (fake *FakeTeam) HidePipelineCallCount() int {
	fake.hidePipelineMutex.RLock()
	defer fake.hidePipelineMutex.RUnlock()
	return len(fake.hidePipelineArgsForCall)
}

func (fake *FakeTeam) HidePipelineArgsForCall(i int) string {
	fake.hidePipelineMutex.RLock()
	defer fake.hidePipelineMutex.RUnlock()
	return fake.hidePipelineArgsForCall[i].pipelineName
}

func (fake *FakeTeam) HidePipelineReturns(result1 bool, result2 error) {
	fake.HidePipelineStub = nil
	fake.hidePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) HidePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.HidePipelineStub = nil
	if fake.hidePipelineReturnsOnCall == nil {
		fake.hidePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hidePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) RenamePipeline(pipelineName string, name string) (bool, error) {
	fake.renamePipelineMutex.Lock()
	ret, specificReturn := fake.renamePipelineReturnsOnCall[len(fake.renamePipelineArgsForCall)]
	fake.renamePipelineArgsForCall = append(fake.renamePipelineArgsForCall, struct {
		pipelineName string
		name         string
	}{pipelineName, name})
	fake.recordInvocation("RenamePipeline", []interface{}{pipelineName, name})
	fake.renamePipelineMutex.Unlock()
	if fake.RenamePipelineStub != nil {
		return fake.RenamePipelineStub(pipelineName, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.renamePipelineReturns.result1, fake.renamePipelineReturns.result2
}

func (fake *FakeTeam) RenamePipelineCallCount() int {
	fake.renamePipelineMutex.RLock()
	defer fake.renamePipelineMutex.RUnlock()
	return len(fake.renamePipelineArgsForCall)
}

func (fake *FakeTeam) RenamePipelineArgsForCall(i int) (string, string) {
	fake.renamePipelineMutex.RLock()
	defer fake.renamePipelineMutex.RUnlock()
	return fake.renamePipelineArgsForCall[i].pipelineName, fake.renamePipelineArgsForCall[i].name
}

func (fake *FakeTeam) RenamePipelineReturns(result1 bool, result2 error) {
	fake.RenamePipelineStub = nil
	fake.renamePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) RenamePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.RenamePipelineStub = nil
	if fake.renamePipelineReturnsOnCall == nil {
		fake.renamePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.renamePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PauseResource(pipelineName string, resourceName string) (bool, error) {
	fake.pauseResourceMutex.Lock()
	ret, specificReturn := fake.pauseResourceReturnsOnCall[len(fake.pauseResourceArgsForCall)]
	fake.pauseResourceArgsForCall = append(fake.pauseResourceArgsForCall, struct {
		pipelineName string
		resourceName string
	}{pipelineName, resourceName})
	fake.recordInvocation("PauseResource", []interface{}{pipelineName, resourceName})
	fake.pauseResourceMutex.Unlock()
	if fake.PauseResourceStub != nil {
		return fake.PauseResourceStub(pipelineName, resourceName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pauseResourceReturns.result1, fake.pauseResourceReturns.result2
}

func (fake *FakeTeam) PauseResourceCallCount() int {
	fake.pauseResourceMutex.RLock()
	defer fake.pauseResourceMutex.RUnlock()
	return len(fake.pauseResourceArgsForCall)
}

func (fake *FakeTeam) PauseResourceArgsForCall(i int) (string, string) {
	fake.pauseResourceMutex.RLock()
	defer fake.pauseResourceMutex.RUnlock()
	return fake.pauseResourceArgsForCall[i].pipelineName, fake.pauseResourceArgsForCall[i].resourceName
}

func (fake *FakeTeam) PauseResourceReturns(result1 bool, result2 error) {
	fake.PauseResourceStub = nil
	fake.pauseResourceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PauseResourceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.PauseResourceStub = nil
	if fake.pauseResourceReturnsOnCall == nil {
		fake.pauseResourceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pauseResourceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpauseResource(pipelineName string, resourceName string) (bool, error) {
	fake.unpauseResourceMutex.Lock()
	ret, specificReturn := fake.unpauseResourceReturnsOnCall[len(fake.unpauseResourceArgsForCall)]
	fake.unpauseResourceArgsForCall = append(fake.unpauseResourceArgsForCall, struct {
		pipelineName string
		resourceName string
	}{pipelineName, resourceName})
	fake.recordInvocation("UnpauseResource", []interface{}{pipelineName, resourceName})
	fake.unpauseResourceMutex.Unlock()
	if fake.UnpauseResourceStub != nil {
		return fake.UnpauseResourceStub(pipelineName, resourceName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.unpauseResourceReturns.result1, fake.unpauseResourceReturns.result2
}

func (fake *FakeTeam) UnpauseResourceCallCount() int {
	fake.unpauseResourceMutex.RLock()
	defer fake.unpauseResourceMutex.RUnlock()
	return len(fake.unpauseResourceArgsForCall)
}

func (fake *FakeTeam) UnpauseResourceArgsForCall(i int) (string, string) {
	fake.unpauseResourceMutex.RLock()
	defer fake.unpauseResourceMutex.RUnlock()
	return fake.unpauseResourceArgsForCall[i].pipelineName, fake.unpauseResourceArgsForCall[i].resourceName
}

func (fake *FakeTeam) UnpauseResourceReturns(result1 bool, result2 error) {
	fake.UnpauseResourceStub = nil
	fake.unpauseResourceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpauseResourceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.UnpauseResourceStub = nil
	if fake.unpauseResourceReturnsOnCall == nil {
		fake.unpauseResourceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unpauseResourceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListPipelines() ([]atc.Pipeline, error) {
	fake.listPipelinesMutex.Lock()
	ret, specificReturn := fake.listPipelinesReturnsOnCall[len(fake.listPipelinesArgsForCall)]
	fake.listPipelinesArgsForCall = append(fake.listPipelinesArgsForCall, struct{}{})
	fake.recordInvocation("ListPipelines", []interface{}{})
	fake.listPipelinesMutex.Unlock()
	if fake.ListPipelinesStub != nil {
		return fake.ListPipelinesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listPipelinesReturns.result1, fake.listPipelinesReturns.result2
}

func (fake *FakeTeam) ListPipelinesCallCount() int {
	fake.listPipelinesMutex.RLock()
	defer fake.listPipelinesMutex.RUnlock()
	return len(fake.listPipelinesArgsForCall)
}

func (fake *FakeTeam) ListPipelinesReturns(result1 []atc.Pipeline, result2 error) {
	fake.ListPipelinesStub = nil
	fake.listPipelinesReturns = struct {
		result1 []atc.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListPipelinesReturnsOnCall(i int, result1 []atc.Pipeline, result2 error) {
	fake.ListPipelinesStub = nil
	if fake.listPipelinesReturnsOnCall == nil {
		fake.listPipelinesReturnsOnCall = make(map[int]struct {
			result1 []atc.Pipeline
			result2 error
		})
	}
	fake.listPipelinesReturnsOnCall[i] = struct {
		result1 []atc.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PipelineConfig(pipelineName string) (atc.Config, atc.RawConfig, string, bool, error) {
	fake.pipelineConfigMutex.Lock()
	ret, specificReturn := fake.pipelineConfigReturnsOnCall[len(fake.pipelineConfigArgsForCall)]
	fake.pipelineConfigArgsForCall = append(fake.pipelineConfigArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("PipelineConfig", []interface{}{pipelineName})
	fake.pipelineConfigMutex.Unlock()
	if fake.PipelineConfigStub != nil {
		return fake.PipelineConfigStub(pipelineName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4, ret.result5
	}
	return fake.pipelineConfigReturns.result1, fake.pipelineConfigReturns.result2, fake.pipelineConfigReturns.result3, fake.pipelineConfigReturns.result4, fake.pipelineConfigReturns.result5
}

func (fake *FakeTeam) PipelineConfigCallCount() int {
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	return len(fake.pipelineConfigArgsForCall)
}

func (fake *FakeTeam) PipelineConfigArgsForCall(i int) string {
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	return fake.pipelineConfigArgsForCall[i].pipelineName
}

func (fake *FakeTeam) PipelineConfigReturns(result1 atc.Config, result2 atc.RawConfig, result3 string, result4 bool, result5 error) {
	fake.PipelineConfigStub = nil
	fake.pipelineConfigReturns = struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeTeam) PipelineConfigReturnsOnCall(i int, result1 atc.Config, result2 atc.RawConfig, result3 string, result4 bool, result5 error) {
	fake.PipelineConfigStub = nil
	if fake.pipelineConfigReturnsOnCall == nil {
		fake.pipelineConfigReturnsOnCall = make(map[int]struct {
			result1 atc.Config
			result2 atc.RawConfig
			result3 string
			result4 bool
			result5 error
		})
	}
	fake.pipelineConfigReturnsOnCall[i] = struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 string
		result4 bool
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfig(pipelineName string, configVersion string, passedConfig []byte) (bool, bool, []concourse.ConfigWarning, error) {
	var passedConfigCopy []byte
	if passedConfig != nil {
		passedConfigCopy = make([]byte, len(passedConfig))
		copy(passedConfigCopy, passedConfig)
	}
	fake.createOrUpdatePipelineConfigMutex.Lock()
	ret, specificReturn := fake.createOrUpdatePipelineConfigReturnsOnCall[len(fake.createOrUpdatePipelineConfigArgsForCall)]
	fake.createOrUpdatePipelineConfigArgsForCall = append(fake.createOrUpdatePipelineConfigArgsForCall, struct {
		pipelineName  string
		configVersion string
		passedConfig  []byte
	}{pipelineName, configVersion, passedConfigCopy})
	fake.recordInvocation("CreateOrUpdatePipelineConfig", []interface{}{pipelineName, configVersion, passedConfigCopy})
	fake.createOrUpdatePipelineConfigMutex.Unlock()
	if fake.CreateOrUpdatePipelineConfigStub != nil {
		return fake.CreateOrUpdatePipelineConfigStub(pipelineName, configVersion, passedConfig)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.createOrUpdatePipelineConfigReturns.result1, fake.createOrUpdatePipelineConfigReturns.result2, fake.createOrUpdatePipelineConfigReturns.result3, fake.createOrUpdatePipelineConfigReturns.result4
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfigCallCount() int {
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	return len(fake.createOrUpdatePipelineConfigArgsForCall)
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfigArgsForCall(i int) (string, string, []byte) {
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	return fake.createOrUpdatePipelineConfigArgsForCall[i].pipelineName, fake.createOrUpdatePipelineConfigArgsForCall[i].configVersion, fake.createOrUpdatePipelineConfigArgsForCall[i].passedConfig
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfigReturns(result1 bool, result2 bool, result3 []concourse.ConfigWarning, result4 error) {
	fake.CreateOrUpdatePipelineConfigStub = nil
	fake.createOrUpdatePipelineConfigReturns = struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) CreateOrUpdatePipelineConfigReturnsOnCall(i int, result1 bool, result2 bool, result3 []concourse.ConfigWarning, result4 error) {
	fake.CreateOrUpdatePipelineConfigStub = nil
	if fake.createOrUpdatePipelineConfigReturnsOnCall == nil {
		fake.createOrUpdatePipelineConfigReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 bool
			result3 []concourse.ConfigWarning
			result4 error
		})
	}
	fake.createOrUpdatePipelineConfigReturnsOnCall[i] = struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) CreatePipelineBuild(pipelineName string, plan atc.Plan) (atc.Build, error) {
	fake.createPipelineBuildMutex.Lock()
	ret, specificReturn := fake.createPipelineBuildReturnsOnCall[len(fake.createPipelineBuildArgsForCall)]
	fake.createPipelineBuildArgsForCall = append(fake.createPipelineBuildArgsForCall, struct {
		pipelineName string
		plan         atc.Plan
	}{pipelineName, plan})
	fake.recordInvocation("CreatePipelineBuild", []interface{}{pipelineName, plan})
	fake.createPipelineBuildMutex.Unlock()
	if fake.CreatePipelineBuildStub != nil {
		return fake.CreatePipelineBuildStub(pipelineName, plan)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createPipelineBuildReturns.result1, fake.createPipelineBuildReturns.result2
}

func (fake *FakeTeam) CreatePipelineBuildCallCount() int {
	fake.createPipelineBuildMutex.RLock()
	defer fake.createPipelineBuildMutex.RUnlock()
	return len(fake.createPipelineBuildArgsForCall)
}

func (fake *FakeTeam) CreatePipelineBuildArgsForCall(i int) (string, atc.Plan) {
	fake.createPipelineBuildMutex.RLock()
	defer fake.createPipelineBuildMutex.RUnlock()
	return fake.createPipelineBuildArgsForCall[i].pipelineName, fake.createPipelineBuildArgsForCall[i].plan
}

func (fake *FakeTeam) CreatePipelineBuildReturns(result1 atc.Build, result2 error) {
	fake.CreatePipelineBuildStub = nil
	fake.createPipelineBuildReturns = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreatePipelineBuildReturnsOnCall(i int, result1 atc.Build, result2 error) {
	fake.CreatePipelineBuildStub = nil
	if fake.createPipelineBuildReturnsOnCall == nil {
		fake.createPipelineBuildReturnsOnCall = make(map[int]struct {
			result1 atc.Build
			result2 error
		})
	}
	fake.createPipelineBuildReturnsOnCall[i] = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) BuildInputsForJob(pipelineName string, jobName string) ([]atc.BuildInput, bool, error) {
	fake.buildInputsForJobMutex.Lock()
	ret, specificReturn := fake.buildInputsForJobReturnsOnCall[len(fake.buildInputsForJobArgsForCall)]
	fake.buildInputsForJobArgsForCall = append(fake.buildInputsForJobArgsForCall, struct {
		pipelineName string
		jobName      string
	}{pipelineName, jobName})
	fake.recordInvocation("BuildInputsForJob", []interface{}{pipelineName, jobName})
	fake.buildInputsForJobMutex.Unlock()
	if fake.BuildInputsForJobStub != nil {
		return fake.BuildInputsForJobStub(pipelineName, jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.buildInputsForJobReturns.result1, fake.buildInputsForJobReturns.result2, fake.buildInputsForJobReturns.result3
}

func (fake *FakeTeam) BuildInputsForJobCallCount() int {
	fake.buildInputsForJobMutex.RLock()
	defer fake.buildInputsForJobMutex.RUnlock()
	return len(fake.buildInputsForJobArgsForCall)
}

func (fake *FakeTeam) BuildInputsForJobArgsForCall(i int) (string, string) {
	fake.buildInputsForJobMutex.RLock()
	defer fake.buildInputsForJobMutex.RUnlock()
	return fake.buildInputsForJobArgsForCall[i].pipelineName, fake.buildInputsForJobArgsForCall[i].jobName
}

func (fake *FakeTeam) BuildInputsForJobReturns(result1 []atc.BuildInput, result2 bool, result3 error) {
	fake.BuildInputsForJobStub = nil
	fake.buildInputsForJobReturns = struct {
		result1 []atc.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildInputsForJobReturnsOnCall(i int, result1 []atc.BuildInput, result2 bool, result3 error) {
	fake.BuildInputsForJobStub = nil
	if fake.buildInputsForJobReturnsOnCall == nil {
		fake.buildInputsForJobReturnsOnCall = make(map[int]struct {
			result1 []atc.BuildInput
			result2 bool
			result3 error
		})
	}
	fake.buildInputsForJobReturnsOnCall[i] = struct {
		result1 []atc.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) Job(pipelineName string, jobName string) (atc.Job, bool, error) {
	fake.jobMutex.Lock()
	ret, specificReturn := fake.jobReturnsOnCall[len(fake.jobArgsForCall)]
	fake.jobArgsForCall = append(fake.jobArgsForCall, struct {
		pipelineName string
		jobName      string
	}{pipelineName, jobName})
	fake.recordInvocation("Job", []interface{}{pipelineName, jobName})
	fake.jobMutex.Unlock()
	if fake.JobStub != nil {
		return fake.JobStub(pipelineName, jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.jobReturns.result1, fake.jobReturns.result2, fake.jobReturns.result3
}

func (fake *FakeTeam) JobCallCount() int {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return len(fake.jobArgsForCall)
}

func (fake *FakeTeam) JobArgsForCall(i int) (string, string) {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return fake.jobArgsForCall[i].pipelineName, fake.jobArgsForCall[i].jobName
}

func (fake *FakeTeam) JobReturns(result1 atc.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	fake.jobReturns = struct {
		result1 atc.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) JobReturnsOnCall(i int, result1 atc.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	if fake.jobReturnsOnCall == nil {
		fake.jobReturnsOnCall = make(map[int]struct {
			result1 atc.Job
			result2 bool
			result3 error
		})
	}
	fake.jobReturnsOnCall[i] = struct {
		result1 atc.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) JobBuild(pipelineName string, jobName string, buildName string) (atc.Build, bool, error) {
	fake.jobBuildMutex.Lock()
	ret, specificReturn := fake.jobBuildReturnsOnCall[len(fake.jobBuildArgsForCall)]
	fake.jobBuildArgsForCall = append(fake.jobBuildArgsForCall, struct {
		pipelineName string
		jobName      string
		buildName    string
	}{pipelineName, jobName, buildName})
	fake.recordInvocation("JobBuild", []interface{}{pipelineName, jobName, buildName})
	fake.jobBuildMutex.Unlock()
	if fake.JobBuildStub != nil {
		return fake.JobBuildStub(pipelineName, jobName, buildName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.jobBuildReturns.result1, fake.jobBuildReturns.result2, fake.jobBuildReturns.result3
}

func (fake *FakeTeam) JobBuildCallCount() int {
	fake.jobBuildMutex.RLock()
	defer fake.jobBuildMutex.RUnlock()
	return len(fake.jobBuildArgsForCall)
}

func (fake *FakeTeam) JobBuildArgsForCall(i int) (string, string, string) {
	fake.jobBuildMutex.RLock()
	defer fake.jobBuildMutex.RUnlock()
	return fake.jobBuildArgsForCall[i].pipelineName, fake.jobBuildArgsForCall[i].jobName, fake.jobBuildArgsForCall[i].buildName
}

func (fake *FakeTeam) JobBuildReturns(result1 atc.Build, result2 bool, result3 error) {
	fake.JobBuildStub = nil
	fake.jobBuildReturns = struct {
		result1 atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) JobBuildReturnsOnCall(i int, result1 atc.Build, result2 bool, result3 error) {
	fake.JobBuildStub = nil
	if fake.jobBuildReturnsOnCall == nil {
		fake.jobBuildReturnsOnCall = make(map[int]struct {
			result1 atc.Build
			result2 bool
			result3 error
		})
	}
	fake.jobBuildReturnsOnCall[i] = struct {
		result1 atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) JobBuilds(pipelineName string, jobName string, page concourse.Page) ([]atc.Build, concourse.Pagination, bool, error) {
	fake.jobBuildsMutex.Lock()
	ret, specificReturn := fake.jobBuildsReturnsOnCall[len(fake.jobBuildsArgsForCall)]
	fake.jobBuildsArgsForCall = append(fake.jobBuildsArgsForCall, struct {
		pipelineName string
		jobName      string
		page         concourse.Page
	}{pipelineName, jobName, page})
	fake.recordInvocation("JobBuilds", []interface{}{pipelineName, jobName, page})
	fake.jobBuildsMutex.Unlock()
	if fake.JobBuildsStub != nil {
		return fake.JobBuildsStub(pipelineName, jobName, page)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.jobBuildsReturns.result1, fake.jobBuildsReturns.result2, fake.jobBuildsReturns.result3, fake.jobBuildsReturns.result4
}

func (fake *FakeTeam) JobBuildsCallCount() int {
	fake.jobBuildsMutex.RLock()
	defer fake.jobBuildsMutex.RUnlock()
	return len(fake.jobBuildsArgsForCall)
}

func (fake *FakeTeam) JobBuildsArgsForCall(i int) (string, string, concourse.Page) {
	fake.jobBuildsMutex.RLock()
	defer fake.jobBuildsMutex.RUnlock()
	return fake.jobBuildsArgsForCall[i].pipelineName, fake.jobBuildsArgsForCall[i].jobName, fake.jobBuildsArgsForCall[i].page
}

func (fake *FakeTeam) JobBuildsReturns(result1 []atc.Build, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.JobBuildsStub = nil
	fake.jobBuildsReturns = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) JobBuildsReturnsOnCall(i int, result1 []atc.Build, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.JobBuildsStub = nil
	if fake.jobBuildsReturnsOnCall == nil {
		fake.jobBuildsReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 concourse.Pagination
			result3 bool
			result4 error
		})
	}
	fake.jobBuildsReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) CreateJobBuild(pipelineName string, jobName string) (atc.Build, error) {
	fake.createJobBuildMutex.Lock()
	ret, specificReturn := fake.createJobBuildReturnsOnCall[len(fake.createJobBuildArgsForCall)]
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		pipelineName string
		jobName      string
	}{pipelineName, jobName})
	fake.recordInvocation("CreateJobBuild", []interface{}{pipelineName, jobName})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(pipelineName, jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createJobBuildReturns.result1, fake.createJobBuildReturns.result2
}

func (fake *FakeTeam) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakeTeam) CreateJobBuildArgsForCall(i int) (string, string) {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return fake.createJobBuildArgsForCall[i].pipelineName, fake.createJobBuildArgsForCall[i].jobName
}

func (fake *FakeTeam) CreateJobBuildReturns(result1 atc.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateJobBuildReturnsOnCall(i int, result1 atc.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	if fake.createJobBuildReturnsOnCall == nil {
		fake.createJobBuildReturnsOnCall = make(map[int]struct {
			result1 atc.Build
			result2 error
		})
	}
	fake.createJobBuildReturnsOnCall[i] = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListJobs(pipelineName string) ([]atc.Job, error) {
	fake.listJobsMutex.Lock()
	ret, specificReturn := fake.listJobsReturnsOnCall[len(fake.listJobsArgsForCall)]
	fake.listJobsArgsForCall = append(fake.listJobsArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("ListJobs", []interface{}{pipelineName})
	fake.listJobsMutex.Unlock()
	if fake.ListJobsStub != nil {
		return fake.ListJobsStub(pipelineName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listJobsReturns.result1, fake.listJobsReturns.result2
}

func (fake *FakeTeam) ListJobsCallCount() int {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	return len(fake.listJobsArgsForCall)
}

func (fake *FakeTeam) ListJobsArgsForCall(i int) string {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	return fake.listJobsArgsForCall[i].pipelineName
}

func (fake *FakeTeam) ListJobsReturns(result1 []atc.Job, result2 error) {
	fake.ListJobsStub = nil
	fake.listJobsReturns = struct {
		result1 []atc.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ListJobsReturnsOnCall(i int, result1 []atc.Job, result2 error) {
	fake.ListJobsStub = nil
	if fake.listJobsReturnsOnCall == nil {
		fake.listJobsReturnsOnCall = make(map[int]struct {
			result1 []atc.Job
			result2 error
		})
	}
	fake.listJobsReturnsOnCall[i] = struct {
		result1 []atc.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PauseJob(pipelineName string, jobName string) (bool, error) {
	fake.pauseJobMutex.Lock()
	ret, specificReturn := fake.pauseJobReturnsOnCall[len(fake.pauseJobArgsForCall)]
	fake.pauseJobArgsForCall = append(fake.pauseJobArgsForCall, struct {
		pipelineName string
		jobName      string
	}{pipelineName, jobName})
	fake.recordInvocation("PauseJob", []interface{}{pipelineName, jobName})
	fake.pauseJobMutex.Unlock()
	if fake.PauseJobStub != nil {
		return fake.PauseJobStub(pipelineName, jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pauseJobReturns.result1, fake.pauseJobReturns.result2
}

func (fake *FakeTeam) PauseJobCallCount() int {
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	return len(fake.pauseJobArgsForCall)
}

func (fake *FakeTeam) PauseJobArgsForCall(i int) (string, string) {
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	return fake.pauseJobArgsForCall[i].pipelineName, fake.pauseJobArgsForCall[i].jobName
}

func (fake *FakeTeam) PauseJobReturns(result1 bool, result2 error) {
	fake.PauseJobStub = nil
	fake.pauseJobReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PauseJobReturnsOnCall(i int, result1 bool, result2 error) {
	fake.PauseJobStub = nil
	if fake.pauseJobReturnsOnCall == nil {
		fake.pauseJobReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pauseJobReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpauseJob(pipelineName string, jobName string) (bool, error) {
	fake.unpauseJobMutex.Lock()
	ret, specificReturn := fake.unpauseJobReturnsOnCall[len(fake.unpauseJobArgsForCall)]
	fake.unpauseJobArgsForCall = append(fake.unpauseJobArgsForCall, struct {
		pipelineName string
		jobName      string
	}{pipelineName, jobName})
	fake.recordInvocation("UnpauseJob", []interface{}{pipelineName, jobName})
	fake.unpauseJobMutex.Unlock()
	if fake.UnpauseJobStub != nil {
		return fake.UnpauseJobStub(pipelineName, jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.unpauseJobReturns.result1, fake.unpauseJobReturns.result2
}

func (fake *FakeTeam) UnpauseJobCallCount() int {
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	return len(fake.unpauseJobArgsForCall)
}

func (fake *FakeTeam) UnpauseJobArgsForCall(i int) (string, string) {
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	return fake.unpauseJobArgsForCall[i].pipelineName, fake.unpauseJobArgsForCall[i].jobName
}

func (fake *FakeTeam) UnpauseJobReturns(result1 bool, result2 error) {
	fake.UnpauseJobStub = nil
	fake.unpauseJobReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UnpauseJobReturnsOnCall(i int, result1 bool, result2 error) {
	fake.UnpauseJobStub = nil
	if fake.unpauseJobReturnsOnCall == nil {
		fake.unpauseJobReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unpauseJobReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Resource(pipelineName string, resourceName string) (atc.Resource, bool, error) {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
		pipelineName string
		resourceName string
	}{pipelineName, resourceName})
	fake.recordInvocation("Resource", []interface{}{pipelineName, resourceName})
	fake.resourceMutex.Unlock()
	if fake.ResourceStub != nil {
		return fake.ResourceStub(pipelineName, resourceName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.resourceReturns.result1, fake.resourceReturns.result2, fake.resourceReturns.result3
}

func (fake *FakeTeam) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakeTeam) ResourceArgsForCall(i int) (string, string) {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return fake.resourceArgsForCall[i].pipelineName, fake.resourceArgsForCall[i].resourceName
}

func (fake *FakeTeam) ResourceReturns(result1 atc.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 atc.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) ResourceReturnsOnCall(i int, result1 atc.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 atc.Resource
			result2 bool
			result3 error
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 atc.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) ResourceVersions(pipelineName string, resourceName string, page concourse.Page) ([]atc.VersionedResource, concourse.Pagination, bool, error) {
	fake.resourceVersionsMutex.Lock()
	ret, specificReturn := fake.resourceVersionsReturnsOnCall[len(fake.resourceVersionsArgsForCall)]
	fake.resourceVersionsArgsForCall = append(fake.resourceVersionsArgsForCall, struct {
		pipelineName string
		resourceName string
		page         concourse.Page
	}{pipelineName, resourceName, page})
	fake.recordInvocation("ResourceVersions", []interface{}{pipelineName, resourceName, page})
	fake.resourceVersionsMutex.Unlock()
	if fake.ResourceVersionsStub != nil {
		return fake.ResourceVersionsStub(pipelineName, resourceName, page)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.resourceVersionsReturns.result1, fake.resourceVersionsReturns.result2, fake.resourceVersionsReturns.result3, fake.resourceVersionsReturns.result4
}

func (fake *FakeTeam) ResourceVersionsCallCount() int {
	fake.resourceVersionsMutex.RLock()
	defer fake.resourceVersionsMutex.RUnlock()
	return len(fake.resourceVersionsArgsForCall)
}

func (fake *FakeTeam) ResourceVersionsArgsForCall(i int) (string, string, concourse.Page) {
	fake.resourceVersionsMutex.RLock()
	defer fake.resourceVersionsMutex.RUnlock()
	return fake.resourceVersionsArgsForCall[i].pipelineName, fake.resourceVersionsArgsForCall[i].resourceName, fake.resourceVersionsArgsForCall[i].page
}

func (fake *FakeTeam) ResourceVersionsReturns(result1 []atc.VersionedResource, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.ResourceVersionsStub = nil
	fake.resourceVersionsReturns = struct {
		result1 []atc.VersionedResource
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) ResourceVersionsReturnsOnCall(i int, result1 []atc.VersionedResource, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.ResourceVersionsStub = nil
	if fake.resourceVersionsReturnsOnCall == nil {
		fake.resourceVersionsReturnsOnCall = make(map[int]struct {
			result1 []atc.VersionedResource
			result2 concourse.Pagination
			result3 bool
			result4 error
		})
	}
	fake.resourceVersionsReturnsOnCall[i] = struct {
		result1 []atc.VersionedResource
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeam) CheckResource(pipelineName string, resourceName string, version atc.Version) (bool, error) {
	fake.checkResourceMutex.Lock()
	ret, specificReturn := fake.checkResourceReturnsOnCall[len(fake.checkResourceArgsForCall)]
	fake.checkResourceArgsForCall = append(fake.checkResourceArgsForCall, struct {
		pipelineName string
		resourceName string
		version      atc.Version
	}{pipelineName, resourceName, version})
	fake.recordInvocation("CheckResource", []interface{}{pipelineName, resourceName, version})
	fake.checkResourceMutex.Unlock()
	if fake.CheckResourceStub != nil {
		return fake.CheckResourceStub(pipelineName, resourceName, version)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.checkResourceReturns.result1, fake.checkResourceReturns.result2
}

func (fake *FakeTeam) CheckResourceCallCount() int {
	fake.checkResourceMutex.RLock()
	defer fake.checkResourceMutex.RUnlock()
	return len(fake.checkResourceArgsForCall)
}

func (fake *FakeTeam) CheckResourceArgsForCall(i int) (string, string, atc.Version) {
	fake.checkResourceMutex.RLock()
	defer fake.checkResourceMutex.RUnlock()
	return fake.checkResourceArgsForCall[i].pipelineName, fake.checkResourceArgsForCall[i].resourceName, fake.checkResourceArgsForCall[i].version
}

func (fake *FakeTeam) CheckResourceReturns(result1 bool, result2 error) {
	fake.CheckResourceStub = nil
	fake.checkResourceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CheckResourceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CheckResourceStub = nil
	if fake.checkResourceReturnsOnCall == nil {
		fake.checkResourceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkResourceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) BuildsWithVersionAsInput(pipelineName string, resourceName string, resourceVersionID int) ([]atc.Build, bool, error) {
	fake.buildsWithVersionAsInputMutex.Lock()
	ret, specificReturn := fake.buildsWithVersionAsInputReturnsOnCall[len(fake.buildsWithVersionAsInputArgsForCall)]
	fake.buildsWithVersionAsInputArgsForCall = append(fake.buildsWithVersionAsInputArgsForCall, struct {
		pipelineName      string
		resourceName      string
		resourceVersionID int
	}{pipelineName, resourceName, resourceVersionID})
	fake.recordInvocation("BuildsWithVersionAsInput", []interface{}{pipelineName, resourceName, resourceVersionID})
	fake.buildsWithVersionAsInputMutex.Unlock()
	if fake.BuildsWithVersionAsInputStub != nil {
		return fake.BuildsWithVersionAsInputStub(pipelineName, resourceName, resourceVersionID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.buildsWithVersionAsInputReturns.result1, fake.buildsWithVersionAsInputReturns.result2, fake.buildsWithVersionAsInputReturns.result3
}

func (fake *FakeTeam) BuildsWithVersionAsInputCallCount() int {
	fake.buildsWithVersionAsInputMutex.RLock()
	defer fake.buildsWithVersionAsInputMutex.RUnlock()
	return len(fake.buildsWithVersionAsInputArgsForCall)
}

func (fake *FakeTeam) BuildsWithVersionAsInputArgsForCall(i int) (string, string, int) {
	fake.buildsWithVersionAsInputMutex.RLock()
	defer fake.buildsWithVersionAsInputMutex.RUnlock()
	return fake.buildsWithVersionAsInputArgsForCall[i].pipelineName, fake.buildsWithVersionAsInputArgsForCall[i].resourceName, fake.buildsWithVersionAsInputArgsForCall[i].resourceVersionID
}

func (fake *FakeTeam) BuildsWithVersionAsInputReturns(result1 []atc.Build, result2 bool, result3 error) {
	fake.BuildsWithVersionAsInputStub = nil
	fake.buildsWithVersionAsInputReturns = struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsWithVersionAsInputReturnsOnCall(i int, result1 []atc.Build, result2 bool, result3 error) {
	fake.BuildsWithVersionAsInputStub = nil
	if fake.buildsWithVersionAsInputReturnsOnCall == nil {
		fake.buildsWithVersionAsInputReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 bool
			result3 error
		})
	}
	fake.buildsWithVersionAsInputReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsWithVersionAsOutput(pipelineName string, resourceName string, resourceVersionID int) ([]atc.Build, bool, error) {
	fake.buildsWithVersionAsOutputMutex.Lock()
	ret, specificReturn := fake.buildsWithVersionAsOutputReturnsOnCall[len(fake.buildsWithVersionAsOutputArgsForCall)]
	fake.buildsWithVersionAsOutputArgsForCall = append(fake.buildsWithVersionAsOutputArgsForCall, struct {
		pipelineName      string
		resourceName      string
		resourceVersionID int
	}{pipelineName, resourceName, resourceVersionID})
	fake.recordInvocation("BuildsWithVersionAsOutput", []interface{}{pipelineName, resourceName, resourceVersionID})
	fake.buildsWithVersionAsOutputMutex.Unlock()
	if fake.BuildsWithVersionAsOutputStub != nil {
		return fake.BuildsWithVersionAsOutputStub(pipelineName, resourceName, resourceVersionID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.buildsWithVersionAsOutputReturns.result1, fake.buildsWithVersionAsOutputReturns.result2, fake.buildsWithVersionAsOutputReturns.result3
}

func (fake *FakeTeam) BuildsWithVersionAsOutputCallCount() int {
	fake.buildsWithVersionAsOutputMutex.RLock()
	defer fake.buildsWithVersionAsOutputMutex.RUnlock()
	return len(fake.buildsWithVersionAsOutputArgsForCall)
}

func (fake *FakeTeam) BuildsWithVersionAsOutputArgsForCall(i int) (string, string, int) {
	fake.buildsWithVersionAsOutputMutex.RLock()
	defer fake.buildsWithVersionAsOutputMutex.RUnlock()
	return fake.buildsWithVersionAsOutputArgsForCall[i].pipelineName, fake.buildsWithVersionAsOutputArgsForCall[i].resourceName, fake.buildsWithVersionAsOutputArgsForCall[i].resourceVersionID
}

func (fake *FakeTeam) BuildsWithVersionAsOutputReturns(result1 []atc.Build, result2 bool, result3 error) {
	fake.BuildsWithVersionAsOutputStub = nil
	fake.buildsWithVersionAsOutputReturns = struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsWithVersionAsOutputReturnsOnCall(i int, result1 []atc.Build, result2 bool, result3 error) {
	fake.BuildsWithVersionAsOutputStub = nil
	if fake.buildsWithVersionAsOutputReturnsOnCall == nil {
		fake.buildsWithVersionAsOutputReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 bool
			result3 error
		})
	}
	fake.buildsWithVersionAsOutputReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.listAuthMethodsMutex.RLock()
	defer fake.listAuthMethodsMutex.RUnlock()
	fake.authTokenMutex.RLock()
	defer fake.authTokenMutex.RUnlock()
	fake.createOrUpdateMutex.RLock()
	defer fake.createOrUpdateMutex.RUnlock()
	fake.renameTeamMutex.RLock()
	defer fake.renameTeamMutex.RUnlock()
	fake.destroyTeamMutex.RLock()
	defer fake.destroyTeamMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.deletePipelineMutex.RLock()
	defer fake.deletePipelineMutex.RUnlock()
	fake.pausePipelineMutex.RLock()
	defer fake.pausePipelineMutex.RUnlock()
	fake.unpausePipelineMutex.RLock()
	defer fake.unpausePipelineMutex.RUnlock()
	fake.exposePipelineMutex.RLock()
	defer fake.exposePipelineMutex.RUnlock()
	fake.hidePipelineMutex.RLock()
	defer fake.hidePipelineMutex.RUnlock()
	fake.renamePipelineMutex.RLock()
	defer fake.renamePipelineMutex.RUnlock()
	fake.pauseResourceMutex.RLock()
	defer fake.pauseResourceMutex.RUnlock()
	fake.unpauseResourceMutex.RLock()
	defer fake.unpauseResourceMutex.RUnlock()
	fake.listPipelinesMutex.RLock()
	defer fake.listPipelinesMutex.RUnlock()
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	fake.createPipelineBuildMutex.RLock()
	defer fake.createPipelineBuildMutex.RUnlock()
	fake.buildInputsForJobMutex.RLock()
	defer fake.buildInputsForJobMutex.RUnlock()
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	fake.jobBuildMutex.RLock()
	defer fake.jobBuildMutex.RUnlock()
	fake.jobBuildsMutex.RLock()
	defer fake.jobBuildsMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.resourceVersionsMutex.RLock()
	defer fake.resourceVersionsMutex.RUnlock()
	fake.checkResourceMutex.RLock()
	defer fake.checkResourceMutex.RUnlock()
	fake.buildsWithVersionAsInputMutex.RLock()
	defer fake.buildsWithVersionAsInputMutex.RUnlock()
	fake.buildsWithVersionAsOutputMutex.RLock()
	defer fake.buildsWithVersionAsOutputMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTeam) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ concourse.Team = new(FakeTeam)
