// Code generated by counterfeiter. DO NOT EDIT.
package execfakes

import (
	"context"
	"io"
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/db/lock"
	"github.com/concourse/concourse/atc/exec"
	"github.com/concourse/concourse/atc/runtime"
	"github.com/concourse/concourse/tracing"
	"go.opentelemetry.io/otel/trace"
)

type FakeCheckDelegate struct {
	BeforeSelectWorkerStub        func(lager.Logger) error
	beforeSelectWorkerMutex       sync.RWMutex
	beforeSelectWorkerArgsForCall []struct {
		arg1 lager.Logger
	}
	beforeSelectWorkerReturns struct {
		result1 error
	}
	beforeSelectWorkerReturnsOnCall map[int]struct {
		result1 error
	}
	BuildStartTimeStub        func() time.Time
	buildStartTimeMutex       sync.RWMutex
	buildStartTimeArgsForCall []struct {
	}
	buildStartTimeReturns struct {
		result1 time.Time
	}
	buildStartTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	ConstructAcrossSubstepsStub        func([]byte, []atc.AcrossVar, [][]interface{}) ([]atc.VarScopedPlan, error)
	constructAcrossSubstepsMutex       sync.RWMutex
	constructAcrossSubstepsArgsForCall []struct {
		arg1 []byte
		arg2 []atc.AcrossVar
		arg3 [][]interface{}
	}
	constructAcrossSubstepsReturns struct {
		result1 []atc.VarScopedPlan
		result2 error
	}
	constructAcrossSubstepsReturnsOnCall map[int]struct {
		result1 []atc.VarScopedPlan
		result2 error
	}
	ContainerOwnerStub        func(atc.PlanID) db.ContainerOwner
	containerOwnerMutex       sync.RWMutex
	containerOwnerArgsForCall []struct {
		arg1 atc.PlanID
	}
	containerOwnerReturns struct {
		result1 db.ContainerOwner
	}
	containerOwnerReturnsOnCall map[int]struct {
		result1 db.ContainerOwner
	}
	ErroredStub        func(lager.Logger, string)
	erroredMutex       sync.RWMutex
	erroredArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	FetchImageStub        func(context.Context, atc.Plan, *atc.Plan, bool) (runtime.ImageSpec, db.ResourceCache, error)
	fetchImageMutex       sync.RWMutex
	fetchImageArgsForCall []struct {
		arg1 context.Context
		arg2 atc.Plan
		arg3 *atc.Plan
		arg4 bool
	}
	fetchImageReturns struct {
		result1 runtime.ImageSpec
		result2 db.ResourceCache
		result3 error
	}
	fetchImageReturnsOnCall map[int]struct {
		result1 runtime.ImageSpec
		result2 db.ResourceCache
		result3 error
	}
	FindOrCreateScopeStub        func(db.ResourceConfig) (db.ResourceConfigScope, error)
	findOrCreateScopeMutex       sync.RWMutex
	findOrCreateScopeArgsForCall []struct {
		arg1 db.ResourceConfig
	}
	findOrCreateScopeReturns struct {
		result1 db.ResourceConfigScope
		result2 error
	}
	findOrCreateScopeReturnsOnCall map[int]struct {
		result1 db.ResourceConfigScope
		result2 error
	}
	FinishedStub        func(lager.Logger, bool)
	finishedMutex       sync.RWMutex
	finishedArgsForCall []struct {
		arg1 lager.Logger
		arg2 bool
	}
	InitializingStub        func(lager.Logger)
	initializingMutex       sync.RWMutex
	initializingArgsForCall []struct {
		arg1 lager.Logger
	}
	PointToCheckedConfigStub        func(db.ResourceConfigScope) error
	pointToCheckedConfigMutex       sync.RWMutex
	pointToCheckedConfigArgsForCall []struct {
		arg1 db.ResourceConfigScope
	}
	pointToCheckedConfigReturns struct {
		result1 error
	}
	pointToCheckedConfigReturnsOnCall map[int]struct {
		result1 error
	}
	SelectedWorkerStub        func(lager.Logger, string)
	selectedWorkerMutex       sync.RWMutex
	selectedWorkerArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	StartSpanStub        func(context.Context, string, tracing.Attrs) (context.Context, trace.Span)
	startSpanMutex       sync.RWMutex
	startSpanArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 tracing.Attrs
	}
	startSpanReturns struct {
		result1 context.Context
		result2 trace.Span
	}
	startSpanReturnsOnCall map[int]struct {
		result1 context.Context
		result2 trace.Span
	}
	StartingStub        func(lager.Logger)
	startingMutex       sync.RWMutex
	startingArgsForCall []struct {
		arg1 lager.Logger
	}
	StderrStub        func() io.Writer
	stderrMutex       sync.RWMutex
	stderrArgsForCall []struct {
	}
	stderrReturns struct {
		result1 io.Writer
	}
	stderrReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	StdoutStub        func() io.Writer
	stdoutMutex       sync.RWMutex
	stdoutArgsForCall []struct {
	}
	stdoutReturns struct {
		result1 io.Writer
	}
	stdoutReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	StreamingVolumeStub        func(lager.Logger, string, string, string)
	streamingVolumeMutex       sync.RWMutex
	streamingVolumeArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
	}
	UpdateScopeLastCheckEndTimeStub        func(db.ResourceConfigScope, bool) (bool, error)
	updateScopeLastCheckEndTimeMutex       sync.RWMutex
	updateScopeLastCheckEndTimeArgsForCall []struct {
		arg1 db.ResourceConfigScope
		arg2 bool
	}
	updateScopeLastCheckEndTimeReturns struct {
		result1 bool
		result2 error
	}
	updateScopeLastCheckEndTimeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UpdateScopeLastCheckStartTimeStub        func(db.ResourceConfigScope, bool) (bool, int, error)
	updateScopeLastCheckStartTimeMutex       sync.RWMutex
	updateScopeLastCheckStartTimeArgsForCall []struct {
		arg1 db.ResourceConfigScope
		arg2 bool
	}
	updateScopeLastCheckStartTimeReturns struct {
		result1 bool
		result2 int
		result3 error
	}
	updateScopeLastCheckStartTimeReturnsOnCall map[int]struct {
		result1 bool
		result2 int
		result3 error
	}
	WaitToRunStub        func(context.Context, db.ResourceConfigScope) (lock.Lock, bool, error)
	waitToRunMutex       sync.RWMutex
	waitToRunArgsForCall []struct {
		arg1 context.Context
		arg2 db.ResourceConfigScope
	}
	waitToRunReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	waitToRunReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	WaitingForStreamedVolumeStub        func(lager.Logger, string, string)
	waitingForStreamedVolumeMutex       sync.RWMutex
	waitingForStreamedVolumeArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	WaitingForWorkerStub        func(lager.Logger)
	waitingForWorkerMutex       sync.RWMutex
	waitingForWorkerArgsForCall []struct {
		arg1 lager.Logger
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCheckDelegate) BeforeSelectWorker(arg1 lager.Logger) error {
	fake.beforeSelectWorkerMutex.Lock()
	ret, specificReturn := fake.beforeSelectWorkerReturnsOnCall[len(fake.beforeSelectWorkerArgsForCall)]
	fake.beforeSelectWorkerArgsForCall = append(fake.beforeSelectWorkerArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.BeforeSelectWorkerStub
	fakeReturns := fake.beforeSelectWorkerReturns
	fake.recordInvocation("BeforeSelectWorker", []interface{}{arg1})
	fake.beforeSelectWorkerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCheckDelegate) BeforeSelectWorkerCallCount() int {
	fake.beforeSelectWorkerMutex.RLock()
	defer fake.beforeSelectWorkerMutex.RUnlock()
	return len(fake.beforeSelectWorkerArgsForCall)
}

func (fake *FakeCheckDelegate) BeforeSelectWorkerCalls(stub func(lager.Logger) error) {
	fake.beforeSelectWorkerMutex.Lock()
	defer fake.beforeSelectWorkerMutex.Unlock()
	fake.BeforeSelectWorkerStub = stub
}

func (fake *FakeCheckDelegate) BeforeSelectWorkerArgsForCall(i int) lager.Logger {
	fake.beforeSelectWorkerMutex.RLock()
	defer fake.beforeSelectWorkerMutex.RUnlock()
	argsForCall := fake.beforeSelectWorkerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheckDelegate) BeforeSelectWorkerReturns(result1 error) {
	fake.beforeSelectWorkerMutex.Lock()
	defer fake.beforeSelectWorkerMutex.Unlock()
	fake.BeforeSelectWorkerStub = nil
	fake.beforeSelectWorkerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheckDelegate) BeforeSelectWorkerReturnsOnCall(i int, result1 error) {
	fake.beforeSelectWorkerMutex.Lock()
	defer fake.beforeSelectWorkerMutex.Unlock()
	fake.BeforeSelectWorkerStub = nil
	if fake.beforeSelectWorkerReturnsOnCall == nil {
		fake.beforeSelectWorkerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.beforeSelectWorkerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheckDelegate) BuildStartTime() time.Time {
	fake.buildStartTimeMutex.Lock()
	ret, specificReturn := fake.buildStartTimeReturnsOnCall[len(fake.buildStartTimeArgsForCall)]
	fake.buildStartTimeArgsForCall = append(fake.buildStartTimeArgsForCall, struct {
	}{})
	stub := fake.BuildStartTimeStub
	fakeReturns := fake.buildStartTimeReturns
	fake.recordInvocation("BuildStartTime", []interface{}{})
	fake.buildStartTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCheckDelegate) BuildStartTimeCallCount() int {
	fake.buildStartTimeMutex.RLock()
	defer fake.buildStartTimeMutex.RUnlock()
	return len(fake.buildStartTimeArgsForCall)
}

func (fake *FakeCheckDelegate) BuildStartTimeCalls(stub func() time.Time) {
	fake.buildStartTimeMutex.Lock()
	defer fake.buildStartTimeMutex.Unlock()
	fake.BuildStartTimeStub = stub
}

func (fake *FakeCheckDelegate) BuildStartTimeReturns(result1 time.Time) {
	fake.buildStartTimeMutex.Lock()
	defer fake.buildStartTimeMutex.Unlock()
	fake.BuildStartTimeStub = nil
	fake.buildStartTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheckDelegate) BuildStartTimeReturnsOnCall(i int, result1 time.Time) {
	fake.buildStartTimeMutex.Lock()
	defer fake.buildStartTimeMutex.Unlock()
	fake.BuildStartTimeStub = nil
	if fake.buildStartTimeReturnsOnCall == nil {
		fake.buildStartTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.buildStartTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheckDelegate) ConstructAcrossSubsteps(arg1 []byte, arg2 []atc.AcrossVar, arg3 [][]interface{}) ([]atc.VarScopedPlan, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	var arg2Copy []atc.AcrossVar
	if arg2 != nil {
		arg2Copy = make([]atc.AcrossVar, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy [][]interface{}
	if arg3 != nil {
		arg3Copy = make([][]interface{}, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.constructAcrossSubstepsMutex.Lock()
	ret, specificReturn := fake.constructAcrossSubstepsReturnsOnCall[len(fake.constructAcrossSubstepsArgsForCall)]
	fake.constructAcrossSubstepsArgsForCall = append(fake.constructAcrossSubstepsArgsForCall, struct {
		arg1 []byte
		arg2 []atc.AcrossVar
		arg3 [][]interface{}
	}{arg1Copy, arg2Copy, arg3Copy})
	stub := fake.ConstructAcrossSubstepsStub
	fakeReturns := fake.constructAcrossSubstepsReturns
	fake.recordInvocation("ConstructAcrossSubsteps", []interface{}{arg1Copy, arg2Copy, arg3Copy})
	fake.constructAcrossSubstepsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCheckDelegate) ConstructAcrossSubstepsCallCount() int {
	fake.constructAcrossSubstepsMutex.RLock()
	defer fake.constructAcrossSubstepsMutex.RUnlock()
	return len(fake.constructAcrossSubstepsArgsForCall)
}

func (fake *FakeCheckDelegate) ConstructAcrossSubstepsCalls(stub func([]byte, []atc.AcrossVar, [][]interface{}) ([]atc.VarScopedPlan, error)) {
	fake.constructAcrossSubstepsMutex.Lock()
	defer fake.constructAcrossSubstepsMutex.Unlock()
	fake.ConstructAcrossSubstepsStub = stub
}

func (fake *FakeCheckDelegate) ConstructAcrossSubstepsArgsForCall(i int) ([]byte, []atc.AcrossVar, [][]interface{}) {
	fake.constructAcrossSubstepsMutex.RLock()
	defer fake.constructAcrossSubstepsMutex.RUnlock()
	argsForCall := fake.constructAcrossSubstepsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCheckDelegate) ConstructAcrossSubstepsReturns(result1 []atc.VarScopedPlan, result2 error) {
	fake.constructAcrossSubstepsMutex.Lock()
	defer fake.constructAcrossSubstepsMutex.Unlock()
	fake.ConstructAcrossSubstepsStub = nil
	fake.constructAcrossSubstepsReturns = struct {
		result1 []atc.VarScopedPlan
		result2 error
	}{result1, result2}
}

func (fake *FakeCheckDelegate) ConstructAcrossSubstepsReturnsOnCall(i int, result1 []atc.VarScopedPlan, result2 error) {
	fake.constructAcrossSubstepsMutex.Lock()
	defer fake.constructAcrossSubstepsMutex.Unlock()
	fake.ConstructAcrossSubstepsStub = nil
	if fake.constructAcrossSubstepsReturnsOnCall == nil {
		fake.constructAcrossSubstepsReturnsOnCall = make(map[int]struct {
			result1 []atc.VarScopedPlan
			result2 error
		})
	}
	fake.constructAcrossSubstepsReturnsOnCall[i] = struct {
		result1 []atc.VarScopedPlan
		result2 error
	}{result1, result2}
}

func (fake *FakeCheckDelegate) ContainerOwner(arg1 atc.PlanID) db.ContainerOwner {
	fake.containerOwnerMutex.Lock()
	ret, specificReturn := fake.containerOwnerReturnsOnCall[len(fake.containerOwnerArgsForCall)]
	fake.containerOwnerArgsForCall = append(fake.containerOwnerArgsForCall, struct {
		arg1 atc.PlanID
	}{arg1})
	stub := fake.ContainerOwnerStub
	fakeReturns := fake.containerOwnerReturns
	fake.recordInvocation("ContainerOwner", []interface{}{arg1})
	fake.containerOwnerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCheckDelegate) ContainerOwnerCallCount() int {
	fake.containerOwnerMutex.RLock()
	defer fake.containerOwnerMutex.RUnlock()
	return len(fake.containerOwnerArgsForCall)
}

func (fake *FakeCheckDelegate) ContainerOwnerCalls(stub func(atc.PlanID) db.ContainerOwner) {
	fake.containerOwnerMutex.Lock()
	defer fake.containerOwnerMutex.Unlock()
	fake.ContainerOwnerStub = stub
}

func (fake *FakeCheckDelegate) ContainerOwnerArgsForCall(i int) atc.PlanID {
	fake.containerOwnerMutex.RLock()
	defer fake.containerOwnerMutex.RUnlock()
	argsForCall := fake.containerOwnerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheckDelegate) ContainerOwnerReturns(result1 db.ContainerOwner) {
	fake.containerOwnerMutex.Lock()
	defer fake.containerOwnerMutex.Unlock()
	fake.ContainerOwnerStub = nil
	fake.containerOwnerReturns = struct {
		result1 db.ContainerOwner
	}{result1}
}

func (fake *FakeCheckDelegate) ContainerOwnerReturnsOnCall(i int, result1 db.ContainerOwner) {
	fake.containerOwnerMutex.Lock()
	defer fake.containerOwnerMutex.Unlock()
	fake.ContainerOwnerStub = nil
	if fake.containerOwnerReturnsOnCall == nil {
		fake.containerOwnerReturnsOnCall = make(map[int]struct {
			result1 db.ContainerOwner
		})
	}
	fake.containerOwnerReturnsOnCall[i] = struct {
		result1 db.ContainerOwner
	}{result1}
}

func (fake *FakeCheckDelegate) Errored(arg1 lager.Logger, arg2 string) {
	fake.erroredMutex.Lock()
	fake.erroredArgsForCall = append(fake.erroredArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.ErroredStub
	fake.recordInvocation("Errored", []interface{}{arg1, arg2})
	fake.erroredMutex.Unlock()
	if stub != nil {
		fake.ErroredStub(arg1, arg2)
	}
}

func (fake *FakeCheckDelegate) ErroredCallCount() int {
	fake.erroredMutex.RLock()
	defer fake.erroredMutex.RUnlock()
	return len(fake.erroredArgsForCall)
}

func (fake *FakeCheckDelegate) ErroredCalls(stub func(lager.Logger, string)) {
	fake.erroredMutex.Lock()
	defer fake.erroredMutex.Unlock()
	fake.ErroredStub = stub
}

func (fake *FakeCheckDelegate) ErroredArgsForCall(i int) (lager.Logger, string) {
	fake.erroredMutex.RLock()
	defer fake.erroredMutex.RUnlock()
	argsForCall := fake.erroredArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCheckDelegate) FetchImage(arg1 context.Context, arg2 atc.Plan, arg3 *atc.Plan, arg4 bool) (runtime.ImageSpec, db.ResourceCache, error) {
	fake.fetchImageMutex.Lock()
	ret, specificReturn := fake.fetchImageReturnsOnCall[len(fake.fetchImageArgsForCall)]
	fake.fetchImageArgsForCall = append(fake.fetchImageArgsForCall, struct {
		arg1 context.Context
		arg2 atc.Plan
		arg3 *atc.Plan
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.FetchImageStub
	fakeReturns := fake.fetchImageReturns
	fake.recordInvocation("FetchImage", []interface{}{arg1, arg2, arg3, arg4})
	fake.fetchImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCheckDelegate) FetchImageCallCount() int {
	fake.fetchImageMutex.RLock()
	defer fake.fetchImageMutex.RUnlock()
	return len(fake.fetchImageArgsForCall)
}

func (fake *FakeCheckDelegate) FetchImageCalls(stub func(context.Context, atc.Plan, *atc.Plan, bool) (runtime.ImageSpec, db.ResourceCache, error)) {
	fake.fetchImageMutex.Lock()
	defer fake.fetchImageMutex.Unlock()
	fake.FetchImageStub = stub
}

func (fake *FakeCheckDelegate) FetchImageArgsForCall(i int) (context.Context, atc.Plan, *atc.Plan, bool) {
	fake.fetchImageMutex.RLock()
	defer fake.fetchImageMutex.RUnlock()
	argsForCall := fake.fetchImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCheckDelegate) FetchImageReturns(result1 runtime.ImageSpec, result2 db.ResourceCache, result3 error) {
	fake.fetchImageMutex.Lock()
	defer fake.fetchImageMutex.Unlock()
	fake.FetchImageStub = nil
	fake.fetchImageReturns = struct {
		result1 runtime.ImageSpec
		result2 db.ResourceCache
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheckDelegate) FetchImageReturnsOnCall(i int, result1 runtime.ImageSpec, result2 db.ResourceCache, result3 error) {
	fake.fetchImageMutex.Lock()
	defer fake.fetchImageMutex.Unlock()
	fake.FetchImageStub = nil
	if fake.fetchImageReturnsOnCall == nil {
		fake.fetchImageReturnsOnCall = make(map[int]struct {
			result1 runtime.ImageSpec
			result2 db.ResourceCache
			result3 error
		})
	}
	fake.fetchImageReturnsOnCall[i] = struct {
		result1 runtime.ImageSpec
		result2 db.ResourceCache
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheckDelegate) FindOrCreateScope(arg1 db.ResourceConfig) (db.ResourceConfigScope, error) {
	fake.findOrCreateScopeMutex.Lock()
	ret, specificReturn := fake.findOrCreateScopeReturnsOnCall[len(fake.findOrCreateScopeArgsForCall)]
	fake.findOrCreateScopeArgsForCall = append(fake.findOrCreateScopeArgsForCall, struct {
		arg1 db.ResourceConfig
	}{arg1})
	stub := fake.FindOrCreateScopeStub
	fakeReturns := fake.findOrCreateScopeReturns
	fake.recordInvocation("FindOrCreateScope", []interface{}{arg1})
	fake.findOrCreateScopeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCheckDelegate) FindOrCreateScopeCallCount() int {
	fake.findOrCreateScopeMutex.RLock()
	defer fake.findOrCreateScopeMutex.RUnlock()
	return len(fake.findOrCreateScopeArgsForCall)
}

func (fake *FakeCheckDelegate) FindOrCreateScopeCalls(stub func(db.ResourceConfig) (db.ResourceConfigScope, error)) {
	fake.findOrCreateScopeMutex.Lock()
	defer fake.findOrCreateScopeMutex.Unlock()
	fake.FindOrCreateScopeStub = stub
}

func (fake *FakeCheckDelegate) FindOrCreateScopeArgsForCall(i int) db.ResourceConfig {
	fake.findOrCreateScopeMutex.RLock()
	defer fake.findOrCreateScopeMutex.RUnlock()
	argsForCall := fake.findOrCreateScopeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheckDelegate) FindOrCreateScopeReturns(result1 db.ResourceConfigScope, result2 error) {
	fake.findOrCreateScopeMutex.Lock()
	defer fake.findOrCreateScopeMutex.Unlock()
	fake.FindOrCreateScopeStub = nil
	fake.findOrCreateScopeReturns = struct {
		result1 db.ResourceConfigScope
		result2 error
	}{result1, result2}
}

func (fake *FakeCheckDelegate) FindOrCreateScopeReturnsOnCall(i int, result1 db.ResourceConfigScope, result2 error) {
	fake.findOrCreateScopeMutex.Lock()
	defer fake.findOrCreateScopeMutex.Unlock()
	fake.FindOrCreateScopeStub = nil
	if fake.findOrCreateScopeReturnsOnCall == nil {
		fake.findOrCreateScopeReturnsOnCall = make(map[int]struct {
			result1 db.ResourceConfigScope
			result2 error
		})
	}
	fake.findOrCreateScopeReturnsOnCall[i] = struct {
		result1 db.ResourceConfigScope
		result2 error
	}{result1, result2}
}

func (fake *FakeCheckDelegate) Finished(arg1 lager.Logger, arg2 bool) {
	fake.finishedMutex.Lock()
	fake.finishedArgsForCall = append(fake.finishedArgsForCall, struct {
		arg1 lager.Logger
		arg2 bool
	}{arg1, arg2})
	stub := fake.FinishedStub
	fake.recordInvocation("Finished", []interface{}{arg1, arg2})
	fake.finishedMutex.Unlock()
	if stub != nil {
		fake.FinishedStub(arg1, arg2)
	}
}

func (fake *FakeCheckDelegate) FinishedCallCount() int {
	fake.finishedMutex.RLock()
	defer fake.finishedMutex.RUnlock()
	return len(fake.finishedArgsForCall)
}

func (fake *FakeCheckDelegate) FinishedCalls(stub func(lager.Logger, bool)) {
	fake.finishedMutex.Lock()
	defer fake.finishedMutex.Unlock()
	fake.FinishedStub = stub
}

func (fake *FakeCheckDelegate) FinishedArgsForCall(i int) (lager.Logger, bool) {
	fake.finishedMutex.RLock()
	defer fake.finishedMutex.RUnlock()
	argsForCall := fake.finishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCheckDelegate) Initializing(arg1 lager.Logger) {
	fake.initializingMutex.Lock()
	fake.initializingArgsForCall = append(fake.initializingArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.InitializingStub
	fake.recordInvocation("Initializing", []interface{}{arg1})
	fake.initializingMutex.Unlock()
	if stub != nil {
		fake.InitializingStub(arg1)
	}
}

func (fake *FakeCheckDelegate) InitializingCallCount() int {
	fake.initializingMutex.RLock()
	defer fake.initializingMutex.RUnlock()
	return len(fake.initializingArgsForCall)
}

func (fake *FakeCheckDelegate) InitializingCalls(stub func(lager.Logger)) {
	fake.initializingMutex.Lock()
	defer fake.initializingMutex.Unlock()
	fake.InitializingStub = stub
}

func (fake *FakeCheckDelegate) InitializingArgsForCall(i int) lager.Logger {
	fake.initializingMutex.RLock()
	defer fake.initializingMutex.RUnlock()
	argsForCall := fake.initializingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheckDelegate) PointToCheckedConfig(arg1 db.ResourceConfigScope) error {
	fake.pointToCheckedConfigMutex.Lock()
	ret, specificReturn := fake.pointToCheckedConfigReturnsOnCall[len(fake.pointToCheckedConfigArgsForCall)]
	fake.pointToCheckedConfigArgsForCall = append(fake.pointToCheckedConfigArgsForCall, struct {
		arg1 db.ResourceConfigScope
	}{arg1})
	stub := fake.PointToCheckedConfigStub
	fakeReturns := fake.pointToCheckedConfigReturns
	fake.recordInvocation("PointToCheckedConfig", []interface{}{arg1})
	fake.pointToCheckedConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCheckDelegate) PointToCheckedConfigCallCount() int {
	fake.pointToCheckedConfigMutex.RLock()
	defer fake.pointToCheckedConfigMutex.RUnlock()
	return len(fake.pointToCheckedConfigArgsForCall)
}

func (fake *FakeCheckDelegate) PointToCheckedConfigCalls(stub func(db.ResourceConfigScope) error) {
	fake.pointToCheckedConfigMutex.Lock()
	defer fake.pointToCheckedConfigMutex.Unlock()
	fake.PointToCheckedConfigStub = stub
}

func (fake *FakeCheckDelegate) PointToCheckedConfigArgsForCall(i int) db.ResourceConfigScope {
	fake.pointToCheckedConfigMutex.RLock()
	defer fake.pointToCheckedConfigMutex.RUnlock()
	argsForCall := fake.pointToCheckedConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheckDelegate) PointToCheckedConfigReturns(result1 error) {
	fake.pointToCheckedConfigMutex.Lock()
	defer fake.pointToCheckedConfigMutex.Unlock()
	fake.PointToCheckedConfigStub = nil
	fake.pointToCheckedConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheckDelegate) PointToCheckedConfigReturnsOnCall(i int, result1 error) {
	fake.pointToCheckedConfigMutex.Lock()
	defer fake.pointToCheckedConfigMutex.Unlock()
	fake.PointToCheckedConfigStub = nil
	if fake.pointToCheckedConfigReturnsOnCall == nil {
		fake.pointToCheckedConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pointToCheckedConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheckDelegate) SelectedWorker(arg1 lager.Logger, arg2 string) {
	fake.selectedWorkerMutex.Lock()
	fake.selectedWorkerArgsForCall = append(fake.selectedWorkerArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.SelectedWorkerStub
	fake.recordInvocation("SelectedWorker", []interface{}{arg1, arg2})
	fake.selectedWorkerMutex.Unlock()
	if stub != nil {
		fake.SelectedWorkerStub(arg1, arg2)
	}
}

func (fake *FakeCheckDelegate) SelectedWorkerCallCount() int {
	fake.selectedWorkerMutex.RLock()
	defer fake.selectedWorkerMutex.RUnlock()
	return len(fake.selectedWorkerArgsForCall)
}

func (fake *FakeCheckDelegate) SelectedWorkerCalls(stub func(lager.Logger, string)) {
	fake.selectedWorkerMutex.Lock()
	defer fake.selectedWorkerMutex.Unlock()
	fake.SelectedWorkerStub = stub
}

func (fake *FakeCheckDelegate) SelectedWorkerArgsForCall(i int) (lager.Logger, string) {
	fake.selectedWorkerMutex.RLock()
	defer fake.selectedWorkerMutex.RUnlock()
	argsForCall := fake.selectedWorkerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCheckDelegate) StartSpan(arg1 context.Context, arg2 string, arg3 tracing.Attrs) (context.Context, trace.Span) {
	fake.startSpanMutex.Lock()
	ret, specificReturn := fake.startSpanReturnsOnCall[len(fake.startSpanArgsForCall)]
	fake.startSpanArgsForCall = append(fake.startSpanArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 tracing.Attrs
	}{arg1, arg2, arg3})
	stub := fake.StartSpanStub
	fakeReturns := fake.startSpanReturns
	fake.recordInvocation("StartSpan", []interface{}{arg1, arg2, arg3})
	fake.startSpanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCheckDelegate) StartSpanCallCount() int {
	fake.startSpanMutex.RLock()
	defer fake.startSpanMutex.RUnlock()
	return len(fake.startSpanArgsForCall)
}

func (fake *FakeCheckDelegate) StartSpanCalls(stub func(context.Context, string, tracing.Attrs) (context.Context, trace.Span)) {
	fake.startSpanMutex.Lock()
	defer fake.startSpanMutex.Unlock()
	fake.StartSpanStub = stub
}

func (fake *FakeCheckDelegate) StartSpanArgsForCall(i int) (context.Context, string, tracing.Attrs) {
	fake.startSpanMutex.RLock()
	defer fake.startSpanMutex.RUnlock()
	argsForCall := fake.startSpanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCheckDelegate) StartSpanReturns(result1 context.Context, result2 trace.Span) {
	fake.startSpanMutex.Lock()
	defer fake.startSpanMutex.Unlock()
	fake.StartSpanStub = nil
	fake.startSpanReturns = struct {
		result1 context.Context
		result2 trace.Span
	}{result1, result2}
}

func (fake *FakeCheckDelegate) StartSpanReturnsOnCall(i int, result1 context.Context, result2 trace.Span) {
	fake.startSpanMutex.Lock()
	defer fake.startSpanMutex.Unlock()
	fake.StartSpanStub = nil
	if fake.startSpanReturnsOnCall == nil {
		fake.startSpanReturnsOnCall = make(map[int]struct {
			result1 context.Context
			result2 trace.Span
		})
	}
	fake.startSpanReturnsOnCall[i] = struct {
		result1 context.Context
		result2 trace.Span
	}{result1, result2}
}

func (fake *FakeCheckDelegate) Starting(arg1 lager.Logger) {
	fake.startingMutex.Lock()
	fake.startingArgsForCall = append(fake.startingArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.StartingStub
	fake.recordInvocation("Starting", []interface{}{arg1})
	fake.startingMutex.Unlock()
	if stub != nil {
		fake.StartingStub(arg1)
	}
}

func (fake *FakeCheckDelegate) StartingCallCount() int {
	fake.startingMutex.RLock()
	defer fake.startingMutex.RUnlock()
	return len(fake.startingArgsForCall)
}

func (fake *FakeCheckDelegate) StartingCalls(stub func(lager.Logger)) {
	fake.startingMutex.Lock()
	defer fake.startingMutex.Unlock()
	fake.StartingStub = stub
}

func (fake *FakeCheckDelegate) StartingArgsForCall(i int) lager.Logger {
	fake.startingMutex.RLock()
	defer fake.startingMutex.RUnlock()
	argsForCall := fake.startingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheckDelegate) Stderr() io.Writer {
	fake.stderrMutex.Lock()
	ret, specificReturn := fake.stderrReturnsOnCall[len(fake.stderrArgsForCall)]
	fake.stderrArgsForCall = append(fake.stderrArgsForCall, struct {
	}{})
	stub := fake.StderrStub
	fakeReturns := fake.stderrReturns
	fake.recordInvocation("Stderr", []interface{}{})
	fake.stderrMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCheckDelegate) StderrCallCount() int {
	fake.stderrMutex.RLock()
	defer fake.stderrMutex.RUnlock()
	return len(fake.stderrArgsForCall)
}

func (fake *FakeCheckDelegate) StderrCalls(stub func() io.Writer) {
	fake.stderrMutex.Lock()
	defer fake.stderrMutex.Unlock()
	fake.StderrStub = stub
}

func (fake *FakeCheckDelegate) StderrReturns(result1 io.Writer) {
	fake.stderrMutex.Lock()
	defer fake.stderrMutex.Unlock()
	fake.StderrStub = nil
	fake.stderrReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeCheckDelegate) StderrReturnsOnCall(i int, result1 io.Writer) {
	fake.stderrMutex.Lock()
	defer fake.stderrMutex.Unlock()
	fake.StderrStub = nil
	if fake.stderrReturnsOnCall == nil {
		fake.stderrReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.stderrReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeCheckDelegate) Stdout() io.Writer {
	fake.stdoutMutex.Lock()
	ret, specificReturn := fake.stdoutReturnsOnCall[len(fake.stdoutArgsForCall)]
	fake.stdoutArgsForCall = append(fake.stdoutArgsForCall, struct {
	}{})
	stub := fake.StdoutStub
	fakeReturns := fake.stdoutReturns
	fake.recordInvocation("Stdout", []interface{}{})
	fake.stdoutMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCheckDelegate) StdoutCallCount() int {
	fake.stdoutMutex.RLock()
	defer fake.stdoutMutex.RUnlock()
	return len(fake.stdoutArgsForCall)
}

func (fake *FakeCheckDelegate) StdoutCalls(stub func() io.Writer) {
	fake.stdoutMutex.Lock()
	defer fake.stdoutMutex.Unlock()
	fake.StdoutStub = stub
}

func (fake *FakeCheckDelegate) StdoutReturns(result1 io.Writer) {
	fake.stdoutMutex.Lock()
	defer fake.stdoutMutex.Unlock()
	fake.StdoutStub = nil
	fake.stdoutReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeCheckDelegate) StdoutReturnsOnCall(i int, result1 io.Writer) {
	fake.stdoutMutex.Lock()
	defer fake.stdoutMutex.Unlock()
	fake.StdoutStub = nil
	if fake.stdoutReturnsOnCall == nil {
		fake.stdoutReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.stdoutReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeCheckDelegate) StreamingVolume(arg1 lager.Logger, arg2 string, arg3 string, arg4 string) {
	fake.streamingVolumeMutex.Lock()
	fake.streamingVolumeArgsForCall = append(fake.streamingVolumeArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.StreamingVolumeStub
	fake.recordInvocation("StreamingVolume", []interface{}{arg1, arg2, arg3, arg4})
	fake.streamingVolumeMutex.Unlock()
	if stub != nil {
		fake.StreamingVolumeStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeCheckDelegate) StreamingVolumeCallCount() int {
	fake.streamingVolumeMutex.RLock()
	defer fake.streamingVolumeMutex.RUnlock()
	return len(fake.streamingVolumeArgsForCall)
}

func (fake *FakeCheckDelegate) StreamingVolumeCalls(stub func(lager.Logger, string, string, string)) {
	fake.streamingVolumeMutex.Lock()
	defer fake.streamingVolumeMutex.Unlock()
	fake.StreamingVolumeStub = stub
}

func (fake *FakeCheckDelegate) StreamingVolumeArgsForCall(i int) (lager.Logger, string, string, string) {
	fake.streamingVolumeMutex.RLock()
	defer fake.streamingVolumeMutex.RUnlock()
	argsForCall := fake.streamingVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckEndTime(arg1 db.ResourceConfigScope, arg2 bool) (bool, error) {
	fake.updateScopeLastCheckEndTimeMutex.Lock()
	ret, specificReturn := fake.updateScopeLastCheckEndTimeReturnsOnCall[len(fake.updateScopeLastCheckEndTimeArgsForCall)]
	fake.updateScopeLastCheckEndTimeArgsForCall = append(fake.updateScopeLastCheckEndTimeArgsForCall, struct {
		arg1 db.ResourceConfigScope
		arg2 bool
	}{arg1, arg2})
	stub := fake.UpdateScopeLastCheckEndTimeStub
	fakeReturns := fake.updateScopeLastCheckEndTimeReturns
	fake.recordInvocation("UpdateScopeLastCheckEndTime", []interface{}{arg1, arg2})
	fake.updateScopeLastCheckEndTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckEndTimeCallCount() int {
	fake.updateScopeLastCheckEndTimeMutex.RLock()
	defer fake.updateScopeLastCheckEndTimeMutex.RUnlock()
	return len(fake.updateScopeLastCheckEndTimeArgsForCall)
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckEndTimeCalls(stub func(db.ResourceConfigScope, bool) (bool, error)) {
	fake.updateScopeLastCheckEndTimeMutex.Lock()
	defer fake.updateScopeLastCheckEndTimeMutex.Unlock()
	fake.UpdateScopeLastCheckEndTimeStub = stub
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckEndTimeArgsForCall(i int) (db.ResourceConfigScope, bool) {
	fake.updateScopeLastCheckEndTimeMutex.RLock()
	defer fake.updateScopeLastCheckEndTimeMutex.RUnlock()
	argsForCall := fake.updateScopeLastCheckEndTimeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckEndTimeReturns(result1 bool, result2 error) {
	fake.updateScopeLastCheckEndTimeMutex.Lock()
	defer fake.updateScopeLastCheckEndTimeMutex.Unlock()
	fake.UpdateScopeLastCheckEndTimeStub = nil
	fake.updateScopeLastCheckEndTimeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckEndTimeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateScopeLastCheckEndTimeMutex.Lock()
	defer fake.updateScopeLastCheckEndTimeMutex.Unlock()
	fake.UpdateScopeLastCheckEndTimeStub = nil
	if fake.updateScopeLastCheckEndTimeReturnsOnCall == nil {
		fake.updateScopeLastCheckEndTimeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateScopeLastCheckEndTimeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckStartTime(arg1 db.ResourceConfigScope, arg2 bool) (bool, int, error) {
	fake.updateScopeLastCheckStartTimeMutex.Lock()
	ret, specificReturn := fake.updateScopeLastCheckStartTimeReturnsOnCall[len(fake.updateScopeLastCheckStartTimeArgsForCall)]
	fake.updateScopeLastCheckStartTimeArgsForCall = append(fake.updateScopeLastCheckStartTimeArgsForCall, struct {
		arg1 db.ResourceConfigScope
		arg2 bool
	}{arg1, arg2})
	stub := fake.UpdateScopeLastCheckStartTimeStub
	fakeReturns := fake.updateScopeLastCheckStartTimeReturns
	fake.recordInvocation("UpdateScopeLastCheckStartTime", []interface{}{arg1, arg2})
	fake.updateScopeLastCheckStartTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckStartTimeCallCount() int {
	fake.updateScopeLastCheckStartTimeMutex.RLock()
	defer fake.updateScopeLastCheckStartTimeMutex.RUnlock()
	return len(fake.updateScopeLastCheckStartTimeArgsForCall)
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckStartTimeCalls(stub func(db.ResourceConfigScope, bool) (bool, int, error)) {
	fake.updateScopeLastCheckStartTimeMutex.Lock()
	defer fake.updateScopeLastCheckStartTimeMutex.Unlock()
	fake.UpdateScopeLastCheckStartTimeStub = stub
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckStartTimeArgsForCall(i int) (db.ResourceConfigScope, bool) {
	fake.updateScopeLastCheckStartTimeMutex.RLock()
	defer fake.updateScopeLastCheckStartTimeMutex.RUnlock()
	argsForCall := fake.updateScopeLastCheckStartTimeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckStartTimeReturns(result1 bool, result2 int, result3 error) {
	fake.updateScopeLastCheckStartTimeMutex.Lock()
	defer fake.updateScopeLastCheckStartTimeMutex.Unlock()
	fake.UpdateScopeLastCheckStartTimeStub = nil
	fake.updateScopeLastCheckStartTimeReturns = struct {
		result1 bool
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheckDelegate) UpdateScopeLastCheckStartTimeReturnsOnCall(i int, result1 bool, result2 int, result3 error) {
	fake.updateScopeLastCheckStartTimeMutex.Lock()
	defer fake.updateScopeLastCheckStartTimeMutex.Unlock()
	fake.UpdateScopeLastCheckStartTimeStub = nil
	if fake.updateScopeLastCheckStartTimeReturnsOnCall == nil {
		fake.updateScopeLastCheckStartTimeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 int
			result3 error
		})
	}
	fake.updateScopeLastCheckStartTimeReturnsOnCall[i] = struct {
		result1 bool
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheckDelegate) WaitToRun(arg1 context.Context, arg2 db.ResourceConfigScope) (lock.Lock, bool, error) {
	fake.waitToRunMutex.Lock()
	ret, specificReturn := fake.waitToRunReturnsOnCall[len(fake.waitToRunArgsForCall)]
	fake.waitToRunArgsForCall = append(fake.waitToRunArgsForCall, struct {
		arg1 context.Context
		arg2 db.ResourceConfigScope
	}{arg1, arg2})
	stub := fake.WaitToRunStub
	fakeReturns := fake.waitToRunReturns
	fake.recordInvocation("WaitToRun", []interface{}{arg1, arg2})
	fake.waitToRunMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCheckDelegate) WaitToRunCallCount() int {
	fake.waitToRunMutex.RLock()
	defer fake.waitToRunMutex.RUnlock()
	return len(fake.waitToRunArgsForCall)
}

func (fake *FakeCheckDelegate) WaitToRunCalls(stub func(context.Context, db.ResourceConfigScope) (lock.Lock, bool, error)) {
	fake.waitToRunMutex.Lock()
	defer fake.waitToRunMutex.Unlock()
	fake.WaitToRunStub = stub
}

func (fake *FakeCheckDelegate) WaitToRunArgsForCall(i int) (context.Context, db.ResourceConfigScope) {
	fake.waitToRunMutex.RLock()
	defer fake.waitToRunMutex.RUnlock()
	argsForCall := fake.waitToRunArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCheckDelegate) WaitToRunReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.waitToRunMutex.Lock()
	defer fake.waitToRunMutex.Unlock()
	fake.WaitToRunStub = nil
	fake.waitToRunReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheckDelegate) WaitToRunReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.waitToRunMutex.Lock()
	defer fake.waitToRunMutex.Unlock()
	fake.WaitToRunStub = nil
	if fake.waitToRunReturnsOnCall == nil {
		fake.waitToRunReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.waitToRunReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheckDelegate) WaitingForStreamedVolume(arg1 lager.Logger, arg2 string, arg3 string) {
	fake.waitingForStreamedVolumeMutex.Lock()
	fake.waitingForStreamedVolumeArgsForCall = append(fake.waitingForStreamedVolumeArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.WaitingForStreamedVolumeStub
	fake.recordInvocation("WaitingForStreamedVolume", []interface{}{arg1, arg2, arg3})
	fake.waitingForStreamedVolumeMutex.Unlock()
	if stub != nil {
		fake.WaitingForStreamedVolumeStub(arg1, arg2, arg3)
	}
}

func (fake *FakeCheckDelegate) WaitingForStreamedVolumeCallCount() int {
	fake.waitingForStreamedVolumeMutex.RLock()
	defer fake.waitingForStreamedVolumeMutex.RUnlock()
	return len(fake.waitingForStreamedVolumeArgsForCall)
}

func (fake *FakeCheckDelegate) WaitingForStreamedVolumeCalls(stub func(lager.Logger, string, string)) {
	fake.waitingForStreamedVolumeMutex.Lock()
	defer fake.waitingForStreamedVolumeMutex.Unlock()
	fake.WaitingForStreamedVolumeStub = stub
}

func (fake *FakeCheckDelegate) WaitingForStreamedVolumeArgsForCall(i int) (lager.Logger, string, string) {
	fake.waitingForStreamedVolumeMutex.RLock()
	defer fake.waitingForStreamedVolumeMutex.RUnlock()
	argsForCall := fake.waitingForStreamedVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCheckDelegate) WaitingForWorker(arg1 lager.Logger) {
	fake.waitingForWorkerMutex.Lock()
	fake.waitingForWorkerArgsForCall = append(fake.waitingForWorkerArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.WaitingForWorkerStub
	fake.recordInvocation("WaitingForWorker", []interface{}{arg1})
	fake.waitingForWorkerMutex.Unlock()
	if stub != nil {
		fake.WaitingForWorkerStub(arg1)
	}
}

func (fake *FakeCheckDelegate) WaitingForWorkerCallCount() int {
	fake.waitingForWorkerMutex.RLock()
	defer fake.waitingForWorkerMutex.RUnlock()
	return len(fake.waitingForWorkerArgsForCall)
}

func (fake *FakeCheckDelegate) WaitingForWorkerCalls(stub func(lager.Logger)) {
	fake.waitingForWorkerMutex.Lock()
	defer fake.waitingForWorkerMutex.Unlock()
	fake.WaitingForWorkerStub = stub
}

func (fake *FakeCheckDelegate) WaitingForWorkerArgsForCall(i int) lager.Logger {
	fake.waitingForWorkerMutex.RLock()
	defer fake.waitingForWorkerMutex.RUnlock()
	argsForCall := fake.waitingForWorkerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheckDelegate) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.beforeSelectWorkerMutex.RLock()
	defer fake.beforeSelectWorkerMutex.RUnlock()
	fake.buildStartTimeMutex.RLock()
	defer fake.buildStartTimeMutex.RUnlock()
	fake.constructAcrossSubstepsMutex.RLock()
	defer fake.constructAcrossSubstepsMutex.RUnlock()
	fake.containerOwnerMutex.RLock()
	defer fake.containerOwnerMutex.RUnlock()
	fake.erroredMutex.RLock()
	defer fake.erroredMutex.RUnlock()
	fake.fetchImageMutex.RLock()
	defer fake.fetchImageMutex.RUnlock()
	fake.findOrCreateScopeMutex.RLock()
	defer fake.findOrCreateScopeMutex.RUnlock()
	fake.finishedMutex.RLock()
	defer fake.finishedMutex.RUnlock()
	fake.initializingMutex.RLock()
	defer fake.initializingMutex.RUnlock()
	fake.pointToCheckedConfigMutex.RLock()
	defer fake.pointToCheckedConfigMutex.RUnlock()
	fake.selectedWorkerMutex.RLock()
	defer fake.selectedWorkerMutex.RUnlock()
	fake.startSpanMutex.RLock()
	defer fake.startSpanMutex.RUnlock()
	fake.startingMutex.RLock()
	defer fake.startingMutex.RUnlock()
	fake.stderrMutex.RLock()
	defer fake.stderrMutex.RUnlock()
	fake.stdoutMutex.RLock()
	defer fake.stdoutMutex.RUnlock()
	fake.streamingVolumeMutex.RLock()
	defer fake.streamingVolumeMutex.RUnlock()
	fake.updateScopeLastCheckEndTimeMutex.RLock()
	defer fake.updateScopeLastCheckEndTimeMutex.RUnlock()
	fake.updateScopeLastCheckStartTimeMutex.RLock()
	defer fake.updateScopeLastCheckStartTimeMutex.RUnlock()
	fake.waitToRunMutex.RLock()
	defer fake.waitToRunMutex.RUnlock()
	fake.waitingForStreamedVolumeMutex.RLock()
	defer fake.waitingForStreamedVolumeMutex.RUnlock()
	fake.waitingForWorkerMutex.RLock()
	defer fake.waitingForWorkerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCheckDelegate) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ exec.CheckDelegate = new(FakeCheckDelegate)
