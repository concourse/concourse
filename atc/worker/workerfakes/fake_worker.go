// Code generated by counterfeiter. DO NOT EDIT.
package workerfakes

import (
	"context"
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/resource"
	"github.com/concourse/concourse/atc/runtime"
	"github.com/concourse/concourse/atc/worker"
	"github.com/concourse/concourse/atc/worker/gclient"
	"github.com/cppforlife/go-semi-semantic/version"
)

type FakeWorker struct {
	ActiveTasksStub        func() (int, error)
	activeTasksMutex       sync.RWMutex
	activeTasksArgsForCall []struct {
	}
	activeTasksReturns struct {
		result1 int
		result2 error
	}
	activeTasksReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	BuildContainersStub        func() int
	buildContainersMutex       sync.RWMutex
	buildContainersArgsForCall []struct {
	}
	buildContainersReturns struct {
		result1 int
	}
	buildContainersReturnsOnCall map[int]struct {
		result1 int
	}
	CertsVolumeStub        func(lager.Logger) (worker.Volume, bool, error)
	certsVolumeMutex       sync.RWMutex
	certsVolumeArgsForCall []struct {
		arg1 lager.Logger
	}
	certsVolumeReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	certsVolumeReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	CreateVolumeStub        func(lager.Logger, worker.VolumeSpec, int, db.VolumeType) (worker.Volume, error)
	createVolumeMutex       sync.RWMutex
	createVolumeArgsForCall []struct {
		arg1 lager.Logger
		arg2 worker.VolumeSpec
		arg3 int
		arg4 db.VolumeType
	}
	createVolumeReturns struct {
		result1 worker.Volume
		result2 error
	}
	createVolumeReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 error
	}
	DecreaseActiveTasksStub        func() error
	decreaseActiveTasksMutex       sync.RWMutex
	decreaseActiveTasksArgsForCall []struct {
	}
	decreaseActiveTasksReturns struct {
		result1 error
	}
	decreaseActiveTasksReturnsOnCall map[int]struct {
		result1 error
	}
	DescriptionStub        func() string
	descriptionMutex       sync.RWMutex
	descriptionArgsForCall []struct {
	}
	descriptionReturns struct {
		result1 string
	}
	descriptionReturnsOnCall map[int]struct {
		result1 string
	}
	EphemeralStub        func() bool
	ephemeralMutex       sync.RWMutex
	ephemeralArgsForCall []struct {
	}
	ephemeralReturns struct {
		result1 bool
	}
	ephemeralReturnsOnCall map[int]struct {
		result1 bool
	}
	FetchStub        func(context.Context, lager.Logger, db.ContainerMetadata, worker.Worker, worker.ContainerSpec, runtime.ProcessSpec, resource.Resource, atc.VersionedResourceTypes, db.ContainerOwner, string, worker.ImageFetchingDelegate, db.UsedResourceCache, string) (worker.GetResult, worker.Volume, error)
	fetchMutex       sync.RWMutex
	fetchArgsForCall []struct {
		arg1  context.Context
		arg2  lager.Logger
		arg3  db.ContainerMetadata
		arg4  worker.Worker
		arg5  worker.ContainerSpec
		arg6  runtime.ProcessSpec
		arg7  resource.Resource
		arg8  atc.VersionedResourceTypes
		arg9  db.ContainerOwner
		arg10 string
		arg11 worker.ImageFetchingDelegate
		arg12 db.UsedResourceCache
		arg13 string
	}
	fetchReturns struct {
		result1 worker.GetResult
		result2 worker.Volume
		result3 error
	}
	fetchReturnsOnCall map[int]struct {
		result1 worker.GetResult
		result2 worker.Volume
		result3 error
	}
	FindContainerByHandleStub        func(lager.Logger, int, string) (worker.Container, bool, error)
	findContainerByHandleMutex       sync.RWMutex
	findContainerByHandleArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
		arg3 string
	}
	findContainerByHandleReturns struct {
		result1 worker.Container
		result2 bool
		result3 error
	}
	findContainerByHandleReturnsOnCall map[int]struct {
		result1 worker.Container
		result2 bool
		result3 error
	}
	FindOrCreateContainerStub        func(context.Context, lager.Logger, worker.ImageFetchingDelegate, db.ContainerOwner, db.ContainerMetadata, worker.ContainerSpec, atc.VersionedResourceTypes) (worker.Container, error)
	findOrCreateContainerMutex       sync.RWMutex
	findOrCreateContainerArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 worker.ImageFetchingDelegate
		arg4 db.ContainerOwner
		arg5 db.ContainerMetadata
		arg6 worker.ContainerSpec
		arg7 atc.VersionedResourceTypes
	}
	findOrCreateContainerReturns struct {
		result1 worker.Container
		result2 error
	}
	findOrCreateContainerReturnsOnCall map[int]struct {
		result1 worker.Container
		result2 error
	}
	FindVolumeForResourceCacheStub        func(lager.Logger, db.UsedResourceCache) (worker.Volume, bool, error)
	findVolumeForResourceCacheMutex       sync.RWMutex
	findVolumeForResourceCacheArgsForCall []struct {
		arg1 lager.Logger
		arg2 db.UsedResourceCache
	}
	findVolumeForResourceCacheReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	findVolumeForResourceCacheReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	FindVolumeForTaskCacheStub        func(lager.Logger, int, int, string, string) (worker.Volume, bool, error)
	findVolumeForTaskCacheMutex       sync.RWMutex
	findVolumeForTaskCacheArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
		arg3 int
		arg4 string
		arg5 string
	}
	findVolumeForTaskCacheReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	findVolumeForTaskCacheReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	GardenClientStub        func() gclient.Client
	gardenClientMutex       sync.RWMutex
	gardenClientArgsForCall []struct {
	}
	gardenClientReturns struct {
		result1 gclient.Client
	}
	gardenClientReturnsOnCall map[int]struct {
		result1 gclient.Client
	}
	IncreaseActiveTasksStub        func() error
	increaseActiveTasksMutex       sync.RWMutex
	increaseActiveTasksArgsForCall []struct {
	}
	increaseActiveTasksReturns struct {
		result1 error
	}
	increaseActiveTasksReturnsOnCall map[int]struct {
		result1 error
	}
	IsOwnedByTeamStub        func() bool
	isOwnedByTeamMutex       sync.RWMutex
	isOwnedByTeamArgsForCall []struct {
	}
	isOwnedByTeamReturns struct {
		result1 bool
	}
	isOwnedByTeamReturnsOnCall map[int]struct {
		result1 bool
	}
	IsVersionCompatibleStub        func(lager.Logger, version.Version) bool
	isVersionCompatibleMutex       sync.RWMutex
	isVersionCompatibleArgsForCall []struct {
		arg1 lager.Logger
		arg2 version.Version
	}
	isVersionCompatibleReturns struct {
		result1 bool
	}
	isVersionCompatibleReturnsOnCall map[int]struct {
		result1 bool
	}
	LookupVolumeStub        func(lager.Logger, string) (worker.Volume, bool, error)
	lookupVolumeMutex       sync.RWMutex
	lookupVolumeArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	lookupVolumeReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	lookupVolumeReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ResourceTypesStub        func() []atc.WorkerResourceType
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct {
	}
	resourceTypesReturns struct {
		result1 []atc.WorkerResourceType
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 []atc.WorkerResourceType
	}
	SatisfiesStub        func(lager.Logger, worker.WorkerSpec) bool
	satisfiesMutex       sync.RWMutex
	satisfiesArgsForCall []struct {
		arg1 lager.Logger
		arg2 worker.WorkerSpec
	}
	satisfiesReturns struct {
		result1 bool
	}
	satisfiesReturnsOnCall map[int]struct {
		result1 bool
	}
	TagsStub        func() atc.Tags
	tagsMutex       sync.RWMutex
	tagsArgsForCall []struct {
	}
	tagsReturns struct {
		result1 atc.Tags
	}
	tagsReturnsOnCall map[int]struct {
		result1 atc.Tags
	}
	UptimeStub        func() time.Duration
	uptimeMutex       sync.RWMutex
	uptimeArgsForCall []struct {
	}
	uptimeReturns struct {
		result1 time.Duration
	}
	uptimeReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorker) ActiveTasks() (int, error) {
	fake.activeTasksMutex.Lock()
	ret, specificReturn := fake.activeTasksReturnsOnCall[len(fake.activeTasksArgsForCall)]
	fake.activeTasksArgsForCall = append(fake.activeTasksArgsForCall, struct {
	}{})
	fake.recordInvocation("ActiveTasks", []interface{}{})
	fake.activeTasksMutex.Unlock()
	if fake.ActiveTasksStub != nil {
		return fake.ActiveTasksStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.activeTasksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) ActiveTasksCallCount() int {
	fake.activeTasksMutex.RLock()
	defer fake.activeTasksMutex.RUnlock()
	return len(fake.activeTasksArgsForCall)
}

func (fake *FakeWorker) ActiveTasksCalls(stub func() (int, error)) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = stub
}

func (fake *FakeWorker) ActiveTasksReturns(result1 int, result2 error) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = nil
	fake.activeTasksReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ActiveTasksReturnsOnCall(i int, result1 int, result2 error) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = nil
	if fake.activeTasksReturnsOnCall == nil {
		fake.activeTasksReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.activeTasksReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) BuildContainers() int {
	fake.buildContainersMutex.Lock()
	ret, specificReturn := fake.buildContainersReturnsOnCall[len(fake.buildContainersArgsForCall)]
	fake.buildContainersArgsForCall = append(fake.buildContainersArgsForCall, struct {
	}{})
	fake.recordInvocation("BuildContainers", []interface{}{})
	fake.buildContainersMutex.Unlock()
	if fake.BuildContainersStub != nil {
		return fake.BuildContainersStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.buildContainersReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) BuildContainersCallCount() int {
	fake.buildContainersMutex.RLock()
	defer fake.buildContainersMutex.RUnlock()
	return len(fake.buildContainersArgsForCall)
}

func (fake *FakeWorker) BuildContainersCalls(stub func() int) {
	fake.buildContainersMutex.Lock()
	defer fake.buildContainersMutex.Unlock()
	fake.BuildContainersStub = stub
}

func (fake *FakeWorker) BuildContainersReturns(result1 int) {
	fake.buildContainersMutex.Lock()
	defer fake.buildContainersMutex.Unlock()
	fake.BuildContainersStub = nil
	fake.buildContainersReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) BuildContainersReturnsOnCall(i int, result1 int) {
	fake.buildContainersMutex.Lock()
	defer fake.buildContainersMutex.Unlock()
	fake.BuildContainersStub = nil
	if fake.buildContainersReturnsOnCall == nil {
		fake.buildContainersReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.buildContainersReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) CertsVolume(arg1 lager.Logger) (worker.Volume, bool, error) {
	fake.certsVolumeMutex.Lock()
	ret, specificReturn := fake.certsVolumeReturnsOnCall[len(fake.certsVolumeArgsForCall)]
	fake.certsVolumeArgsForCall = append(fake.certsVolumeArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("CertsVolume", []interface{}{arg1})
	fake.certsVolumeMutex.Unlock()
	if fake.CertsVolumeStub != nil {
		return fake.CertsVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.certsVolumeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) CertsVolumeCallCount() int {
	fake.certsVolumeMutex.RLock()
	defer fake.certsVolumeMutex.RUnlock()
	return len(fake.certsVolumeArgsForCall)
}

func (fake *FakeWorker) CertsVolumeCalls(stub func(lager.Logger) (worker.Volume, bool, error)) {
	fake.certsVolumeMutex.Lock()
	defer fake.certsVolumeMutex.Unlock()
	fake.CertsVolumeStub = stub
}

func (fake *FakeWorker) CertsVolumeArgsForCall(i int) lager.Logger {
	fake.certsVolumeMutex.RLock()
	defer fake.certsVolumeMutex.RUnlock()
	argsForCall := fake.certsVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorker) CertsVolumeReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.certsVolumeMutex.Lock()
	defer fake.certsVolumeMutex.Unlock()
	fake.CertsVolumeStub = nil
	fake.certsVolumeReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) CertsVolumeReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.certsVolumeMutex.Lock()
	defer fake.certsVolumeMutex.Unlock()
	fake.CertsVolumeStub = nil
	if fake.certsVolumeReturnsOnCall == nil {
		fake.certsVolumeReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.certsVolumeReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) CreateVolume(arg1 lager.Logger, arg2 worker.VolumeSpec, arg3 int, arg4 db.VolumeType) (worker.Volume, error) {
	fake.createVolumeMutex.Lock()
	ret, specificReturn := fake.createVolumeReturnsOnCall[len(fake.createVolumeArgsForCall)]
	fake.createVolumeArgsForCall = append(fake.createVolumeArgsForCall, struct {
		arg1 lager.Logger
		arg2 worker.VolumeSpec
		arg3 int
		arg4 db.VolumeType
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("CreateVolume", []interface{}{arg1, arg2, arg3, arg4})
	fake.createVolumeMutex.Unlock()
	if fake.CreateVolumeStub != nil {
		return fake.CreateVolumeStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) CreateVolumeCallCount() int {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return len(fake.createVolumeArgsForCall)
}

func (fake *FakeWorker) CreateVolumeCalls(stub func(lager.Logger, worker.VolumeSpec, int, db.VolumeType) (worker.Volume, error)) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = stub
}

func (fake *FakeWorker) CreateVolumeArgsForCall(i int) (lager.Logger, worker.VolumeSpec, int, db.VolumeType) {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	argsForCall := fake.createVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeWorker) CreateVolumeReturns(result1 worker.Volume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	fake.createVolumeReturns = struct {
		result1 worker.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) CreateVolumeReturnsOnCall(i int, result1 worker.Volume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	if fake.createVolumeReturnsOnCall == nil {
		fake.createVolumeReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 error
		})
	}
	fake.createVolumeReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) DecreaseActiveTasks() error {
	fake.decreaseActiveTasksMutex.Lock()
	ret, specificReturn := fake.decreaseActiveTasksReturnsOnCall[len(fake.decreaseActiveTasksArgsForCall)]
	fake.decreaseActiveTasksArgsForCall = append(fake.decreaseActiveTasksArgsForCall, struct {
	}{})
	fake.recordInvocation("DecreaseActiveTasks", []interface{}{})
	fake.decreaseActiveTasksMutex.Unlock()
	if fake.DecreaseActiveTasksStub != nil {
		return fake.DecreaseActiveTasksStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.decreaseActiveTasksReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) DecreaseActiveTasksCallCount() int {
	fake.decreaseActiveTasksMutex.RLock()
	defer fake.decreaseActiveTasksMutex.RUnlock()
	return len(fake.decreaseActiveTasksArgsForCall)
}

func (fake *FakeWorker) DecreaseActiveTasksCalls(stub func() error) {
	fake.decreaseActiveTasksMutex.Lock()
	defer fake.decreaseActiveTasksMutex.Unlock()
	fake.DecreaseActiveTasksStub = stub
}

func (fake *FakeWorker) DecreaseActiveTasksReturns(result1 error) {
	fake.decreaseActiveTasksMutex.Lock()
	defer fake.decreaseActiveTasksMutex.Unlock()
	fake.DecreaseActiveTasksStub = nil
	fake.decreaseActiveTasksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) DecreaseActiveTasksReturnsOnCall(i int, result1 error) {
	fake.decreaseActiveTasksMutex.Lock()
	defer fake.decreaseActiveTasksMutex.Unlock()
	fake.DecreaseActiveTasksStub = nil
	if fake.decreaseActiveTasksReturnsOnCall == nil {
		fake.decreaseActiveTasksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.decreaseActiveTasksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) Description() string {
	fake.descriptionMutex.Lock()
	ret, specificReturn := fake.descriptionReturnsOnCall[len(fake.descriptionArgsForCall)]
	fake.descriptionArgsForCall = append(fake.descriptionArgsForCall, struct {
	}{})
	fake.recordInvocation("Description", []interface{}{})
	fake.descriptionMutex.Unlock()
	if fake.DescriptionStub != nil {
		return fake.DescriptionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.descriptionReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) DescriptionCallCount() int {
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	return len(fake.descriptionArgsForCall)
}

func (fake *FakeWorker) DescriptionCalls(stub func() string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = stub
}

func (fake *FakeWorker) DescriptionReturns(result1 string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = nil
	fake.descriptionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) DescriptionReturnsOnCall(i int, result1 string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = nil
	if fake.descriptionReturnsOnCall == nil {
		fake.descriptionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.descriptionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Ephemeral() bool {
	fake.ephemeralMutex.Lock()
	ret, specificReturn := fake.ephemeralReturnsOnCall[len(fake.ephemeralArgsForCall)]
	fake.ephemeralArgsForCall = append(fake.ephemeralArgsForCall, struct {
	}{})
	fake.recordInvocation("Ephemeral", []interface{}{})
	fake.ephemeralMutex.Unlock()
	if fake.EphemeralStub != nil {
		return fake.EphemeralStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.ephemeralReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) EphemeralCallCount() int {
	fake.ephemeralMutex.RLock()
	defer fake.ephemeralMutex.RUnlock()
	return len(fake.ephemeralArgsForCall)
}

func (fake *FakeWorker) EphemeralCalls(stub func() bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = stub
}

func (fake *FakeWorker) EphemeralReturns(result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	fake.ephemeralReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) EphemeralReturnsOnCall(i int, result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	if fake.ephemeralReturnsOnCall == nil {
		fake.ephemeralReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ephemeralReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) Fetch(arg1 context.Context, arg2 lager.Logger, arg3 db.ContainerMetadata, arg4 worker.Worker, arg5 worker.ContainerSpec, arg6 runtime.ProcessSpec, arg7 resource.Resource, arg8 atc.VersionedResourceTypes, arg9 db.ContainerOwner, arg10 string, arg11 worker.ImageFetchingDelegate, arg12 db.UsedResourceCache, arg13 string) (worker.GetResult, worker.Volume, error) {
	fake.fetchMutex.Lock()
	ret, specificReturn := fake.fetchReturnsOnCall[len(fake.fetchArgsForCall)]
	fake.fetchArgsForCall = append(fake.fetchArgsForCall, struct {
		arg1  context.Context
		arg2  lager.Logger
		arg3  db.ContainerMetadata
		arg4  worker.Worker
		arg5  worker.ContainerSpec
		arg6  runtime.ProcessSpec
		arg7  resource.Resource
		arg8  atc.VersionedResourceTypes
		arg9  db.ContainerOwner
		arg10 string
		arg11 worker.ImageFetchingDelegate
		arg12 db.UsedResourceCache
		arg13 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13})
	fake.recordInvocation("Fetch", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13})
	fake.fetchMutex.Unlock()
	if fake.FetchStub != nil {
		return fake.FetchStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.fetchReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FetchCallCount() int {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	return len(fake.fetchArgsForCall)
}

func (fake *FakeWorker) FetchCalls(stub func(context.Context, lager.Logger, db.ContainerMetadata, worker.Worker, worker.ContainerSpec, runtime.ProcessSpec, resource.Resource, atc.VersionedResourceTypes, db.ContainerOwner, string, worker.ImageFetchingDelegate, db.UsedResourceCache, string) (worker.GetResult, worker.Volume, error)) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = stub
}

func (fake *FakeWorker) FetchArgsForCall(i int) (context.Context, lager.Logger, db.ContainerMetadata, worker.Worker, worker.ContainerSpec, runtime.ProcessSpec, resource.Resource, atc.VersionedResourceTypes, db.ContainerOwner, string, worker.ImageFetchingDelegate, db.UsedResourceCache, string) {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	argsForCall := fake.fetchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9, argsForCall.arg10, argsForCall.arg11, argsForCall.arg12, argsForCall.arg13
}

func (fake *FakeWorker) FetchReturns(result1 worker.GetResult, result2 worker.Volume, result3 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	fake.fetchReturns = struct {
		result1 worker.GetResult
		result2 worker.Volume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FetchReturnsOnCall(i int, result1 worker.GetResult, result2 worker.Volume, result3 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	if fake.fetchReturnsOnCall == nil {
		fake.fetchReturnsOnCall = make(map[int]struct {
			result1 worker.GetResult
			result2 worker.Volume
			result3 error
		})
	}
	fake.fetchReturnsOnCall[i] = struct {
		result1 worker.GetResult
		result2 worker.Volume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindContainerByHandle(arg1 lager.Logger, arg2 int, arg3 string) (worker.Container, bool, error) {
	fake.findContainerByHandleMutex.Lock()
	ret, specificReturn := fake.findContainerByHandleReturnsOnCall[len(fake.findContainerByHandleArgsForCall)]
	fake.findContainerByHandleArgsForCall = append(fake.findContainerByHandleArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("FindContainerByHandle", []interface{}{arg1, arg2, arg3})
	fake.findContainerByHandleMutex.Unlock()
	if fake.FindContainerByHandleStub != nil {
		return fake.FindContainerByHandleStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findContainerByHandleReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindContainerByHandleCallCount() int {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	return len(fake.findContainerByHandleArgsForCall)
}

func (fake *FakeWorker) FindContainerByHandleCalls(stub func(lager.Logger, int, string) (worker.Container, bool, error)) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = stub
}

func (fake *FakeWorker) FindContainerByHandleArgsForCall(i int) (lager.Logger, int, string) {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	argsForCall := fake.findContainerByHandleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorker) FindContainerByHandleReturns(result1 worker.Container, result2 bool, result3 error) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = nil
	fake.findContainerByHandleReturns = struct {
		result1 worker.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindContainerByHandleReturnsOnCall(i int, result1 worker.Container, result2 bool, result3 error) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = nil
	if fake.findContainerByHandleReturnsOnCall == nil {
		fake.findContainerByHandleReturnsOnCall = make(map[int]struct {
			result1 worker.Container
			result2 bool
			result3 error
		})
	}
	fake.findContainerByHandleReturnsOnCall[i] = struct {
		result1 worker.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindOrCreateContainer(arg1 context.Context, arg2 lager.Logger, arg3 worker.ImageFetchingDelegate, arg4 db.ContainerOwner, arg5 db.ContainerMetadata, arg6 worker.ContainerSpec, arg7 atc.VersionedResourceTypes) (worker.Container, error) {
	fake.findOrCreateContainerMutex.Lock()
	ret, specificReturn := fake.findOrCreateContainerReturnsOnCall[len(fake.findOrCreateContainerArgsForCall)]
	fake.findOrCreateContainerArgsForCall = append(fake.findOrCreateContainerArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 worker.ImageFetchingDelegate
		arg4 db.ContainerOwner
		arg5 db.ContainerMetadata
		arg6 worker.ContainerSpec
		arg7 atc.VersionedResourceTypes
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("FindOrCreateContainer", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.findOrCreateContainerMutex.Unlock()
	if fake.FindOrCreateContainerStub != nil {
		return fake.FindOrCreateContainerStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findOrCreateContainerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) FindOrCreateContainerCallCount() int {
	fake.findOrCreateContainerMutex.RLock()
	defer fake.findOrCreateContainerMutex.RUnlock()
	return len(fake.findOrCreateContainerArgsForCall)
}

func (fake *FakeWorker) FindOrCreateContainerCalls(stub func(context.Context, lager.Logger, worker.ImageFetchingDelegate, db.ContainerOwner, db.ContainerMetadata, worker.ContainerSpec, atc.VersionedResourceTypes) (worker.Container, error)) {
	fake.findOrCreateContainerMutex.Lock()
	defer fake.findOrCreateContainerMutex.Unlock()
	fake.FindOrCreateContainerStub = stub
}

func (fake *FakeWorker) FindOrCreateContainerArgsForCall(i int) (context.Context, lager.Logger, worker.ImageFetchingDelegate, db.ContainerOwner, db.ContainerMetadata, worker.ContainerSpec, atc.VersionedResourceTypes) {
	fake.findOrCreateContainerMutex.RLock()
	defer fake.findOrCreateContainerMutex.RUnlock()
	argsForCall := fake.findOrCreateContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeWorker) FindOrCreateContainerReturns(result1 worker.Container, result2 error) {
	fake.findOrCreateContainerMutex.Lock()
	defer fake.findOrCreateContainerMutex.Unlock()
	fake.FindOrCreateContainerStub = nil
	fake.findOrCreateContainerReturns = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindOrCreateContainerReturnsOnCall(i int, result1 worker.Container, result2 error) {
	fake.findOrCreateContainerMutex.Lock()
	defer fake.findOrCreateContainerMutex.Unlock()
	fake.FindOrCreateContainerStub = nil
	if fake.findOrCreateContainerReturnsOnCall == nil {
		fake.findOrCreateContainerReturnsOnCall = make(map[int]struct {
			result1 worker.Container
			result2 error
		})
	}
	fake.findOrCreateContainerReturnsOnCall[i] = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindVolumeForResourceCache(arg1 lager.Logger, arg2 db.UsedResourceCache) (worker.Volume, bool, error) {
	fake.findVolumeForResourceCacheMutex.Lock()
	ret, specificReturn := fake.findVolumeForResourceCacheReturnsOnCall[len(fake.findVolumeForResourceCacheArgsForCall)]
	fake.findVolumeForResourceCacheArgsForCall = append(fake.findVolumeForResourceCacheArgsForCall, struct {
		arg1 lager.Logger
		arg2 db.UsedResourceCache
	}{arg1, arg2})
	fake.recordInvocation("FindVolumeForResourceCache", []interface{}{arg1, arg2})
	fake.findVolumeForResourceCacheMutex.Unlock()
	if fake.FindVolumeForResourceCacheStub != nil {
		return fake.FindVolumeForResourceCacheStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findVolumeForResourceCacheReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindVolumeForResourceCacheCallCount() int {
	fake.findVolumeForResourceCacheMutex.RLock()
	defer fake.findVolumeForResourceCacheMutex.RUnlock()
	return len(fake.findVolumeForResourceCacheArgsForCall)
}

func (fake *FakeWorker) FindVolumeForResourceCacheCalls(stub func(lager.Logger, db.UsedResourceCache) (worker.Volume, bool, error)) {
	fake.findVolumeForResourceCacheMutex.Lock()
	defer fake.findVolumeForResourceCacheMutex.Unlock()
	fake.FindVolumeForResourceCacheStub = stub
}

func (fake *FakeWorker) FindVolumeForResourceCacheArgsForCall(i int) (lager.Logger, db.UsedResourceCache) {
	fake.findVolumeForResourceCacheMutex.RLock()
	defer fake.findVolumeForResourceCacheMutex.RUnlock()
	argsForCall := fake.findVolumeForResourceCacheArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) FindVolumeForResourceCacheReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForResourceCacheMutex.Lock()
	defer fake.findVolumeForResourceCacheMutex.Unlock()
	fake.FindVolumeForResourceCacheStub = nil
	fake.findVolumeForResourceCacheReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForResourceCacheReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForResourceCacheMutex.Lock()
	defer fake.findVolumeForResourceCacheMutex.Unlock()
	fake.FindVolumeForResourceCacheStub = nil
	if fake.findVolumeForResourceCacheReturnsOnCall == nil {
		fake.findVolumeForResourceCacheReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.findVolumeForResourceCacheReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForTaskCache(arg1 lager.Logger, arg2 int, arg3 int, arg4 string, arg5 string) (worker.Volume, bool, error) {
	fake.findVolumeForTaskCacheMutex.Lock()
	ret, specificReturn := fake.findVolumeForTaskCacheReturnsOnCall[len(fake.findVolumeForTaskCacheArgsForCall)]
	fake.findVolumeForTaskCacheArgsForCall = append(fake.findVolumeForTaskCacheArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
		arg3 int
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("FindVolumeForTaskCache", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.findVolumeForTaskCacheMutex.Unlock()
	if fake.FindVolumeForTaskCacheStub != nil {
		return fake.FindVolumeForTaskCacheStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findVolumeForTaskCacheReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindVolumeForTaskCacheCallCount() int {
	fake.findVolumeForTaskCacheMutex.RLock()
	defer fake.findVolumeForTaskCacheMutex.RUnlock()
	return len(fake.findVolumeForTaskCacheArgsForCall)
}

func (fake *FakeWorker) FindVolumeForTaskCacheCalls(stub func(lager.Logger, int, int, string, string) (worker.Volume, bool, error)) {
	fake.findVolumeForTaskCacheMutex.Lock()
	defer fake.findVolumeForTaskCacheMutex.Unlock()
	fake.FindVolumeForTaskCacheStub = stub
}

func (fake *FakeWorker) FindVolumeForTaskCacheArgsForCall(i int) (lager.Logger, int, int, string, string) {
	fake.findVolumeForTaskCacheMutex.RLock()
	defer fake.findVolumeForTaskCacheMutex.RUnlock()
	argsForCall := fake.findVolumeForTaskCacheArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeWorker) FindVolumeForTaskCacheReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForTaskCacheMutex.Lock()
	defer fake.findVolumeForTaskCacheMutex.Unlock()
	fake.FindVolumeForTaskCacheStub = nil
	fake.findVolumeForTaskCacheReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForTaskCacheReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForTaskCacheMutex.Lock()
	defer fake.findVolumeForTaskCacheMutex.Unlock()
	fake.FindVolumeForTaskCacheStub = nil
	if fake.findVolumeForTaskCacheReturnsOnCall == nil {
		fake.findVolumeForTaskCacheReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.findVolumeForTaskCacheReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) GardenClient() gclient.Client {
	fake.gardenClientMutex.Lock()
	ret, specificReturn := fake.gardenClientReturnsOnCall[len(fake.gardenClientArgsForCall)]
	fake.gardenClientArgsForCall = append(fake.gardenClientArgsForCall, struct {
	}{})
	fake.recordInvocation("GardenClient", []interface{}{})
	fake.gardenClientMutex.Unlock()
	if fake.GardenClientStub != nil {
		return fake.GardenClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.gardenClientReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) GardenClientCallCount() int {
	fake.gardenClientMutex.RLock()
	defer fake.gardenClientMutex.RUnlock()
	return len(fake.gardenClientArgsForCall)
}

func (fake *FakeWorker) GardenClientCalls(stub func() gclient.Client) {
	fake.gardenClientMutex.Lock()
	defer fake.gardenClientMutex.Unlock()
	fake.GardenClientStub = stub
}

func (fake *FakeWorker) GardenClientReturns(result1 gclient.Client) {
	fake.gardenClientMutex.Lock()
	defer fake.gardenClientMutex.Unlock()
	fake.GardenClientStub = nil
	fake.gardenClientReturns = struct {
		result1 gclient.Client
	}{result1}
}

func (fake *FakeWorker) GardenClientReturnsOnCall(i int, result1 gclient.Client) {
	fake.gardenClientMutex.Lock()
	defer fake.gardenClientMutex.Unlock()
	fake.GardenClientStub = nil
	if fake.gardenClientReturnsOnCall == nil {
		fake.gardenClientReturnsOnCall = make(map[int]struct {
			result1 gclient.Client
		})
	}
	fake.gardenClientReturnsOnCall[i] = struct {
		result1 gclient.Client
	}{result1}
}

func (fake *FakeWorker) IncreaseActiveTasks() error {
	fake.increaseActiveTasksMutex.Lock()
	ret, specificReturn := fake.increaseActiveTasksReturnsOnCall[len(fake.increaseActiveTasksArgsForCall)]
	fake.increaseActiveTasksArgsForCall = append(fake.increaseActiveTasksArgsForCall, struct {
	}{})
	fake.recordInvocation("IncreaseActiveTasks", []interface{}{})
	fake.increaseActiveTasksMutex.Unlock()
	if fake.IncreaseActiveTasksStub != nil {
		return fake.IncreaseActiveTasksStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.increaseActiveTasksReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) IncreaseActiveTasksCallCount() int {
	fake.increaseActiveTasksMutex.RLock()
	defer fake.increaseActiveTasksMutex.RUnlock()
	return len(fake.increaseActiveTasksArgsForCall)
}

func (fake *FakeWorker) IncreaseActiveTasksCalls(stub func() error) {
	fake.increaseActiveTasksMutex.Lock()
	defer fake.increaseActiveTasksMutex.Unlock()
	fake.IncreaseActiveTasksStub = stub
}

func (fake *FakeWorker) IncreaseActiveTasksReturns(result1 error) {
	fake.increaseActiveTasksMutex.Lock()
	defer fake.increaseActiveTasksMutex.Unlock()
	fake.IncreaseActiveTasksStub = nil
	fake.increaseActiveTasksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) IncreaseActiveTasksReturnsOnCall(i int, result1 error) {
	fake.increaseActiveTasksMutex.Lock()
	defer fake.increaseActiveTasksMutex.Unlock()
	fake.IncreaseActiveTasksStub = nil
	if fake.increaseActiveTasksReturnsOnCall == nil {
		fake.increaseActiveTasksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.increaseActiveTasksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) IsOwnedByTeam() bool {
	fake.isOwnedByTeamMutex.Lock()
	ret, specificReturn := fake.isOwnedByTeamReturnsOnCall[len(fake.isOwnedByTeamArgsForCall)]
	fake.isOwnedByTeamArgsForCall = append(fake.isOwnedByTeamArgsForCall, struct {
	}{})
	fake.recordInvocation("IsOwnedByTeam", []interface{}{})
	fake.isOwnedByTeamMutex.Unlock()
	if fake.IsOwnedByTeamStub != nil {
		return fake.IsOwnedByTeamStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isOwnedByTeamReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) IsOwnedByTeamCallCount() int {
	fake.isOwnedByTeamMutex.RLock()
	defer fake.isOwnedByTeamMutex.RUnlock()
	return len(fake.isOwnedByTeamArgsForCall)
}

func (fake *FakeWorker) IsOwnedByTeamCalls(stub func() bool) {
	fake.isOwnedByTeamMutex.Lock()
	defer fake.isOwnedByTeamMutex.Unlock()
	fake.IsOwnedByTeamStub = stub
}

func (fake *FakeWorker) IsOwnedByTeamReturns(result1 bool) {
	fake.isOwnedByTeamMutex.Lock()
	defer fake.isOwnedByTeamMutex.Unlock()
	fake.IsOwnedByTeamStub = nil
	fake.isOwnedByTeamReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsOwnedByTeamReturnsOnCall(i int, result1 bool) {
	fake.isOwnedByTeamMutex.Lock()
	defer fake.isOwnedByTeamMutex.Unlock()
	fake.IsOwnedByTeamStub = nil
	if fake.isOwnedByTeamReturnsOnCall == nil {
		fake.isOwnedByTeamReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isOwnedByTeamReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsVersionCompatible(arg1 lager.Logger, arg2 version.Version) bool {
	fake.isVersionCompatibleMutex.Lock()
	ret, specificReturn := fake.isVersionCompatibleReturnsOnCall[len(fake.isVersionCompatibleArgsForCall)]
	fake.isVersionCompatibleArgsForCall = append(fake.isVersionCompatibleArgsForCall, struct {
		arg1 lager.Logger
		arg2 version.Version
	}{arg1, arg2})
	fake.recordInvocation("IsVersionCompatible", []interface{}{arg1, arg2})
	fake.isVersionCompatibleMutex.Unlock()
	if fake.IsVersionCompatibleStub != nil {
		return fake.IsVersionCompatibleStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isVersionCompatibleReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) IsVersionCompatibleCallCount() int {
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	return len(fake.isVersionCompatibleArgsForCall)
}

func (fake *FakeWorker) IsVersionCompatibleCalls(stub func(lager.Logger, version.Version) bool) {
	fake.isVersionCompatibleMutex.Lock()
	defer fake.isVersionCompatibleMutex.Unlock()
	fake.IsVersionCompatibleStub = stub
}

func (fake *FakeWorker) IsVersionCompatibleArgsForCall(i int) (lager.Logger, version.Version) {
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	argsForCall := fake.isVersionCompatibleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) IsVersionCompatibleReturns(result1 bool) {
	fake.isVersionCompatibleMutex.Lock()
	defer fake.isVersionCompatibleMutex.Unlock()
	fake.IsVersionCompatibleStub = nil
	fake.isVersionCompatibleReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsVersionCompatibleReturnsOnCall(i int, result1 bool) {
	fake.isVersionCompatibleMutex.Lock()
	defer fake.isVersionCompatibleMutex.Unlock()
	fake.IsVersionCompatibleStub = nil
	if fake.isVersionCompatibleReturnsOnCall == nil {
		fake.isVersionCompatibleReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isVersionCompatibleReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) LookupVolume(arg1 lager.Logger, arg2 string) (worker.Volume, bool, error) {
	fake.lookupVolumeMutex.Lock()
	ret, specificReturn := fake.lookupVolumeReturnsOnCall[len(fake.lookupVolumeArgsForCall)]
	fake.lookupVolumeArgsForCall = append(fake.lookupVolumeArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("LookupVolume", []interface{}{arg1, arg2})
	fake.lookupVolumeMutex.Unlock()
	if fake.LookupVolumeStub != nil {
		return fake.LookupVolumeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.lookupVolumeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) LookupVolumeCallCount() int {
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	return len(fake.lookupVolumeArgsForCall)
}

func (fake *FakeWorker) LookupVolumeCalls(stub func(lager.Logger, string) (worker.Volume, bool, error)) {
	fake.lookupVolumeMutex.Lock()
	defer fake.lookupVolumeMutex.Unlock()
	fake.LookupVolumeStub = stub
}

func (fake *FakeWorker) LookupVolumeArgsForCall(i int) (lager.Logger, string) {
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	argsForCall := fake.lookupVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) LookupVolumeReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.lookupVolumeMutex.Lock()
	defer fake.lookupVolumeMutex.Unlock()
	fake.LookupVolumeStub = nil
	fake.lookupVolumeReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) LookupVolumeReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.lookupVolumeMutex.Lock()
	defer fake.lookupVolumeMutex.Unlock()
	fake.LookupVolumeStub = nil
	if fake.lookupVolumeReturnsOnCall == nil {
		fake.lookupVolumeReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.lookupVolumeReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeWorker) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeWorker) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) ResourceTypes() []atc.WorkerResourceType {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if fake.ResourceTypesStub != nil {
		return fake.ResourceTypesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceTypesReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakeWorker) ResourceTypesCalls(stub func() []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = stub
}

func (fake *FakeWorker) ResourceTypesReturns(result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) ResourceTypesReturnsOnCall(i int, result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 []atc.WorkerResourceType
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) Satisfies(arg1 lager.Logger, arg2 worker.WorkerSpec) bool {
	fake.satisfiesMutex.Lock()
	ret, specificReturn := fake.satisfiesReturnsOnCall[len(fake.satisfiesArgsForCall)]
	fake.satisfiesArgsForCall = append(fake.satisfiesArgsForCall, struct {
		arg1 lager.Logger
		arg2 worker.WorkerSpec
	}{arg1, arg2})
	fake.recordInvocation("Satisfies", []interface{}{arg1, arg2})
	fake.satisfiesMutex.Unlock()
	if fake.SatisfiesStub != nil {
		return fake.SatisfiesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.satisfiesReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) SatisfiesCallCount() int {
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	return len(fake.satisfiesArgsForCall)
}

func (fake *FakeWorker) SatisfiesCalls(stub func(lager.Logger, worker.WorkerSpec) bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = stub
}

func (fake *FakeWorker) SatisfiesArgsForCall(i int) (lager.Logger, worker.WorkerSpec) {
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	argsForCall := fake.satisfiesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) SatisfiesReturns(result1 bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = nil
	fake.satisfiesReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) SatisfiesReturnsOnCall(i int, result1 bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = nil
	if fake.satisfiesReturnsOnCall == nil {
		fake.satisfiesReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.satisfiesReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) Tags() atc.Tags {
	fake.tagsMutex.Lock()
	ret, specificReturn := fake.tagsReturnsOnCall[len(fake.tagsArgsForCall)]
	fake.tagsArgsForCall = append(fake.tagsArgsForCall, struct {
	}{})
	fake.recordInvocation("Tags", []interface{}{})
	fake.tagsMutex.Unlock()
	if fake.TagsStub != nil {
		return fake.TagsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tagsReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) TagsCallCount() int {
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	return len(fake.tagsArgsForCall)
}

func (fake *FakeWorker) TagsCalls(stub func() atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = stub
}

func (fake *FakeWorker) TagsReturns(result1 atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	fake.tagsReturns = struct {
		result1 atc.Tags
	}{result1}
}

func (fake *FakeWorker) TagsReturnsOnCall(i int, result1 atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	if fake.tagsReturnsOnCall == nil {
		fake.tagsReturnsOnCall = make(map[int]struct {
			result1 atc.Tags
		})
	}
	fake.tagsReturnsOnCall[i] = struct {
		result1 atc.Tags
	}{result1}
}

func (fake *FakeWorker) Uptime() time.Duration {
	fake.uptimeMutex.Lock()
	ret, specificReturn := fake.uptimeReturnsOnCall[len(fake.uptimeArgsForCall)]
	fake.uptimeArgsForCall = append(fake.uptimeArgsForCall, struct {
	}{})
	fake.recordInvocation("Uptime", []interface{}{})
	fake.uptimeMutex.Unlock()
	if fake.UptimeStub != nil {
		return fake.UptimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uptimeReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) UptimeCallCount() int {
	fake.uptimeMutex.RLock()
	defer fake.uptimeMutex.RUnlock()
	return len(fake.uptimeArgsForCall)
}

func (fake *FakeWorker) UptimeCalls(stub func() time.Duration) {
	fake.uptimeMutex.Lock()
	defer fake.uptimeMutex.Unlock()
	fake.UptimeStub = stub
}

func (fake *FakeWorker) UptimeReturns(result1 time.Duration) {
	fake.uptimeMutex.Lock()
	defer fake.uptimeMutex.Unlock()
	fake.UptimeStub = nil
	fake.uptimeReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeWorker) UptimeReturnsOnCall(i int, result1 time.Duration) {
	fake.uptimeMutex.Lock()
	defer fake.uptimeMutex.Unlock()
	fake.UptimeStub = nil
	if fake.uptimeReturnsOnCall == nil {
		fake.uptimeReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.uptimeReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeWorker) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activeTasksMutex.RLock()
	defer fake.activeTasksMutex.RUnlock()
	fake.buildContainersMutex.RLock()
	defer fake.buildContainersMutex.RUnlock()
	fake.certsVolumeMutex.RLock()
	defer fake.certsVolumeMutex.RUnlock()
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	fake.decreaseActiveTasksMutex.RLock()
	defer fake.decreaseActiveTasksMutex.RUnlock()
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	fake.ephemeralMutex.RLock()
	defer fake.ephemeralMutex.RUnlock()
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	fake.findOrCreateContainerMutex.RLock()
	defer fake.findOrCreateContainerMutex.RUnlock()
	fake.findVolumeForResourceCacheMutex.RLock()
	defer fake.findVolumeForResourceCacheMutex.RUnlock()
	fake.findVolumeForTaskCacheMutex.RLock()
	defer fake.findVolumeForTaskCacheMutex.RUnlock()
	fake.gardenClientMutex.RLock()
	defer fake.gardenClientMutex.RUnlock()
	fake.increaseActiveTasksMutex.RLock()
	defer fake.increaseActiveTasksMutex.RUnlock()
	fake.isOwnedByTeamMutex.RLock()
	defer fake.isOwnedByTeamMutex.RUnlock()
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	fake.uptimeMutex.RLock()
	defer fake.uptimeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorker) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ worker.Worker = new(FakeWorker)
