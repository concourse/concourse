// Code generated by counterfeiter. DO NOT EDIT.
package workerfakes

import (
	"context"
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/resource"
	"github.com/concourse/concourse/atc/runtime"
	"github.com/concourse/concourse/atc/worker"
	"github.com/concourse/concourse/atc/worker/gclient"
	"github.com/cppforlife/go-semi-semantic/version"
)

type FakeWorker struct {
	ActiveContainersStub        func() int
	activeContainersMutex       sync.RWMutex
	activeContainersArgsForCall []struct {
	}
	activeContainersReturns struct {
		result1 int
	}
	activeContainersReturnsOnCall map[int]struct {
		result1 int
	}
	ActiveTasksStub        func() (int, error)
	activeTasksMutex       sync.RWMutex
	activeTasksArgsForCall []struct {
	}
	activeTasksReturns struct {
		result1 int
		result2 error
	}
	activeTasksReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ActiveVolumesStub        func() int
	activeVolumesMutex       sync.RWMutex
	activeVolumesArgsForCall []struct {
	}
	activeVolumesReturns struct {
		result1 int
	}
	activeVolumesReturnsOnCall map[int]struct {
		result1 int
	}
	AllocatableMemoryStub        func() *atc.MemoryLimit
	allocatableMemoryMutex       sync.RWMutex
	allocatableMemoryArgsForCall []struct {
	}
	allocatableMemoryReturns struct {
		result1 *atc.MemoryLimit
	}
	allocatableMemoryReturnsOnCall map[int]struct {
		result1 *atc.MemoryLimit
	}
	BuildContainersStub        func() int
	buildContainersMutex       sync.RWMutex
	buildContainersArgsForCall []struct {
	}
	buildContainersReturns struct {
		result1 int
	}
	buildContainersReturnsOnCall map[int]struct {
		result1 int
	}
	CertsVolumeStub        func(lager.Logger) (worker.Volume, bool, error)
	certsVolumeMutex       sync.RWMutex
	certsVolumeArgsForCall []struct {
		arg1 lager.Logger
	}
	certsVolumeReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	certsVolumeReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	CreateVolumeStub        func(lager.Logger, worker.VolumeSpec, int, db.VolumeType) (worker.Volume, error)
	createVolumeMutex       sync.RWMutex
	createVolumeArgsForCall []struct {
		arg1 lager.Logger
		arg2 worker.VolumeSpec
		arg3 int
		arg4 db.VolumeType
	}
	createVolumeReturns struct {
		result1 worker.Volume
		result2 error
	}
	createVolumeReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 error
	}
	DecreaseActiveTasksStub        func() (int, error)
	decreaseActiveTasksMutex       sync.RWMutex
	decreaseActiveTasksArgsForCall []struct {
	}
	decreaseActiveTasksReturns struct {
		result1 int
		result2 error
	}
	decreaseActiveTasksReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	DescriptionStub        func() string
	descriptionMutex       sync.RWMutex
	descriptionArgsForCall []struct {
	}
	descriptionReturns struct {
		result1 string
	}
	descriptionReturnsOnCall map[int]struct {
		result1 string
	}
	EphemeralStub        func() bool
	ephemeralMutex       sync.RWMutex
	ephemeralArgsForCall []struct {
	}
	ephemeralReturns struct {
		result1 bool
	}
	ephemeralReturnsOnCall map[int]struct {
		result1 bool
	}
	FetchStub        func(context.Context, lager.Logger, db.ContainerMetadata, worker.Worker, worker.ContainerSpec, runtime.ProcessSpec, resource.Resource, db.ContainerOwner, db.UsedResourceCache, string) (worker.GetResult, worker.Volume, error)
	fetchMutex       sync.RWMutex
	fetchArgsForCall []struct {
		arg1  context.Context
		arg2  lager.Logger
		arg3  db.ContainerMetadata
		arg4  worker.Worker
		arg5  worker.ContainerSpec
		arg6  runtime.ProcessSpec
		arg7  resource.Resource
		arg8  db.ContainerOwner
		arg9  db.UsedResourceCache
		arg10 string
	}
	fetchReturns struct {
		result1 worker.GetResult
		result2 worker.Volume
		result3 error
	}
	fetchReturnsOnCall map[int]struct {
		result1 worker.GetResult
		result2 worker.Volume
		result3 error
	}
	FindContainerByHandleStub        func(lager.Logger, int, string) (worker.Container, bool, error)
	findContainerByHandleMutex       sync.RWMutex
	findContainerByHandleArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
		arg3 string
	}
	findContainerByHandleReturns struct {
		result1 worker.Container
		result2 bool
		result3 error
	}
	findContainerByHandleReturnsOnCall map[int]struct {
		result1 worker.Container
		result2 bool
		result3 error
	}
	FindOrCreateContainerStub        func(context.Context, lager.Logger, db.ContainerOwner, db.ContainerMetadata, worker.ContainerSpec) (worker.Container, error)
	findOrCreateContainerMutex       sync.RWMutex
	findOrCreateContainerArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 db.ContainerOwner
		arg4 db.ContainerMetadata
		arg5 worker.ContainerSpec
	}
	findOrCreateContainerReturns struct {
		result1 worker.Container
		result2 error
	}
	findOrCreateContainerReturnsOnCall map[int]struct {
		result1 worker.Container
		result2 error
	}
	FindResourceCacheForVolumeStub        func(worker.Volume) (db.UsedResourceCache, bool, error)
	findResourceCacheForVolumeMutex       sync.RWMutex
	findResourceCacheForVolumeArgsForCall []struct {
		arg1 worker.Volume
	}
	findResourceCacheForVolumeReturns struct {
		result1 db.UsedResourceCache
		result2 bool
		result3 error
	}
	findResourceCacheForVolumeReturnsOnCall map[int]struct {
		result1 db.UsedResourceCache
		result2 bool
		result3 error
	}
	FindVolumeForResourceCacheStub        func(lager.Logger, db.UsedResourceCache) (worker.Volume, bool, error)
	findVolumeForResourceCacheMutex       sync.RWMutex
	findVolumeForResourceCacheArgsForCall []struct {
		arg1 lager.Logger
		arg2 db.UsedResourceCache
	}
	findVolumeForResourceCacheReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	findVolumeForResourceCacheReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	FindVolumeForTaskCacheStub        func(lager.Logger, int, int, string, string) (worker.Volume, bool, error)
	findVolumeForTaskCacheMutex       sync.RWMutex
	findVolumeForTaskCacheArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
		arg3 int
		arg4 string
		arg5 string
	}
	findVolumeForTaskCacheReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	findVolumeForTaskCacheReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	GardenClientStub        func() gclient.Client
	gardenClientMutex       sync.RWMutex
	gardenClientArgsForCall []struct {
	}
	gardenClientReturns struct {
		result1 gclient.Client
	}
	gardenClientReturnsOnCall map[int]struct {
		result1 gclient.Client
	}
	IncreaseActiveTasksStub        func() (int, error)
	increaseActiveTasksMutex       sync.RWMutex
	increaseActiveTasksArgsForCall []struct {
	}
	increaseActiveTasksReturns struct {
		result1 int
		result2 error
	}
	increaseActiveTasksReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	IsOwnedByTeamStub        func() bool
	isOwnedByTeamMutex       sync.RWMutex
	isOwnedByTeamArgsForCall []struct {
	}
	isOwnedByTeamReturns struct {
		result1 bool
	}
	isOwnedByTeamReturnsOnCall map[int]struct {
		result1 bool
	}
	IsVersionCompatibleStub        func(lager.Logger, version.Version) bool
	isVersionCompatibleMutex       sync.RWMutex
	isVersionCompatibleArgsForCall []struct {
		arg1 lager.Logger
		arg2 version.Version
	}
	isVersionCompatibleReturns struct {
		result1 bool
	}
	isVersionCompatibleReturnsOnCall map[int]struct {
		result1 bool
	}
	LookupVolumeStub        func(lager.Logger, string) (worker.Volume, bool, error)
	lookupVolumeMutex       sync.RWMutex
	lookupVolumeArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	lookupVolumeReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	lookupVolumeReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ResourceTypesStub        func() []atc.WorkerResourceType
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct {
	}
	resourceTypesReturns struct {
		result1 []atc.WorkerResourceType
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 []atc.WorkerResourceType
	}
	SatisfiesStub        func(lager.Logger, worker.WorkerSpec) bool
	satisfiesMutex       sync.RWMutex
	satisfiesArgsForCall []struct {
		arg1 lager.Logger
		arg2 worker.WorkerSpec
	}
	satisfiesReturns struct {
		result1 bool
	}
	satisfiesReturnsOnCall map[int]struct {
		result1 bool
	}
	TagsStub        func() atc.Tags
	tagsMutex       sync.RWMutex
	tagsArgsForCall []struct {
	}
	tagsReturns struct {
		result1 atc.Tags
	}
	tagsReturnsOnCall map[int]struct {
		result1 atc.Tags
	}
	UptimeStub        func() time.Duration
	uptimeMutex       sync.RWMutex
	uptimeArgsForCall []struct {
	}
	uptimeReturns struct {
		result1 time.Duration
	}
	uptimeReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorker) ActiveContainers() int {
	fake.activeContainersMutex.Lock()
	ret, specificReturn := fake.activeContainersReturnsOnCall[len(fake.activeContainersArgsForCall)]
	fake.activeContainersArgsForCall = append(fake.activeContainersArgsForCall, struct {
	}{})
	stub := fake.ActiveContainersStub
	fakeReturns := fake.activeContainersReturns
	fake.recordInvocation("ActiveContainers", []interface{}{})
	fake.activeContainersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ActiveContainersCallCount() int {
	fake.activeContainersMutex.RLock()
	defer fake.activeContainersMutex.RUnlock()
	return len(fake.activeContainersArgsForCall)
}

func (fake *FakeWorker) ActiveContainersCalls(stub func() int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = stub
}

func (fake *FakeWorker) ActiveContainersReturns(result1 int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = nil
	fake.activeContainersReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveContainersReturnsOnCall(i int, result1 int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = nil
	if fake.activeContainersReturnsOnCall == nil {
		fake.activeContainersReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.activeContainersReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveTasks() (int, error) {
	fake.activeTasksMutex.Lock()
	ret, specificReturn := fake.activeTasksReturnsOnCall[len(fake.activeTasksArgsForCall)]
	fake.activeTasksArgsForCall = append(fake.activeTasksArgsForCall, struct {
	}{})
	stub := fake.ActiveTasksStub
	fakeReturns := fake.activeTasksReturns
	fake.recordInvocation("ActiveTasks", []interface{}{})
	fake.activeTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) ActiveTasksCallCount() int {
	fake.activeTasksMutex.RLock()
	defer fake.activeTasksMutex.RUnlock()
	return len(fake.activeTasksArgsForCall)
}

func (fake *FakeWorker) ActiveTasksCalls(stub func() (int, error)) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = stub
}

func (fake *FakeWorker) ActiveTasksReturns(result1 int, result2 error) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = nil
	fake.activeTasksReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ActiveTasksReturnsOnCall(i int, result1 int, result2 error) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = nil
	if fake.activeTasksReturnsOnCall == nil {
		fake.activeTasksReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.activeTasksReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ActiveVolumes() int {
	fake.activeVolumesMutex.Lock()
	ret, specificReturn := fake.activeVolumesReturnsOnCall[len(fake.activeVolumesArgsForCall)]
	fake.activeVolumesArgsForCall = append(fake.activeVolumesArgsForCall, struct {
	}{})
	stub := fake.ActiveVolumesStub
	fakeReturns := fake.activeVolumesReturns
	fake.recordInvocation("ActiveVolumes", []interface{}{})
	fake.activeVolumesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ActiveVolumesCallCount() int {
	fake.activeVolumesMutex.RLock()
	defer fake.activeVolumesMutex.RUnlock()
	return len(fake.activeVolumesArgsForCall)
}

func (fake *FakeWorker) ActiveVolumesCalls(stub func() int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = stub
}

func (fake *FakeWorker) ActiveVolumesReturns(result1 int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = nil
	fake.activeVolumesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveVolumesReturnsOnCall(i int, result1 int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = nil
	if fake.activeVolumesReturnsOnCall == nil {
		fake.activeVolumesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.activeVolumesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) AllocatableMemory() *atc.MemoryLimit {
	fake.allocatableMemoryMutex.Lock()
	ret, specificReturn := fake.allocatableMemoryReturnsOnCall[len(fake.allocatableMemoryArgsForCall)]
	fake.allocatableMemoryArgsForCall = append(fake.allocatableMemoryArgsForCall, struct {
	}{})
	fake.recordInvocation("AllocatableMemory", []interface{}{})
	fake.allocatableMemoryMutex.Unlock()
	if fake.AllocatableMemoryStub != nil {
		return fake.AllocatableMemoryStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.allocatableMemoryReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) AllocatableMemoryCallCount() int {
	fake.allocatableMemoryMutex.RLock()
	defer fake.allocatableMemoryMutex.RUnlock()
	return len(fake.allocatableMemoryArgsForCall)
}

func (fake *FakeWorker) AllocatableMemoryCalls(stub func() *atc.MemoryLimit) {
	fake.allocatableMemoryMutex.Lock()
	defer fake.allocatableMemoryMutex.Unlock()
	fake.AllocatableMemoryStub = stub
}

func (fake *FakeWorker) AllocatableMemoryReturns(result1 *atc.MemoryLimit) {
	fake.allocatableMemoryMutex.Lock()
	defer fake.allocatableMemoryMutex.Unlock()
	fake.AllocatableMemoryStub = nil
	fake.allocatableMemoryReturns = struct {
		result1 *atc.MemoryLimit
	}{result1}
}

func (fake *FakeWorker) AllocatableMemoryReturnsOnCall(i int, result1 *atc.MemoryLimit) {
	fake.allocatableMemoryMutex.Lock()
	defer fake.allocatableMemoryMutex.Unlock()
	fake.AllocatableMemoryStub = nil
	if fake.allocatableMemoryReturnsOnCall == nil {
		fake.allocatableMemoryReturnsOnCall = make(map[int]struct {
			result1 *atc.MemoryLimit
		})
	}
	fake.allocatableMemoryReturnsOnCall[i] = struct {
		result1 *atc.MemoryLimit
	}{result1}
}

func (fake *FakeWorker) BuildContainers() int {
	fake.buildContainersMutex.Lock()
	ret, specificReturn := fake.buildContainersReturnsOnCall[len(fake.buildContainersArgsForCall)]
	fake.buildContainersArgsForCall = append(fake.buildContainersArgsForCall, struct {
	}{})
	stub := fake.BuildContainersStub
	fakeReturns := fake.buildContainersReturns
	fake.recordInvocation("BuildContainers", []interface{}{})
	fake.buildContainersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) BuildContainersCallCount() int {
	fake.buildContainersMutex.RLock()
	defer fake.buildContainersMutex.RUnlock()
	return len(fake.buildContainersArgsForCall)
}

func (fake *FakeWorker) BuildContainersCalls(stub func() int) {
	fake.buildContainersMutex.Lock()
	defer fake.buildContainersMutex.Unlock()
	fake.BuildContainersStub = stub
}

func (fake *FakeWorker) BuildContainersReturns(result1 int) {
	fake.buildContainersMutex.Lock()
	defer fake.buildContainersMutex.Unlock()
	fake.BuildContainersStub = nil
	fake.buildContainersReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) BuildContainersReturnsOnCall(i int, result1 int) {
	fake.buildContainersMutex.Lock()
	defer fake.buildContainersMutex.Unlock()
	fake.BuildContainersStub = nil
	if fake.buildContainersReturnsOnCall == nil {
		fake.buildContainersReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.buildContainersReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) CertsVolume(arg1 lager.Logger) (worker.Volume, bool, error) {
	fake.certsVolumeMutex.Lock()
	ret, specificReturn := fake.certsVolumeReturnsOnCall[len(fake.certsVolumeArgsForCall)]
	fake.certsVolumeArgsForCall = append(fake.certsVolumeArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.CertsVolumeStub
	fakeReturns := fake.certsVolumeReturns
	fake.recordInvocation("CertsVolume", []interface{}{arg1})
	fake.certsVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) CertsVolumeCallCount() int {
	fake.certsVolumeMutex.RLock()
	defer fake.certsVolumeMutex.RUnlock()
	return len(fake.certsVolumeArgsForCall)
}

func (fake *FakeWorker) CertsVolumeCalls(stub func(lager.Logger) (worker.Volume, bool, error)) {
	fake.certsVolumeMutex.Lock()
	defer fake.certsVolumeMutex.Unlock()
	fake.CertsVolumeStub = stub
}

func (fake *FakeWorker) CertsVolumeArgsForCall(i int) lager.Logger {
	fake.certsVolumeMutex.RLock()
	defer fake.certsVolumeMutex.RUnlock()
	argsForCall := fake.certsVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorker) CertsVolumeReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.certsVolumeMutex.Lock()
	defer fake.certsVolumeMutex.Unlock()
	fake.CertsVolumeStub = nil
	fake.certsVolumeReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) CertsVolumeReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.certsVolumeMutex.Lock()
	defer fake.certsVolumeMutex.Unlock()
	fake.CertsVolumeStub = nil
	if fake.certsVolumeReturnsOnCall == nil {
		fake.certsVolumeReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.certsVolumeReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) CreateVolume(arg1 lager.Logger, arg2 worker.VolumeSpec, arg3 int, arg4 db.VolumeType) (worker.Volume, error) {
	fake.createVolumeMutex.Lock()
	ret, specificReturn := fake.createVolumeReturnsOnCall[len(fake.createVolumeArgsForCall)]
	fake.createVolumeArgsForCall = append(fake.createVolumeArgsForCall, struct {
		arg1 lager.Logger
		arg2 worker.VolumeSpec
		arg3 int
		arg4 db.VolumeType
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateVolumeStub
	fakeReturns := fake.createVolumeReturns
	fake.recordInvocation("CreateVolume", []interface{}{arg1, arg2, arg3, arg4})
	fake.createVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) CreateVolumeCallCount() int {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return len(fake.createVolumeArgsForCall)
}

func (fake *FakeWorker) CreateVolumeCalls(stub func(lager.Logger, worker.VolumeSpec, int, db.VolumeType) (worker.Volume, error)) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = stub
}

func (fake *FakeWorker) CreateVolumeArgsForCall(i int) (lager.Logger, worker.VolumeSpec, int, db.VolumeType) {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	argsForCall := fake.createVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeWorker) CreateVolumeReturns(result1 worker.Volume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	fake.createVolumeReturns = struct {
		result1 worker.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) CreateVolumeReturnsOnCall(i int, result1 worker.Volume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	if fake.createVolumeReturnsOnCall == nil {
		fake.createVolumeReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 error
		})
	}
	fake.createVolumeReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) DecreaseActiveTasks() (int, error) {
	fake.decreaseActiveTasksMutex.Lock()
	ret, specificReturn := fake.decreaseActiveTasksReturnsOnCall[len(fake.decreaseActiveTasksArgsForCall)]
	fake.decreaseActiveTasksArgsForCall = append(fake.decreaseActiveTasksArgsForCall, struct {
	}{})
	stub := fake.DecreaseActiveTasksStub
	fakeReturns := fake.decreaseActiveTasksReturns
	fake.recordInvocation("DecreaseActiveTasks", []interface{}{})
	fake.decreaseActiveTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) DecreaseActiveTasksCallCount() int {
	fake.decreaseActiveTasksMutex.RLock()
	defer fake.decreaseActiveTasksMutex.RUnlock()
	return len(fake.decreaseActiveTasksArgsForCall)
}

func (fake *FakeWorker) DecreaseActiveTasksCalls(stub func() (int, error)) {
	fake.decreaseActiveTasksMutex.Lock()
	defer fake.decreaseActiveTasksMutex.Unlock()
	fake.DecreaseActiveTasksStub = stub
}

func (fake *FakeWorker) DecreaseActiveTasksReturns(result1 int, result2 error) {
	fake.decreaseActiveTasksMutex.Lock()
	defer fake.decreaseActiveTasksMutex.Unlock()
	fake.DecreaseActiveTasksStub = nil
	fake.decreaseActiveTasksReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) DecreaseActiveTasksReturnsOnCall(i int, result1 int, result2 error) {
	fake.decreaseActiveTasksMutex.Lock()
	defer fake.decreaseActiveTasksMutex.Unlock()
	fake.DecreaseActiveTasksStub = nil
	if fake.decreaseActiveTasksReturnsOnCall == nil {
		fake.decreaseActiveTasksReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.decreaseActiveTasksReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) Description() string {
	fake.descriptionMutex.Lock()
	ret, specificReturn := fake.descriptionReturnsOnCall[len(fake.descriptionArgsForCall)]
	fake.descriptionArgsForCall = append(fake.descriptionArgsForCall, struct {
	}{})
	stub := fake.DescriptionStub
	fakeReturns := fake.descriptionReturns
	fake.recordInvocation("Description", []interface{}{})
	fake.descriptionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) DescriptionCallCount() int {
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	return len(fake.descriptionArgsForCall)
}

func (fake *FakeWorker) DescriptionCalls(stub func() string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = stub
}

func (fake *FakeWorker) DescriptionReturns(result1 string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = nil
	fake.descriptionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) DescriptionReturnsOnCall(i int, result1 string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = nil
	if fake.descriptionReturnsOnCall == nil {
		fake.descriptionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.descriptionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Ephemeral() bool {
	fake.ephemeralMutex.Lock()
	ret, specificReturn := fake.ephemeralReturnsOnCall[len(fake.ephemeralArgsForCall)]
	fake.ephemeralArgsForCall = append(fake.ephemeralArgsForCall, struct {
	}{})
	stub := fake.EphemeralStub
	fakeReturns := fake.ephemeralReturns
	fake.recordInvocation("Ephemeral", []interface{}{})
	fake.ephemeralMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) EphemeralCallCount() int {
	fake.ephemeralMutex.RLock()
	defer fake.ephemeralMutex.RUnlock()
	return len(fake.ephemeralArgsForCall)
}

func (fake *FakeWorker) EphemeralCalls(stub func() bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = stub
}

func (fake *FakeWorker) EphemeralReturns(result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	fake.ephemeralReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) EphemeralReturnsOnCall(i int, result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	if fake.ephemeralReturnsOnCall == nil {
		fake.ephemeralReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ephemeralReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) Fetch(arg1 context.Context, arg2 lager.Logger, arg3 db.ContainerMetadata, arg4 worker.Worker, arg5 worker.ContainerSpec, arg6 runtime.ProcessSpec, arg7 resource.Resource, arg8 db.ContainerOwner, arg9 db.UsedResourceCache, arg10 string) (worker.GetResult, worker.Volume, error) {
	fake.fetchMutex.Lock()
	ret, specificReturn := fake.fetchReturnsOnCall[len(fake.fetchArgsForCall)]
	fake.fetchArgsForCall = append(fake.fetchArgsForCall, struct {
		arg1  context.Context
		arg2  lager.Logger
		arg3  db.ContainerMetadata
		arg4  worker.Worker
		arg5  worker.ContainerSpec
		arg6  runtime.ProcessSpec
		arg7  resource.Resource
		arg8  db.ContainerOwner
		arg9  db.UsedResourceCache
		arg10 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10})
	stub := fake.FetchStub
	fakeReturns := fake.fetchReturns
	fake.recordInvocation("Fetch", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10})
	fake.fetchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FetchCallCount() int {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	return len(fake.fetchArgsForCall)
}

func (fake *FakeWorker) FetchCalls(stub func(context.Context, lager.Logger, db.ContainerMetadata, worker.Worker, worker.ContainerSpec, runtime.ProcessSpec, resource.Resource, db.ContainerOwner, db.UsedResourceCache, string) (worker.GetResult, worker.Volume, error)) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = stub
}

func (fake *FakeWorker) FetchArgsForCall(i int) (context.Context, lager.Logger, db.ContainerMetadata, worker.Worker, worker.ContainerSpec, runtime.ProcessSpec, resource.Resource, db.ContainerOwner, db.UsedResourceCache, string) {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	argsForCall := fake.fetchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9, argsForCall.arg10
}

func (fake *FakeWorker) FetchReturns(result1 worker.GetResult, result2 worker.Volume, result3 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	fake.fetchReturns = struct {
		result1 worker.GetResult
		result2 worker.Volume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FetchReturnsOnCall(i int, result1 worker.GetResult, result2 worker.Volume, result3 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	if fake.fetchReturnsOnCall == nil {
		fake.fetchReturnsOnCall = make(map[int]struct {
			result1 worker.GetResult
			result2 worker.Volume
			result3 error
		})
	}
	fake.fetchReturnsOnCall[i] = struct {
		result1 worker.GetResult
		result2 worker.Volume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindContainerByHandle(arg1 lager.Logger, arg2 int, arg3 string) (worker.Container, bool, error) {
	fake.findContainerByHandleMutex.Lock()
	ret, specificReturn := fake.findContainerByHandleReturnsOnCall[len(fake.findContainerByHandleArgsForCall)]
	fake.findContainerByHandleArgsForCall = append(fake.findContainerByHandleArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FindContainerByHandleStub
	fakeReturns := fake.findContainerByHandleReturns
	fake.recordInvocation("FindContainerByHandle", []interface{}{arg1, arg2, arg3})
	fake.findContainerByHandleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindContainerByHandleCallCount() int {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	return len(fake.findContainerByHandleArgsForCall)
}

func (fake *FakeWorker) FindContainerByHandleCalls(stub func(lager.Logger, int, string) (worker.Container, bool, error)) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = stub
}

func (fake *FakeWorker) FindContainerByHandleArgsForCall(i int) (lager.Logger, int, string) {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	argsForCall := fake.findContainerByHandleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorker) FindContainerByHandleReturns(result1 worker.Container, result2 bool, result3 error) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = nil
	fake.findContainerByHandleReturns = struct {
		result1 worker.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindContainerByHandleReturnsOnCall(i int, result1 worker.Container, result2 bool, result3 error) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = nil
	if fake.findContainerByHandleReturnsOnCall == nil {
		fake.findContainerByHandleReturnsOnCall = make(map[int]struct {
			result1 worker.Container
			result2 bool
			result3 error
		})
	}
	fake.findContainerByHandleReturnsOnCall[i] = struct {
		result1 worker.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindOrCreateContainer(arg1 context.Context, arg2 lager.Logger, arg3 db.ContainerOwner, arg4 db.ContainerMetadata, arg5 worker.ContainerSpec) (worker.Container, error) {
	fake.findOrCreateContainerMutex.Lock()
	ret, specificReturn := fake.findOrCreateContainerReturnsOnCall[len(fake.findOrCreateContainerArgsForCall)]
	fake.findOrCreateContainerArgsForCall = append(fake.findOrCreateContainerArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 db.ContainerOwner
		arg4 db.ContainerMetadata
		arg5 worker.ContainerSpec
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.FindOrCreateContainerStub
	fakeReturns := fake.findOrCreateContainerReturns
	fake.recordInvocation("FindOrCreateContainer", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.findOrCreateContainerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) FindOrCreateContainerCallCount() int {
	fake.findOrCreateContainerMutex.RLock()
	defer fake.findOrCreateContainerMutex.RUnlock()
	return len(fake.findOrCreateContainerArgsForCall)
}

func (fake *FakeWorker) FindOrCreateContainerCalls(stub func(context.Context, lager.Logger, db.ContainerOwner, db.ContainerMetadata, worker.ContainerSpec) (worker.Container, error)) {
	fake.findOrCreateContainerMutex.Lock()
	defer fake.findOrCreateContainerMutex.Unlock()
	fake.FindOrCreateContainerStub = stub
}

func (fake *FakeWorker) FindOrCreateContainerArgsForCall(i int) (context.Context, lager.Logger, db.ContainerOwner, db.ContainerMetadata, worker.ContainerSpec) {
	fake.findOrCreateContainerMutex.RLock()
	defer fake.findOrCreateContainerMutex.RUnlock()
	argsForCall := fake.findOrCreateContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeWorker) FindOrCreateContainerReturns(result1 worker.Container, result2 error) {
	fake.findOrCreateContainerMutex.Lock()
	defer fake.findOrCreateContainerMutex.Unlock()
	fake.FindOrCreateContainerStub = nil
	fake.findOrCreateContainerReturns = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindOrCreateContainerReturnsOnCall(i int, result1 worker.Container, result2 error) {
	fake.findOrCreateContainerMutex.Lock()
	defer fake.findOrCreateContainerMutex.Unlock()
	fake.FindOrCreateContainerStub = nil
	if fake.findOrCreateContainerReturnsOnCall == nil {
		fake.findOrCreateContainerReturnsOnCall = make(map[int]struct {
			result1 worker.Container
			result2 error
		})
	}
	fake.findOrCreateContainerReturnsOnCall[i] = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindResourceCacheForVolume(arg1 worker.Volume) (db.UsedResourceCache, bool, error) {
	fake.findResourceCacheForVolumeMutex.Lock()
	ret, specificReturn := fake.findResourceCacheForVolumeReturnsOnCall[len(fake.findResourceCacheForVolumeArgsForCall)]
	fake.findResourceCacheForVolumeArgsForCall = append(fake.findResourceCacheForVolumeArgsForCall, struct {
		arg1 worker.Volume
	}{arg1})
	stub := fake.FindResourceCacheForVolumeStub
	fakeReturns := fake.findResourceCacheForVolumeReturns
	fake.recordInvocation("FindResourceCacheForVolume", []interface{}{arg1})
	fake.findResourceCacheForVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindResourceCacheForVolumeCallCount() int {
	fake.findResourceCacheForVolumeMutex.RLock()
	defer fake.findResourceCacheForVolumeMutex.RUnlock()
	return len(fake.findResourceCacheForVolumeArgsForCall)
}

func (fake *FakeWorker) FindResourceCacheForVolumeCalls(stub func(worker.Volume) (db.UsedResourceCache, bool, error)) {
	fake.findResourceCacheForVolumeMutex.Lock()
	defer fake.findResourceCacheForVolumeMutex.Unlock()
	fake.FindResourceCacheForVolumeStub = stub
}

func (fake *FakeWorker) FindResourceCacheForVolumeArgsForCall(i int) worker.Volume {
	fake.findResourceCacheForVolumeMutex.RLock()
	defer fake.findResourceCacheForVolumeMutex.RUnlock()
	argsForCall := fake.findResourceCacheForVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorker) FindResourceCacheForVolumeReturns(result1 db.UsedResourceCache, result2 bool, result3 error) {
	fake.findResourceCacheForVolumeMutex.Lock()
	defer fake.findResourceCacheForVolumeMutex.Unlock()
	fake.FindResourceCacheForVolumeStub = nil
	fake.findResourceCacheForVolumeReturns = struct {
		result1 db.UsedResourceCache
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindResourceCacheForVolumeReturnsOnCall(i int, result1 db.UsedResourceCache, result2 bool, result3 error) {
	fake.findResourceCacheForVolumeMutex.Lock()
	defer fake.findResourceCacheForVolumeMutex.Unlock()
	fake.FindResourceCacheForVolumeStub = nil
	if fake.findResourceCacheForVolumeReturnsOnCall == nil {
		fake.findResourceCacheForVolumeReturnsOnCall = make(map[int]struct {
			result1 db.UsedResourceCache
			result2 bool
			result3 error
		})
	}
	fake.findResourceCacheForVolumeReturnsOnCall[i] = struct {
		result1 db.UsedResourceCache
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForResourceCache(arg1 lager.Logger, arg2 db.UsedResourceCache) (worker.Volume, bool, error) {
	fake.findVolumeForResourceCacheMutex.Lock()
	ret, specificReturn := fake.findVolumeForResourceCacheReturnsOnCall[len(fake.findVolumeForResourceCacheArgsForCall)]
	fake.findVolumeForResourceCacheArgsForCall = append(fake.findVolumeForResourceCacheArgsForCall, struct {
		arg1 lager.Logger
		arg2 db.UsedResourceCache
	}{arg1, arg2})
	stub := fake.FindVolumeForResourceCacheStub
	fakeReturns := fake.findVolumeForResourceCacheReturns
	fake.recordInvocation("FindVolumeForResourceCache", []interface{}{arg1, arg2})
	fake.findVolumeForResourceCacheMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindVolumeForResourceCacheCallCount() int {
	fake.findVolumeForResourceCacheMutex.RLock()
	defer fake.findVolumeForResourceCacheMutex.RUnlock()
	return len(fake.findVolumeForResourceCacheArgsForCall)
}

func (fake *FakeWorker) FindVolumeForResourceCacheCalls(stub func(lager.Logger, db.UsedResourceCache) (worker.Volume, bool, error)) {
	fake.findVolumeForResourceCacheMutex.Lock()
	defer fake.findVolumeForResourceCacheMutex.Unlock()
	fake.FindVolumeForResourceCacheStub = stub
}

func (fake *FakeWorker) FindVolumeForResourceCacheArgsForCall(i int) (lager.Logger, db.UsedResourceCache) {
	fake.findVolumeForResourceCacheMutex.RLock()
	defer fake.findVolumeForResourceCacheMutex.RUnlock()
	argsForCall := fake.findVolumeForResourceCacheArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) FindVolumeForResourceCacheReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForResourceCacheMutex.Lock()
	defer fake.findVolumeForResourceCacheMutex.Unlock()
	fake.FindVolumeForResourceCacheStub = nil
	fake.findVolumeForResourceCacheReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForResourceCacheReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForResourceCacheMutex.Lock()
	defer fake.findVolumeForResourceCacheMutex.Unlock()
	fake.FindVolumeForResourceCacheStub = nil
	if fake.findVolumeForResourceCacheReturnsOnCall == nil {
		fake.findVolumeForResourceCacheReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.findVolumeForResourceCacheReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForTaskCache(arg1 lager.Logger, arg2 int, arg3 int, arg4 string, arg5 string) (worker.Volume, bool, error) {
	fake.findVolumeForTaskCacheMutex.Lock()
	ret, specificReturn := fake.findVolumeForTaskCacheReturnsOnCall[len(fake.findVolumeForTaskCacheArgsForCall)]
	fake.findVolumeForTaskCacheArgsForCall = append(fake.findVolumeForTaskCacheArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
		arg3 int
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.FindVolumeForTaskCacheStub
	fakeReturns := fake.findVolumeForTaskCacheReturns
	fake.recordInvocation("FindVolumeForTaskCache", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.findVolumeForTaskCacheMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindVolumeForTaskCacheCallCount() int {
	fake.findVolumeForTaskCacheMutex.RLock()
	defer fake.findVolumeForTaskCacheMutex.RUnlock()
	return len(fake.findVolumeForTaskCacheArgsForCall)
}

func (fake *FakeWorker) FindVolumeForTaskCacheCalls(stub func(lager.Logger, int, int, string, string) (worker.Volume, bool, error)) {
	fake.findVolumeForTaskCacheMutex.Lock()
	defer fake.findVolumeForTaskCacheMutex.Unlock()
	fake.FindVolumeForTaskCacheStub = stub
}

func (fake *FakeWorker) FindVolumeForTaskCacheArgsForCall(i int) (lager.Logger, int, int, string, string) {
	fake.findVolumeForTaskCacheMutex.RLock()
	defer fake.findVolumeForTaskCacheMutex.RUnlock()
	argsForCall := fake.findVolumeForTaskCacheArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeWorker) FindVolumeForTaskCacheReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForTaskCacheMutex.Lock()
	defer fake.findVolumeForTaskCacheMutex.Unlock()
	fake.FindVolumeForTaskCacheStub = nil
	fake.findVolumeForTaskCacheReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForTaskCacheReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForTaskCacheMutex.Lock()
	defer fake.findVolumeForTaskCacheMutex.Unlock()
	fake.FindVolumeForTaskCacheStub = nil
	if fake.findVolumeForTaskCacheReturnsOnCall == nil {
		fake.findVolumeForTaskCacheReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.findVolumeForTaskCacheReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) GardenClient() gclient.Client {
	fake.gardenClientMutex.Lock()
	ret, specificReturn := fake.gardenClientReturnsOnCall[len(fake.gardenClientArgsForCall)]
	fake.gardenClientArgsForCall = append(fake.gardenClientArgsForCall, struct {
	}{})
	stub := fake.GardenClientStub
	fakeReturns := fake.gardenClientReturns
	fake.recordInvocation("GardenClient", []interface{}{})
	fake.gardenClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) GardenClientCallCount() int {
	fake.gardenClientMutex.RLock()
	defer fake.gardenClientMutex.RUnlock()
	return len(fake.gardenClientArgsForCall)
}

func (fake *FakeWorker) GardenClientCalls(stub func() gclient.Client) {
	fake.gardenClientMutex.Lock()
	defer fake.gardenClientMutex.Unlock()
	fake.GardenClientStub = stub
}

func (fake *FakeWorker) GardenClientReturns(result1 gclient.Client) {
	fake.gardenClientMutex.Lock()
	defer fake.gardenClientMutex.Unlock()
	fake.GardenClientStub = nil
	fake.gardenClientReturns = struct {
		result1 gclient.Client
	}{result1}
}

func (fake *FakeWorker) GardenClientReturnsOnCall(i int, result1 gclient.Client) {
	fake.gardenClientMutex.Lock()
	defer fake.gardenClientMutex.Unlock()
	fake.GardenClientStub = nil
	if fake.gardenClientReturnsOnCall == nil {
		fake.gardenClientReturnsOnCall = make(map[int]struct {
			result1 gclient.Client
		})
	}
	fake.gardenClientReturnsOnCall[i] = struct {
		result1 gclient.Client
	}{result1}
}

func (fake *FakeWorker) IncreaseActiveTasks() (int, error) {
	fake.increaseActiveTasksMutex.Lock()
	ret, specificReturn := fake.increaseActiveTasksReturnsOnCall[len(fake.increaseActiveTasksArgsForCall)]
	fake.increaseActiveTasksArgsForCall = append(fake.increaseActiveTasksArgsForCall, struct {
	}{})
	stub := fake.IncreaseActiveTasksStub
	fakeReturns := fake.increaseActiveTasksReturns
	fake.recordInvocation("IncreaseActiveTasks", []interface{}{})
	fake.increaseActiveTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) IncreaseActiveTasksCallCount() int {
	fake.increaseActiveTasksMutex.RLock()
	defer fake.increaseActiveTasksMutex.RUnlock()
	return len(fake.increaseActiveTasksArgsForCall)
}

func (fake *FakeWorker) IncreaseActiveTasksCalls(stub func() (int, error)) {
	fake.increaseActiveTasksMutex.Lock()
	defer fake.increaseActiveTasksMutex.Unlock()
	fake.IncreaseActiveTasksStub = stub
}

func (fake *FakeWorker) IncreaseActiveTasksReturns(result1 int, result2 error) {
	fake.increaseActiveTasksMutex.Lock()
	defer fake.increaseActiveTasksMutex.Unlock()
	fake.IncreaseActiveTasksStub = nil
	fake.increaseActiveTasksReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) IncreaseActiveTasksReturnsOnCall(i int, result1 int, result2 error) {
	fake.increaseActiveTasksMutex.Lock()
	defer fake.increaseActiveTasksMutex.Unlock()
	fake.IncreaseActiveTasksStub = nil
	if fake.increaseActiveTasksReturnsOnCall == nil {
		fake.increaseActiveTasksReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.increaseActiveTasksReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) IsOwnedByTeam() bool {
	fake.isOwnedByTeamMutex.Lock()
	ret, specificReturn := fake.isOwnedByTeamReturnsOnCall[len(fake.isOwnedByTeamArgsForCall)]
	fake.isOwnedByTeamArgsForCall = append(fake.isOwnedByTeamArgsForCall, struct {
	}{})
	stub := fake.IsOwnedByTeamStub
	fakeReturns := fake.isOwnedByTeamReturns
	fake.recordInvocation("IsOwnedByTeam", []interface{}{})
	fake.isOwnedByTeamMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) IsOwnedByTeamCallCount() int {
	fake.isOwnedByTeamMutex.RLock()
	defer fake.isOwnedByTeamMutex.RUnlock()
	return len(fake.isOwnedByTeamArgsForCall)
}

func (fake *FakeWorker) IsOwnedByTeamCalls(stub func() bool) {
	fake.isOwnedByTeamMutex.Lock()
	defer fake.isOwnedByTeamMutex.Unlock()
	fake.IsOwnedByTeamStub = stub
}

func (fake *FakeWorker) IsOwnedByTeamReturns(result1 bool) {
	fake.isOwnedByTeamMutex.Lock()
	defer fake.isOwnedByTeamMutex.Unlock()
	fake.IsOwnedByTeamStub = nil
	fake.isOwnedByTeamReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsOwnedByTeamReturnsOnCall(i int, result1 bool) {
	fake.isOwnedByTeamMutex.Lock()
	defer fake.isOwnedByTeamMutex.Unlock()
	fake.IsOwnedByTeamStub = nil
	if fake.isOwnedByTeamReturnsOnCall == nil {
		fake.isOwnedByTeamReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isOwnedByTeamReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsVersionCompatible(arg1 lager.Logger, arg2 version.Version) bool {
	fake.isVersionCompatibleMutex.Lock()
	ret, specificReturn := fake.isVersionCompatibleReturnsOnCall[len(fake.isVersionCompatibleArgsForCall)]
	fake.isVersionCompatibleArgsForCall = append(fake.isVersionCompatibleArgsForCall, struct {
		arg1 lager.Logger
		arg2 version.Version
	}{arg1, arg2})
	stub := fake.IsVersionCompatibleStub
	fakeReturns := fake.isVersionCompatibleReturns
	fake.recordInvocation("IsVersionCompatible", []interface{}{arg1, arg2})
	fake.isVersionCompatibleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) IsVersionCompatibleCallCount() int {
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	return len(fake.isVersionCompatibleArgsForCall)
}

func (fake *FakeWorker) IsVersionCompatibleCalls(stub func(lager.Logger, version.Version) bool) {
	fake.isVersionCompatibleMutex.Lock()
	defer fake.isVersionCompatibleMutex.Unlock()
	fake.IsVersionCompatibleStub = stub
}

func (fake *FakeWorker) IsVersionCompatibleArgsForCall(i int) (lager.Logger, version.Version) {
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	argsForCall := fake.isVersionCompatibleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) IsVersionCompatibleReturns(result1 bool) {
	fake.isVersionCompatibleMutex.Lock()
	defer fake.isVersionCompatibleMutex.Unlock()
	fake.IsVersionCompatibleStub = nil
	fake.isVersionCompatibleReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsVersionCompatibleReturnsOnCall(i int, result1 bool) {
	fake.isVersionCompatibleMutex.Lock()
	defer fake.isVersionCompatibleMutex.Unlock()
	fake.IsVersionCompatibleStub = nil
	if fake.isVersionCompatibleReturnsOnCall == nil {
		fake.isVersionCompatibleReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isVersionCompatibleReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) LookupVolume(arg1 lager.Logger, arg2 string) (worker.Volume, bool, error) {
	fake.lookupVolumeMutex.Lock()
	ret, specificReturn := fake.lookupVolumeReturnsOnCall[len(fake.lookupVolumeArgsForCall)]
	fake.lookupVolumeArgsForCall = append(fake.lookupVolumeArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.LookupVolumeStub
	fakeReturns := fake.lookupVolumeReturns
	fake.recordInvocation("LookupVolume", []interface{}{arg1, arg2})
	fake.lookupVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) LookupVolumeCallCount() int {
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	return len(fake.lookupVolumeArgsForCall)
}

func (fake *FakeWorker) LookupVolumeCalls(stub func(lager.Logger, string) (worker.Volume, bool, error)) {
	fake.lookupVolumeMutex.Lock()
	defer fake.lookupVolumeMutex.Unlock()
	fake.LookupVolumeStub = stub
}

func (fake *FakeWorker) LookupVolumeArgsForCall(i int) (lager.Logger, string) {
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	argsForCall := fake.lookupVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) LookupVolumeReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.lookupVolumeMutex.Lock()
	defer fake.lookupVolumeMutex.Unlock()
	fake.LookupVolumeStub = nil
	fake.lookupVolumeReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) LookupVolumeReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.lookupVolumeMutex.Lock()
	defer fake.lookupVolumeMutex.Unlock()
	fake.LookupVolumeStub = nil
	if fake.lookupVolumeReturnsOnCall == nil {
		fake.lookupVolumeReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.lookupVolumeReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeWorker) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeWorker) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) ResourceTypes() []atc.WorkerResourceType {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct {
	}{})
	stub := fake.ResourceTypesStub
	fakeReturns := fake.resourceTypesReturns
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakeWorker) ResourceTypesCalls(stub func() []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = stub
}

func (fake *FakeWorker) ResourceTypesReturns(result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) ResourceTypesReturnsOnCall(i int, result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 []atc.WorkerResourceType
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) Satisfies(arg1 lager.Logger, arg2 worker.WorkerSpec) bool {
	fake.satisfiesMutex.Lock()
	ret, specificReturn := fake.satisfiesReturnsOnCall[len(fake.satisfiesArgsForCall)]
	fake.satisfiesArgsForCall = append(fake.satisfiesArgsForCall, struct {
		arg1 lager.Logger
		arg2 worker.WorkerSpec
	}{arg1, arg2})
	stub := fake.SatisfiesStub
	fakeReturns := fake.satisfiesReturns
	fake.recordInvocation("Satisfies", []interface{}{arg1, arg2})
	fake.satisfiesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) SatisfiesCallCount() int {
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	return len(fake.satisfiesArgsForCall)
}

func (fake *FakeWorker) SatisfiesCalls(stub func(lager.Logger, worker.WorkerSpec) bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = stub
}

func (fake *FakeWorker) SatisfiesArgsForCall(i int) (lager.Logger, worker.WorkerSpec) {
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	argsForCall := fake.satisfiesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) SatisfiesReturns(result1 bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = nil
	fake.satisfiesReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) SatisfiesReturnsOnCall(i int, result1 bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = nil
	if fake.satisfiesReturnsOnCall == nil {
		fake.satisfiesReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.satisfiesReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) Tags() atc.Tags {
	fake.tagsMutex.Lock()
	ret, specificReturn := fake.tagsReturnsOnCall[len(fake.tagsArgsForCall)]
	fake.tagsArgsForCall = append(fake.tagsArgsForCall, struct {
	}{})
	stub := fake.TagsStub
	fakeReturns := fake.tagsReturns
	fake.recordInvocation("Tags", []interface{}{})
	fake.tagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) TagsCallCount() int {
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	return len(fake.tagsArgsForCall)
}

func (fake *FakeWorker) TagsCalls(stub func() atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = stub
}

func (fake *FakeWorker) TagsReturns(result1 atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	fake.tagsReturns = struct {
		result1 atc.Tags
	}{result1}
}

func (fake *FakeWorker) TagsReturnsOnCall(i int, result1 atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	if fake.tagsReturnsOnCall == nil {
		fake.tagsReturnsOnCall = make(map[int]struct {
			result1 atc.Tags
		})
	}
	fake.tagsReturnsOnCall[i] = struct {
		result1 atc.Tags
	}{result1}
}

func (fake *FakeWorker) Uptime() time.Duration {
	fake.uptimeMutex.Lock()
	ret, specificReturn := fake.uptimeReturnsOnCall[len(fake.uptimeArgsForCall)]
	fake.uptimeArgsForCall = append(fake.uptimeArgsForCall, struct {
	}{})
	stub := fake.UptimeStub
	fakeReturns := fake.uptimeReturns
	fake.recordInvocation("Uptime", []interface{}{})
	fake.uptimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) UptimeCallCount() int {
	fake.uptimeMutex.RLock()
	defer fake.uptimeMutex.RUnlock()
	return len(fake.uptimeArgsForCall)
}

func (fake *FakeWorker) UptimeCalls(stub func() time.Duration) {
	fake.uptimeMutex.Lock()
	defer fake.uptimeMutex.Unlock()
	fake.UptimeStub = stub
}

func (fake *FakeWorker) UptimeReturns(result1 time.Duration) {
	fake.uptimeMutex.Lock()
	defer fake.uptimeMutex.Unlock()
	fake.UptimeStub = nil
	fake.uptimeReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeWorker) UptimeReturnsOnCall(i int, result1 time.Duration) {
	fake.uptimeMutex.Lock()
	defer fake.uptimeMutex.Unlock()
	fake.UptimeStub = nil
	if fake.uptimeReturnsOnCall == nil {
		fake.uptimeReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.uptimeReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeWorker) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activeContainersMutex.RLock()
	defer fake.activeContainersMutex.RUnlock()
	fake.activeTasksMutex.RLock()
	defer fake.activeTasksMutex.RUnlock()
	fake.activeVolumesMutex.RLock()
	defer fake.activeVolumesMutex.RUnlock()
	fake.allocatableMemoryMutex.RLock()
	defer fake.allocatableMemoryMutex.RUnlock()
	fake.buildContainersMutex.RLock()
	defer fake.buildContainersMutex.RUnlock()
	fake.certsVolumeMutex.RLock()
	defer fake.certsVolumeMutex.RUnlock()
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	fake.decreaseActiveTasksMutex.RLock()
	defer fake.decreaseActiveTasksMutex.RUnlock()
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	fake.ephemeralMutex.RLock()
	defer fake.ephemeralMutex.RUnlock()
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	fake.findOrCreateContainerMutex.RLock()
	defer fake.findOrCreateContainerMutex.RUnlock()
	fake.findResourceCacheForVolumeMutex.RLock()
	defer fake.findResourceCacheForVolumeMutex.RUnlock()
	fake.findVolumeForResourceCacheMutex.RLock()
	defer fake.findVolumeForResourceCacheMutex.RUnlock()
	fake.findVolumeForTaskCacheMutex.RLock()
	defer fake.findVolumeForTaskCacheMutex.RUnlock()
	fake.gardenClientMutex.RLock()
	defer fake.gardenClientMutex.RUnlock()
	fake.increaseActiveTasksMutex.RLock()
	defer fake.increaseActiveTasksMutex.RUnlock()
	fake.isOwnedByTeamMutex.RLock()
	defer fake.isOwnedByTeamMutex.RUnlock()
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	fake.uptimeMutex.RLock()
	defer fake.uptimeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorker) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ worker.Worker = new(FakeWorker)
