// Code generated by counterfeiter. DO NOT EDIT.
package workerfakes

import (
	context "context"
	sync "sync"
	time "time"

	garden "code.cloudfoundry.org/garden"
	lager "code.cloudfoundry.org/lager"
	atc "github.com/concourse/concourse/atc"
	creds "github.com/concourse/concourse/atc/creds"
	db "github.com/concourse/concourse/atc/db"
	worker "github.com/concourse/concourse/atc/worker"
	version "github.com/cppforlife/go-semi-semantic/version"
)

type FakeWorker struct {
	ActiveContainersStub        func() int
	activeContainersMutex       sync.RWMutex
	activeContainersArgsForCall []struct {
	}
	activeContainersReturns struct {
		result1 int
	}
	activeContainersReturnsOnCall map[int]struct {
		result1 int
	}
	ActiveVolumesStub        func() int
	activeVolumesMutex       sync.RWMutex
	activeVolumesArgsForCall []struct {
	}
	activeVolumesReturns struct {
		result1 int
	}
	activeVolumesReturnsOnCall map[int]struct {
		result1 int
	}
	CertsVolumeStub        func(lager.Logger) (worker.Volume, bool, error)
	certsVolumeMutex       sync.RWMutex
	certsVolumeArgsForCall []struct {
		arg1 lager.Logger
	}
	certsVolumeReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	certsVolumeReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	DescriptionStub        func() string
	descriptionMutex       sync.RWMutex
	descriptionArgsForCall []struct {
	}
	descriptionReturns struct {
		result1 string
	}
	descriptionReturnsOnCall map[int]struct {
		result1 string
	}
	EphemeralStub        func() bool
	ephemeralMutex       sync.RWMutex
	ephemeralArgsForCall []struct {
	}
	ephemeralReturns struct {
		result1 bool
	}
	ephemeralReturnsOnCall map[int]struct {
		result1 bool
	}
	FindContainerByHandleStub        func(lager.Logger, int, string) (worker.Container, bool, error)
	findContainerByHandleMutex       sync.RWMutex
	findContainerByHandleArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
		arg3 string
	}
	findContainerByHandleReturns struct {
		result1 worker.Container
		result2 bool
		result3 error
	}
	findContainerByHandleReturnsOnCall map[int]struct {
		result1 worker.Container
		result2 bool
		result3 error
	}
	FindOrCreateContainerStub        func(context.Context, lager.Logger, worker.ImageFetchingDelegate, db.ContainerOwner, db.ContainerMetadata, worker.ContainerSpec, worker.WorkerSpec, creds.VersionedResourceTypes) (worker.Container, error)
	findOrCreateContainerMutex       sync.RWMutex
	findOrCreateContainerArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 worker.ImageFetchingDelegate
		arg4 db.ContainerOwner
		arg5 db.ContainerMetadata
		arg6 worker.ContainerSpec
		arg7 worker.WorkerSpec
		arg8 creds.VersionedResourceTypes
	}
	findOrCreateContainerReturns struct {
		result1 worker.Container
		result2 error
	}
	findOrCreateContainerReturnsOnCall map[int]struct {
		result1 worker.Container
		result2 error
	}
	FindResourceTypeByPathStub        func(string) (atc.WorkerResourceType, bool)
	findResourceTypeByPathMutex       sync.RWMutex
	findResourceTypeByPathArgsForCall []struct {
		arg1 string
	}
	findResourceTypeByPathReturns struct {
		result1 atc.WorkerResourceType
		result2 bool
	}
	findResourceTypeByPathReturnsOnCall map[int]struct {
		result1 atc.WorkerResourceType
		result2 bool
	}
	FindVolumeForResourceCacheStub        func(lager.Logger, db.UsedResourceCache) (worker.Volume, bool, error)
	findVolumeForResourceCacheMutex       sync.RWMutex
	findVolumeForResourceCacheArgsForCall []struct {
		arg1 lager.Logger
		arg2 db.UsedResourceCache
	}
	findVolumeForResourceCacheReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	findVolumeForResourceCacheReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	FindVolumeForTaskCacheStub        func(lager.Logger, int, int, string, string) (worker.Volume, bool, error)
	findVolumeForTaskCacheMutex       sync.RWMutex
	findVolumeForTaskCacheArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
		arg3 int
		arg4 string
		arg5 string
	}
	findVolumeForTaskCacheReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	findVolumeForTaskCacheReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	GardenClientStub        func() garden.Client
	gardenClientMutex       sync.RWMutex
	gardenClientArgsForCall []struct {
	}
	gardenClientReturns struct {
		result1 garden.Client
	}
	gardenClientReturnsOnCall map[int]struct {
		result1 garden.Client
	}
	IsOwnedByTeamStub        func() bool
	isOwnedByTeamMutex       sync.RWMutex
	isOwnedByTeamArgsForCall []struct {
	}
	isOwnedByTeamReturns struct {
		result1 bool
	}
	isOwnedByTeamReturnsOnCall map[int]struct {
		result1 bool
	}
	IsVersionCompatibleStub        func(lager.Logger, version.Version) bool
	isVersionCompatibleMutex       sync.RWMutex
	isVersionCompatibleArgsForCall []struct {
		arg1 lager.Logger
		arg2 version.Version
	}
	isVersionCompatibleReturns struct {
		result1 bool
	}
	isVersionCompatibleReturnsOnCall map[int]struct {
		result1 bool
	}
	LookupVolumeStub        func(lager.Logger, string) (worker.Volume, bool, error)
	lookupVolumeMutex       sync.RWMutex
	lookupVolumeArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	lookupVolumeReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	lookupVolumeReturnsOnCall map[int]struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ResourceTypesStub        func() []atc.WorkerResourceType
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct {
	}
	resourceTypesReturns struct {
		result1 []atc.WorkerResourceType
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 []atc.WorkerResourceType
	}
	SatisfyingStub        func(lager.Logger, worker.WorkerSpec) (worker.Worker, error)
	satisfyingMutex       sync.RWMutex
	satisfyingArgsForCall []struct {
		arg1 lager.Logger
		arg2 worker.WorkerSpec
	}
	satisfyingReturns struct {
		result1 worker.Worker
		result2 error
	}
	satisfyingReturnsOnCall map[int]struct {
		result1 worker.Worker
		result2 error
	}
	TagsStub        func() atc.Tags
	tagsMutex       sync.RWMutex
	tagsArgsForCall []struct {
	}
	tagsReturns struct {
		result1 atc.Tags
	}
	tagsReturnsOnCall map[int]struct {
		result1 atc.Tags
	}
	UptimeStub        func() time.Duration
	uptimeMutex       sync.RWMutex
	uptimeArgsForCall []struct {
	}
	uptimeReturns struct {
		result1 time.Duration
	}
	uptimeReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorker) ActiveContainers() int {
	fake.activeContainersMutex.Lock()
	ret, specificReturn := fake.activeContainersReturnsOnCall[len(fake.activeContainersArgsForCall)]
	fake.activeContainersArgsForCall = append(fake.activeContainersArgsForCall, struct {
	}{})
	fake.recordInvocation("ActiveContainers", []interface{}{})
	fake.activeContainersMutex.Unlock()
	if fake.ActiveContainersStub != nil {
		return fake.ActiveContainersStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.activeContainersReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) ActiveContainersCallCount() int {
	fake.activeContainersMutex.RLock()
	defer fake.activeContainersMutex.RUnlock()
	return len(fake.activeContainersArgsForCall)
}

func (fake *FakeWorker) ActiveContainersCalls(stub func() int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = stub
}

func (fake *FakeWorker) ActiveContainersReturns(result1 int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = nil
	fake.activeContainersReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveContainersReturnsOnCall(i int, result1 int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = nil
	if fake.activeContainersReturnsOnCall == nil {
		fake.activeContainersReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.activeContainersReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveVolumes() int {
	fake.activeVolumesMutex.Lock()
	ret, specificReturn := fake.activeVolumesReturnsOnCall[len(fake.activeVolumesArgsForCall)]
	fake.activeVolumesArgsForCall = append(fake.activeVolumesArgsForCall, struct {
	}{})
	fake.recordInvocation("ActiveVolumes", []interface{}{})
	fake.activeVolumesMutex.Unlock()
	if fake.ActiveVolumesStub != nil {
		return fake.ActiveVolumesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.activeVolumesReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) ActiveVolumesCallCount() int {
	fake.activeVolumesMutex.RLock()
	defer fake.activeVolumesMutex.RUnlock()
	return len(fake.activeVolumesArgsForCall)
}

func (fake *FakeWorker) ActiveVolumesCalls(stub func() int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = stub
}

func (fake *FakeWorker) ActiveVolumesReturns(result1 int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = nil
	fake.activeVolumesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveVolumesReturnsOnCall(i int, result1 int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = nil
	if fake.activeVolumesReturnsOnCall == nil {
		fake.activeVolumesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.activeVolumesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) CertsVolume(arg1 lager.Logger) (worker.Volume, bool, error) {
	fake.certsVolumeMutex.Lock()
	ret, specificReturn := fake.certsVolumeReturnsOnCall[len(fake.certsVolumeArgsForCall)]
	fake.certsVolumeArgsForCall = append(fake.certsVolumeArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("CertsVolume", []interface{}{arg1})
	fake.certsVolumeMutex.Unlock()
	if fake.CertsVolumeStub != nil {
		return fake.CertsVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.certsVolumeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) CertsVolumeCallCount() int {
	fake.certsVolumeMutex.RLock()
	defer fake.certsVolumeMutex.RUnlock()
	return len(fake.certsVolumeArgsForCall)
}

func (fake *FakeWorker) CertsVolumeCalls(stub func(lager.Logger) (worker.Volume, bool, error)) {
	fake.certsVolumeMutex.Lock()
	defer fake.certsVolumeMutex.Unlock()
	fake.CertsVolumeStub = stub
}

func (fake *FakeWorker) CertsVolumeArgsForCall(i int) lager.Logger {
	fake.certsVolumeMutex.RLock()
	defer fake.certsVolumeMutex.RUnlock()
	argsForCall := fake.certsVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorker) CertsVolumeReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.certsVolumeMutex.Lock()
	defer fake.certsVolumeMutex.Unlock()
	fake.CertsVolumeStub = nil
	fake.certsVolumeReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) CertsVolumeReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.certsVolumeMutex.Lock()
	defer fake.certsVolumeMutex.Unlock()
	fake.CertsVolumeStub = nil
	if fake.certsVolumeReturnsOnCall == nil {
		fake.certsVolumeReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.certsVolumeReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) Description() string {
	fake.descriptionMutex.Lock()
	ret, specificReturn := fake.descriptionReturnsOnCall[len(fake.descriptionArgsForCall)]
	fake.descriptionArgsForCall = append(fake.descriptionArgsForCall, struct {
	}{})
	fake.recordInvocation("Description", []interface{}{})
	fake.descriptionMutex.Unlock()
	if fake.DescriptionStub != nil {
		return fake.DescriptionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.descriptionReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) DescriptionCallCount() int {
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	return len(fake.descriptionArgsForCall)
}

func (fake *FakeWorker) DescriptionCalls(stub func() string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = stub
}

func (fake *FakeWorker) DescriptionReturns(result1 string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = nil
	fake.descriptionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) DescriptionReturnsOnCall(i int, result1 string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = nil
	if fake.descriptionReturnsOnCall == nil {
		fake.descriptionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.descriptionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Ephemeral() bool {
	fake.ephemeralMutex.Lock()
	ret, specificReturn := fake.ephemeralReturnsOnCall[len(fake.ephemeralArgsForCall)]
	fake.ephemeralArgsForCall = append(fake.ephemeralArgsForCall, struct {
	}{})
	fake.recordInvocation("Ephemeral", []interface{}{})
	fake.ephemeralMutex.Unlock()
	if fake.EphemeralStub != nil {
		return fake.EphemeralStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.ephemeralReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) EphemeralCallCount() int {
	fake.ephemeralMutex.RLock()
	defer fake.ephemeralMutex.RUnlock()
	return len(fake.ephemeralArgsForCall)
}

func (fake *FakeWorker) EphemeralCalls(stub func() bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = stub
}

func (fake *FakeWorker) EphemeralReturns(result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	fake.ephemeralReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) EphemeralReturnsOnCall(i int, result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	if fake.ephemeralReturnsOnCall == nil {
		fake.ephemeralReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ephemeralReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) FindContainerByHandle(arg1 lager.Logger, arg2 int, arg3 string) (worker.Container, bool, error) {
	fake.findContainerByHandleMutex.Lock()
	ret, specificReturn := fake.findContainerByHandleReturnsOnCall[len(fake.findContainerByHandleArgsForCall)]
	fake.findContainerByHandleArgsForCall = append(fake.findContainerByHandleArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("FindContainerByHandle", []interface{}{arg1, arg2, arg3})
	fake.findContainerByHandleMutex.Unlock()
	if fake.FindContainerByHandleStub != nil {
		return fake.FindContainerByHandleStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findContainerByHandleReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindContainerByHandleCallCount() int {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	return len(fake.findContainerByHandleArgsForCall)
}

func (fake *FakeWorker) FindContainerByHandleCalls(stub func(lager.Logger, int, string) (worker.Container, bool, error)) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = stub
}

func (fake *FakeWorker) FindContainerByHandleArgsForCall(i int) (lager.Logger, int, string) {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	argsForCall := fake.findContainerByHandleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorker) FindContainerByHandleReturns(result1 worker.Container, result2 bool, result3 error) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = nil
	fake.findContainerByHandleReturns = struct {
		result1 worker.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindContainerByHandleReturnsOnCall(i int, result1 worker.Container, result2 bool, result3 error) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = nil
	if fake.findContainerByHandleReturnsOnCall == nil {
		fake.findContainerByHandleReturnsOnCall = make(map[int]struct {
			result1 worker.Container
			result2 bool
			result3 error
		})
	}
	fake.findContainerByHandleReturnsOnCall[i] = struct {
		result1 worker.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindOrCreateContainer(arg1 context.Context, arg2 lager.Logger, arg3 worker.ImageFetchingDelegate, arg4 db.ContainerOwner, arg5 db.ContainerMetadata, arg6 worker.ContainerSpec, arg7 worker.WorkerSpec, arg8 creds.VersionedResourceTypes) (worker.Container, error) {
	fake.findOrCreateContainerMutex.Lock()
	ret, specificReturn := fake.findOrCreateContainerReturnsOnCall[len(fake.findOrCreateContainerArgsForCall)]
	fake.findOrCreateContainerArgsForCall = append(fake.findOrCreateContainerArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 worker.ImageFetchingDelegate
		arg4 db.ContainerOwner
		arg5 db.ContainerMetadata
		arg6 worker.ContainerSpec
		arg7 worker.WorkerSpec
		arg8 creds.VersionedResourceTypes
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	fake.recordInvocation("FindOrCreateContainer", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	fake.findOrCreateContainerMutex.Unlock()
	if fake.FindOrCreateContainerStub != nil {
		return fake.FindOrCreateContainerStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findOrCreateContainerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) FindOrCreateContainerCallCount() int {
	fake.findOrCreateContainerMutex.RLock()
	defer fake.findOrCreateContainerMutex.RUnlock()
	return len(fake.findOrCreateContainerArgsForCall)
}

func (fake *FakeWorker) FindOrCreateContainerCalls(stub func(context.Context, lager.Logger, worker.ImageFetchingDelegate, db.ContainerOwner, db.ContainerMetadata, worker.ContainerSpec, worker.WorkerSpec, creds.VersionedResourceTypes) (worker.Container, error)) {
	fake.findOrCreateContainerMutex.Lock()
	defer fake.findOrCreateContainerMutex.Unlock()
	fake.FindOrCreateContainerStub = stub
}

func (fake *FakeWorker) FindOrCreateContainerArgsForCall(i int) (context.Context, lager.Logger, worker.ImageFetchingDelegate, db.ContainerOwner, db.ContainerMetadata, worker.ContainerSpec, worker.WorkerSpec, creds.VersionedResourceTypes) {
	fake.findOrCreateContainerMutex.RLock()
	defer fake.findOrCreateContainerMutex.RUnlock()
	argsForCall := fake.findOrCreateContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8
}

func (fake *FakeWorker) FindOrCreateContainerReturns(result1 worker.Container, result2 error) {
	fake.findOrCreateContainerMutex.Lock()
	defer fake.findOrCreateContainerMutex.Unlock()
	fake.FindOrCreateContainerStub = nil
	fake.findOrCreateContainerReturns = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindOrCreateContainerReturnsOnCall(i int, result1 worker.Container, result2 error) {
	fake.findOrCreateContainerMutex.Lock()
	defer fake.findOrCreateContainerMutex.Unlock()
	fake.FindOrCreateContainerStub = nil
	if fake.findOrCreateContainerReturnsOnCall == nil {
		fake.findOrCreateContainerReturnsOnCall = make(map[int]struct {
			result1 worker.Container
			result2 error
		})
	}
	fake.findOrCreateContainerReturnsOnCall[i] = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindResourceTypeByPath(arg1 string) (atc.WorkerResourceType, bool) {
	fake.findResourceTypeByPathMutex.Lock()
	ret, specificReturn := fake.findResourceTypeByPathReturnsOnCall[len(fake.findResourceTypeByPathArgsForCall)]
	fake.findResourceTypeByPathArgsForCall = append(fake.findResourceTypeByPathArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindResourceTypeByPath", []interface{}{arg1})
	fake.findResourceTypeByPathMutex.Unlock()
	if fake.FindResourceTypeByPathStub != nil {
		return fake.FindResourceTypeByPathStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findResourceTypeByPathReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) FindResourceTypeByPathCallCount() int {
	fake.findResourceTypeByPathMutex.RLock()
	defer fake.findResourceTypeByPathMutex.RUnlock()
	return len(fake.findResourceTypeByPathArgsForCall)
}

func (fake *FakeWorker) FindResourceTypeByPathCalls(stub func(string) (atc.WorkerResourceType, bool)) {
	fake.findResourceTypeByPathMutex.Lock()
	defer fake.findResourceTypeByPathMutex.Unlock()
	fake.FindResourceTypeByPathStub = stub
}

func (fake *FakeWorker) FindResourceTypeByPathArgsForCall(i int) string {
	fake.findResourceTypeByPathMutex.RLock()
	defer fake.findResourceTypeByPathMutex.RUnlock()
	argsForCall := fake.findResourceTypeByPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorker) FindResourceTypeByPathReturns(result1 atc.WorkerResourceType, result2 bool) {
	fake.findResourceTypeByPathMutex.Lock()
	defer fake.findResourceTypeByPathMutex.Unlock()
	fake.FindResourceTypeByPathStub = nil
	fake.findResourceTypeByPathReturns = struct {
		result1 atc.WorkerResourceType
		result2 bool
	}{result1, result2}
}

func (fake *FakeWorker) FindResourceTypeByPathReturnsOnCall(i int, result1 atc.WorkerResourceType, result2 bool) {
	fake.findResourceTypeByPathMutex.Lock()
	defer fake.findResourceTypeByPathMutex.Unlock()
	fake.FindResourceTypeByPathStub = nil
	if fake.findResourceTypeByPathReturnsOnCall == nil {
		fake.findResourceTypeByPathReturnsOnCall = make(map[int]struct {
			result1 atc.WorkerResourceType
			result2 bool
		})
	}
	fake.findResourceTypeByPathReturnsOnCall[i] = struct {
		result1 atc.WorkerResourceType
		result2 bool
	}{result1, result2}
}

func (fake *FakeWorker) FindVolumeForResourceCache(arg1 lager.Logger, arg2 db.UsedResourceCache) (worker.Volume, bool, error) {
	fake.findVolumeForResourceCacheMutex.Lock()
	ret, specificReturn := fake.findVolumeForResourceCacheReturnsOnCall[len(fake.findVolumeForResourceCacheArgsForCall)]
	fake.findVolumeForResourceCacheArgsForCall = append(fake.findVolumeForResourceCacheArgsForCall, struct {
		arg1 lager.Logger
		arg2 db.UsedResourceCache
	}{arg1, arg2})
	fake.recordInvocation("FindVolumeForResourceCache", []interface{}{arg1, arg2})
	fake.findVolumeForResourceCacheMutex.Unlock()
	if fake.FindVolumeForResourceCacheStub != nil {
		return fake.FindVolumeForResourceCacheStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findVolumeForResourceCacheReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindVolumeForResourceCacheCallCount() int {
	fake.findVolumeForResourceCacheMutex.RLock()
	defer fake.findVolumeForResourceCacheMutex.RUnlock()
	return len(fake.findVolumeForResourceCacheArgsForCall)
}

func (fake *FakeWorker) FindVolumeForResourceCacheCalls(stub func(lager.Logger, db.UsedResourceCache) (worker.Volume, bool, error)) {
	fake.findVolumeForResourceCacheMutex.Lock()
	defer fake.findVolumeForResourceCacheMutex.Unlock()
	fake.FindVolumeForResourceCacheStub = stub
}

func (fake *FakeWorker) FindVolumeForResourceCacheArgsForCall(i int) (lager.Logger, db.UsedResourceCache) {
	fake.findVolumeForResourceCacheMutex.RLock()
	defer fake.findVolumeForResourceCacheMutex.RUnlock()
	argsForCall := fake.findVolumeForResourceCacheArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) FindVolumeForResourceCacheReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForResourceCacheMutex.Lock()
	defer fake.findVolumeForResourceCacheMutex.Unlock()
	fake.FindVolumeForResourceCacheStub = nil
	fake.findVolumeForResourceCacheReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForResourceCacheReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForResourceCacheMutex.Lock()
	defer fake.findVolumeForResourceCacheMutex.Unlock()
	fake.FindVolumeForResourceCacheStub = nil
	if fake.findVolumeForResourceCacheReturnsOnCall == nil {
		fake.findVolumeForResourceCacheReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.findVolumeForResourceCacheReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForTaskCache(arg1 lager.Logger, arg2 int, arg3 int, arg4 string, arg5 string) (worker.Volume, bool, error) {
	fake.findVolumeForTaskCacheMutex.Lock()
	ret, specificReturn := fake.findVolumeForTaskCacheReturnsOnCall[len(fake.findVolumeForTaskCacheArgsForCall)]
	fake.findVolumeForTaskCacheArgsForCall = append(fake.findVolumeForTaskCacheArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
		arg3 int
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("FindVolumeForTaskCache", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.findVolumeForTaskCacheMutex.Unlock()
	if fake.FindVolumeForTaskCacheStub != nil {
		return fake.FindVolumeForTaskCacheStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findVolumeForTaskCacheReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindVolumeForTaskCacheCallCount() int {
	fake.findVolumeForTaskCacheMutex.RLock()
	defer fake.findVolumeForTaskCacheMutex.RUnlock()
	return len(fake.findVolumeForTaskCacheArgsForCall)
}

func (fake *FakeWorker) FindVolumeForTaskCacheCalls(stub func(lager.Logger, int, int, string, string) (worker.Volume, bool, error)) {
	fake.findVolumeForTaskCacheMutex.Lock()
	defer fake.findVolumeForTaskCacheMutex.Unlock()
	fake.FindVolumeForTaskCacheStub = stub
}

func (fake *FakeWorker) FindVolumeForTaskCacheArgsForCall(i int) (lager.Logger, int, int, string, string) {
	fake.findVolumeForTaskCacheMutex.RLock()
	defer fake.findVolumeForTaskCacheMutex.RUnlock()
	argsForCall := fake.findVolumeForTaskCacheArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeWorker) FindVolumeForTaskCacheReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForTaskCacheMutex.Lock()
	defer fake.findVolumeForTaskCacheMutex.Unlock()
	fake.FindVolumeForTaskCacheStub = nil
	fake.findVolumeForTaskCacheReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindVolumeForTaskCacheReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.findVolumeForTaskCacheMutex.Lock()
	defer fake.findVolumeForTaskCacheMutex.Unlock()
	fake.FindVolumeForTaskCacheStub = nil
	if fake.findVolumeForTaskCacheReturnsOnCall == nil {
		fake.findVolumeForTaskCacheReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.findVolumeForTaskCacheReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) GardenClient() garden.Client {
	fake.gardenClientMutex.Lock()
	ret, specificReturn := fake.gardenClientReturnsOnCall[len(fake.gardenClientArgsForCall)]
	fake.gardenClientArgsForCall = append(fake.gardenClientArgsForCall, struct {
	}{})
	fake.recordInvocation("GardenClient", []interface{}{})
	fake.gardenClientMutex.Unlock()
	if fake.GardenClientStub != nil {
		return fake.GardenClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.gardenClientReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) GardenClientCallCount() int {
	fake.gardenClientMutex.RLock()
	defer fake.gardenClientMutex.RUnlock()
	return len(fake.gardenClientArgsForCall)
}

func (fake *FakeWorker) GardenClientCalls(stub func() garden.Client) {
	fake.gardenClientMutex.Lock()
	defer fake.gardenClientMutex.Unlock()
	fake.GardenClientStub = stub
}

func (fake *FakeWorker) GardenClientReturns(result1 garden.Client) {
	fake.gardenClientMutex.Lock()
	defer fake.gardenClientMutex.Unlock()
	fake.GardenClientStub = nil
	fake.gardenClientReturns = struct {
		result1 garden.Client
	}{result1}
}

func (fake *FakeWorker) GardenClientReturnsOnCall(i int, result1 garden.Client) {
	fake.gardenClientMutex.Lock()
	defer fake.gardenClientMutex.Unlock()
	fake.GardenClientStub = nil
	if fake.gardenClientReturnsOnCall == nil {
		fake.gardenClientReturnsOnCall = make(map[int]struct {
			result1 garden.Client
		})
	}
	fake.gardenClientReturnsOnCall[i] = struct {
		result1 garden.Client
	}{result1}
}

func (fake *FakeWorker) IsOwnedByTeam() bool {
	fake.isOwnedByTeamMutex.Lock()
	ret, specificReturn := fake.isOwnedByTeamReturnsOnCall[len(fake.isOwnedByTeamArgsForCall)]
	fake.isOwnedByTeamArgsForCall = append(fake.isOwnedByTeamArgsForCall, struct {
	}{})
	fake.recordInvocation("IsOwnedByTeam", []interface{}{})
	fake.isOwnedByTeamMutex.Unlock()
	if fake.IsOwnedByTeamStub != nil {
		return fake.IsOwnedByTeamStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isOwnedByTeamReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) IsOwnedByTeamCallCount() int {
	fake.isOwnedByTeamMutex.RLock()
	defer fake.isOwnedByTeamMutex.RUnlock()
	return len(fake.isOwnedByTeamArgsForCall)
}

func (fake *FakeWorker) IsOwnedByTeamCalls(stub func() bool) {
	fake.isOwnedByTeamMutex.Lock()
	defer fake.isOwnedByTeamMutex.Unlock()
	fake.IsOwnedByTeamStub = stub
}

func (fake *FakeWorker) IsOwnedByTeamReturns(result1 bool) {
	fake.isOwnedByTeamMutex.Lock()
	defer fake.isOwnedByTeamMutex.Unlock()
	fake.IsOwnedByTeamStub = nil
	fake.isOwnedByTeamReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsOwnedByTeamReturnsOnCall(i int, result1 bool) {
	fake.isOwnedByTeamMutex.Lock()
	defer fake.isOwnedByTeamMutex.Unlock()
	fake.IsOwnedByTeamStub = nil
	if fake.isOwnedByTeamReturnsOnCall == nil {
		fake.isOwnedByTeamReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isOwnedByTeamReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsVersionCompatible(arg1 lager.Logger, arg2 version.Version) bool {
	fake.isVersionCompatibleMutex.Lock()
	ret, specificReturn := fake.isVersionCompatibleReturnsOnCall[len(fake.isVersionCompatibleArgsForCall)]
	fake.isVersionCompatibleArgsForCall = append(fake.isVersionCompatibleArgsForCall, struct {
		arg1 lager.Logger
		arg2 version.Version
	}{arg1, arg2})
	fake.recordInvocation("IsVersionCompatible", []interface{}{arg1, arg2})
	fake.isVersionCompatibleMutex.Unlock()
	if fake.IsVersionCompatibleStub != nil {
		return fake.IsVersionCompatibleStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isVersionCompatibleReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) IsVersionCompatibleCallCount() int {
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	return len(fake.isVersionCompatibleArgsForCall)
}

func (fake *FakeWorker) IsVersionCompatibleCalls(stub func(lager.Logger, version.Version) bool) {
	fake.isVersionCompatibleMutex.Lock()
	defer fake.isVersionCompatibleMutex.Unlock()
	fake.IsVersionCompatibleStub = stub
}

func (fake *FakeWorker) IsVersionCompatibleArgsForCall(i int) (lager.Logger, version.Version) {
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	argsForCall := fake.isVersionCompatibleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) IsVersionCompatibleReturns(result1 bool) {
	fake.isVersionCompatibleMutex.Lock()
	defer fake.isVersionCompatibleMutex.Unlock()
	fake.IsVersionCompatibleStub = nil
	fake.isVersionCompatibleReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsVersionCompatibleReturnsOnCall(i int, result1 bool) {
	fake.isVersionCompatibleMutex.Lock()
	defer fake.isVersionCompatibleMutex.Unlock()
	fake.IsVersionCompatibleStub = nil
	if fake.isVersionCompatibleReturnsOnCall == nil {
		fake.isVersionCompatibleReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isVersionCompatibleReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) LookupVolume(arg1 lager.Logger, arg2 string) (worker.Volume, bool, error) {
	fake.lookupVolumeMutex.Lock()
	ret, specificReturn := fake.lookupVolumeReturnsOnCall[len(fake.lookupVolumeArgsForCall)]
	fake.lookupVolumeArgsForCall = append(fake.lookupVolumeArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("LookupVolume", []interface{}{arg1, arg2})
	fake.lookupVolumeMutex.Unlock()
	if fake.LookupVolumeStub != nil {
		return fake.LookupVolumeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.lookupVolumeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) LookupVolumeCallCount() int {
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	return len(fake.lookupVolumeArgsForCall)
}

func (fake *FakeWorker) LookupVolumeCalls(stub func(lager.Logger, string) (worker.Volume, bool, error)) {
	fake.lookupVolumeMutex.Lock()
	defer fake.lookupVolumeMutex.Unlock()
	fake.LookupVolumeStub = stub
}

func (fake *FakeWorker) LookupVolumeArgsForCall(i int) (lager.Logger, string) {
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	argsForCall := fake.lookupVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) LookupVolumeReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.lookupVolumeMutex.Lock()
	defer fake.lookupVolumeMutex.Unlock()
	fake.LookupVolumeStub = nil
	fake.lookupVolumeReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) LookupVolumeReturnsOnCall(i int, result1 worker.Volume, result2 bool, result3 error) {
	fake.lookupVolumeMutex.Lock()
	defer fake.lookupVolumeMutex.Unlock()
	fake.LookupVolumeStub = nil
	if fake.lookupVolumeReturnsOnCall == nil {
		fake.lookupVolumeReturnsOnCall = make(map[int]struct {
			result1 worker.Volume
			result2 bool
			result3 error
		})
	}
	fake.lookupVolumeReturnsOnCall[i] = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeWorker) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeWorker) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) ResourceTypes() []atc.WorkerResourceType {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if fake.ResourceTypesStub != nil {
		return fake.ResourceTypesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceTypesReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakeWorker) ResourceTypesCalls(stub func() []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = stub
}

func (fake *FakeWorker) ResourceTypesReturns(result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) ResourceTypesReturnsOnCall(i int, result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 []atc.WorkerResourceType
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) Satisfying(arg1 lager.Logger, arg2 worker.WorkerSpec) (worker.Worker, error) {
	fake.satisfyingMutex.Lock()
	ret, specificReturn := fake.satisfyingReturnsOnCall[len(fake.satisfyingArgsForCall)]
	fake.satisfyingArgsForCall = append(fake.satisfyingArgsForCall, struct {
		arg1 lager.Logger
		arg2 worker.WorkerSpec
	}{arg1, arg2})
	fake.recordInvocation("Satisfying", []interface{}{arg1, arg2})
	fake.satisfyingMutex.Unlock()
	if fake.SatisfyingStub != nil {
		return fake.SatisfyingStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.satisfyingReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) SatisfyingCallCount() int {
	fake.satisfyingMutex.RLock()
	defer fake.satisfyingMutex.RUnlock()
	return len(fake.satisfyingArgsForCall)
}

func (fake *FakeWorker) SatisfyingCalls(stub func(lager.Logger, worker.WorkerSpec) (worker.Worker, error)) {
	fake.satisfyingMutex.Lock()
	defer fake.satisfyingMutex.Unlock()
	fake.SatisfyingStub = stub
}

func (fake *FakeWorker) SatisfyingArgsForCall(i int) (lager.Logger, worker.WorkerSpec) {
	fake.satisfyingMutex.RLock()
	defer fake.satisfyingMutex.RUnlock()
	argsForCall := fake.satisfyingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) SatisfyingReturns(result1 worker.Worker, result2 error) {
	fake.satisfyingMutex.Lock()
	defer fake.satisfyingMutex.Unlock()
	fake.SatisfyingStub = nil
	fake.satisfyingReturns = struct {
		result1 worker.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) SatisfyingReturnsOnCall(i int, result1 worker.Worker, result2 error) {
	fake.satisfyingMutex.Lock()
	defer fake.satisfyingMutex.Unlock()
	fake.SatisfyingStub = nil
	if fake.satisfyingReturnsOnCall == nil {
		fake.satisfyingReturnsOnCall = make(map[int]struct {
			result1 worker.Worker
			result2 error
		})
	}
	fake.satisfyingReturnsOnCall[i] = struct {
		result1 worker.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) Tags() atc.Tags {
	fake.tagsMutex.Lock()
	ret, specificReturn := fake.tagsReturnsOnCall[len(fake.tagsArgsForCall)]
	fake.tagsArgsForCall = append(fake.tagsArgsForCall, struct {
	}{})
	fake.recordInvocation("Tags", []interface{}{})
	fake.tagsMutex.Unlock()
	if fake.TagsStub != nil {
		return fake.TagsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tagsReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) TagsCallCount() int {
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	return len(fake.tagsArgsForCall)
}

func (fake *FakeWorker) TagsCalls(stub func() atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = stub
}

func (fake *FakeWorker) TagsReturns(result1 atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	fake.tagsReturns = struct {
		result1 atc.Tags
	}{result1}
}

func (fake *FakeWorker) TagsReturnsOnCall(i int, result1 atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	if fake.tagsReturnsOnCall == nil {
		fake.tagsReturnsOnCall = make(map[int]struct {
			result1 atc.Tags
		})
	}
	fake.tagsReturnsOnCall[i] = struct {
		result1 atc.Tags
	}{result1}
}

func (fake *FakeWorker) Uptime() time.Duration {
	fake.uptimeMutex.Lock()
	ret, specificReturn := fake.uptimeReturnsOnCall[len(fake.uptimeArgsForCall)]
	fake.uptimeArgsForCall = append(fake.uptimeArgsForCall, struct {
	}{})
	fake.recordInvocation("Uptime", []interface{}{})
	fake.uptimeMutex.Unlock()
	if fake.UptimeStub != nil {
		return fake.UptimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uptimeReturns
	return fakeReturns.result1
}

func (fake *FakeWorker) UptimeCallCount() int {
	fake.uptimeMutex.RLock()
	defer fake.uptimeMutex.RUnlock()
	return len(fake.uptimeArgsForCall)
}

func (fake *FakeWorker) UptimeCalls(stub func() time.Duration) {
	fake.uptimeMutex.Lock()
	defer fake.uptimeMutex.Unlock()
	fake.UptimeStub = stub
}

func (fake *FakeWorker) UptimeReturns(result1 time.Duration) {
	fake.uptimeMutex.Lock()
	defer fake.uptimeMutex.Unlock()
	fake.UptimeStub = nil
	fake.uptimeReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeWorker) UptimeReturnsOnCall(i int, result1 time.Duration) {
	fake.uptimeMutex.Lock()
	defer fake.uptimeMutex.Unlock()
	fake.UptimeStub = nil
	if fake.uptimeReturnsOnCall == nil {
		fake.uptimeReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.uptimeReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeWorker) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activeContainersMutex.RLock()
	defer fake.activeContainersMutex.RUnlock()
	fake.activeVolumesMutex.RLock()
	defer fake.activeVolumesMutex.RUnlock()
	fake.certsVolumeMutex.RLock()
	defer fake.certsVolumeMutex.RUnlock()
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	fake.ephemeralMutex.RLock()
	defer fake.ephemeralMutex.RUnlock()
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	fake.findOrCreateContainerMutex.RLock()
	defer fake.findOrCreateContainerMutex.RUnlock()
	fake.findResourceTypeByPathMutex.RLock()
	defer fake.findResourceTypeByPathMutex.RUnlock()
	fake.findVolumeForResourceCacheMutex.RLock()
	defer fake.findVolumeForResourceCacheMutex.RUnlock()
	fake.findVolumeForTaskCacheMutex.RLock()
	defer fake.findVolumeForTaskCacheMutex.RUnlock()
	fake.gardenClientMutex.RLock()
	defer fake.gardenClientMutex.RUnlock()
	fake.isOwnedByTeamMutex.RLock()
	defer fake.isOwnedByTeamMutex.RUnlock()
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.satisfyingMutex.RLock()
	defer fake.satisfyingMutex.RUnlock()
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	fake.uptimeMutex.RLock()
	defer fake.uptimeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorker) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ worker.Worker = new(FakeWorker)
