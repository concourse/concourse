// Code generated by counterfeiter. DO NOT EDIT.
package workerfakes

import (
	"context"
	"io"
	"sync"
	"time"

	"code.cloudfoundry.org/garden"
	"github.com/concourse/concourse/atc/worker"
)

type FakeContainer struct {
	AttachStub        func(context.Context, string, garden.ProcessIO) (garden.Process, error)
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 garden.ProcessIO
	}
	attachReturns struct {
		result1 garden.Process
		result2 error
	}
	attachReturnsOnCall map[int]struct {
		result1 garden.Process
		result2 error
	}
	BulkNetOutStub        func([]garden.NetOutRule) error
	bulkNetOutMutex       sync.RWMutex
	bulkNetOutArgsForCall []struct {
		arg1 []garden.NetOutRule
	}
	bulkNetOutReturns struct {
		result1 error
	}
	bulkNetOutReturnsOnCall map[int]struct {
		result1 error
	}
	CurrentBandwidthLimitsStub        func() (garden.BandwidthLimits, error)
	currentBandwidthLimitsMutex       sync.RWMutex
	currentBandwidthLimitsArgsForCall []struct {
	}
	currentBandwidthLimitsReturns struct {
		result1 garden.BandwidthLimits
		result2 error
	}
	currentBandwidthLimitsReturnsOnCall map[int]struct {
		result1 garden.BandwidthLimits
		result2 error
	}
	CurrentCPULimitsStub        func() (garden.CPULimits, error)
	currentCPULimitsMutex       sync.RWMutex
	currentCPULimitsArgsForCall []struct {
	}
	currentCPULimitsReturns struct {
		result1 garden.CPULimits
		result2 error
	}
	currentCPULimitsReturnsOnCall map[int]struct {
		result1 garden.CPULimits
		result2 error
	}
	CurrentDiskLimitsStub        func() (garden.DiskLimits, error)
	currentDiskLimitsMutex       sync.RWMutex
	currentDiskLimitsArgsForCall []struct {
	}
	currentDiskLimitsReturns struct {
		result1 garden.DiskLimits
		result2 error
	}
	currentDiskLimitsReturnsOnCall map[int]struct {
		result1 garden.DiskLimits
		result2 error
	}
	CurrentMemoryLimitsStub        func() (garden.MemoryLimits, error)
	currentMemoryLimitsMutex       sync.RWMutex
	currentMemoryLimitsArgsForCall []struct {
	}
	currentMemoryLimitsReturns struct {
		result1 garden.MemoryLimits
		result2 error
	}
	currentMemoryLimitsReturnsOnCall map[int]struct {
		result1 garden.MemoryLimits
		result2 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	HandleStub        func() string
	handleMutex       sync.RWMutex
	handleArgsForCall []struct {
	}
	handleReturns struct {
		result1 string
	}
	handleReturnsOnCall map[int]struct {
		result1 string
	}
	InfoStub        func() (garden.ContainerInfo, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
	}
	infoReturns struct {
		result1 garden.ContainerInfo
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 garden.ContainerInfo
		result2 error
	}
	MarkAsHijackedStub        func() error
	markAsHijackedMutex       sync.RWMutex
	markAsHijackedArgsForCall []struct {
	}
	markAsHijackedReturns struct {
		result1 error
	}
	markAsHijackedReturnsOnCall map[int]struct {
		result1 error
	}
	MetricsStub        func() (garden.Metrics, error)
	metricsMutex       sync.RWMutex
	metricsArgsForCall []struct {
	}
	metricsReturns struct {
		result1 garden.Metrics
		result2 error
	}
	metricsReturnsOnCall map[int]struct {
		result1 garden.Metrics
		result2 error
	}
	NetInStub        func(uint32, uint32) (uint32, uint32, error)
	netInMutex       sync.RWMutex
	netInArgsForCall []struct {
		arg1 uint32
		arg2 uint32
	}
	netInReturns struct {
		result1 uint32
		result2 uint32
		result3 error
	}
	netInReturnsOnCall map[int]struct {
		result1 uint32
		result2 uint32
		result3 error
	}
	NetOutStub        func(garden.NetOutRule) error
	netOutMutex       sync.RWMutex
	netOutArgsForCall []struct {
		arg1 garden.NetOutRule
	}
	netOutReturns struct {
		result1 error
	}
	netOutReturnsOnCall map[int]struct {
		result1 error
	}
	PropertiesStub        func() (garden.Properties, error)
	propertiesMutex       sync.RWMutex
	propertiesArgsForCall []struct {
	}
	propertiesReturns struct {
		result1 garden.Properties
		result2 error
	}
	propertiesReturnsOnCall map[int]struct {
		result1 garden.Properties
		result2 error
	}
	PropertyStub        func(string) (string, error)
	propertyMutex       sync.RWMutex
	propertyArgsForCall []struct {
		arg1 string
	}
	propertyReturns struct {
		result1 string
		result2 error
	}
	propertyReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RemovePropertyStub        func(string) error
	removePropertyMutex       sync.RWMutex
	removePropertyArgsForCall []struct {
		arg1 string
	}
	removePropertyReturns struct {
		result1 error
	}
	removePropertyReturnsOnCall map[int]struct {
		result1 error
	}
	RunStub        func(context.Context, garden.ProcessSpec, garden.ProcessIO) (garden.Process, error)
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 context.Context
		arg2 garden.ProcessSpec
		arg3 garden.ProcessIO
	}
	runReturns struct {
		result1 garden.Process
		result2 error
	}
	runReturnsOnCall map[int]struct {
		result1 garden.Process
		result2 error
	}
	RunScriptStub        func(context.Context, string, []string, []byte, interface{}, io.Writer, bool) error
	runScriptMutex       sync.RWMutex
	runScriptArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []byte
		arg5 interface{}
		arg6 io.Writer
		arg7 bool
	}
	runScriptReturns struct {
		result1 error
	}
	runScriptReturnsOnCall map[int]struct {
		result1 error
	}
	SetGraceTimeStub        func(time.Duration) error
	setGraceTimeMutex       sync.RWMutex
	setGraceTimeArgsForCall []struct {
		arg1 time.Duration
	}
	setGraceTimeReturns struct {
		result1 error
	}
	setGraceTimeReturnsOnCall map[int]struct {
		result1 error
	}
	SetPropertyStub        func(string, string) error
	setPropertyMutex       sync.RWMutex
	setPropertyArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setPropertyReturns struct {
		result1 error
	}
	setPropertyReturnsOnCall map[int]struct {
		result1 error
	}
	StopStub        func(bool) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		arg1 bool
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	StreamInStub        func(garden.StreamInSpec) error
	streamInMutex       sync.RWMutex
	streamInArgsForCall []struct {
		arg1 garden.StreamInSpec
	}
	streamInReturns struct {
		result1 error
	}
	streamInReturnsOnCall map[int]struct {
		result1 error
	}
	StreamOutStub        func(garden.StreamOutSpec) (io.ReadCloser, error)
	streamOutMutex       sync.RWMutex
	streamOutArgsForCall []struct {
		arg1 garden.StreamOutSpec
	}
	streamOutReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	streamOutReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	VolumeMountsStub        func() []worker.VolumeMount
	volumeMountsMutex       sync.RWMutex
	volumeMountsArgsForCall []struct {
	}
	volumeMountsReturns struct {
		result1 []worker.VolumeMount
	}
	volumeMountsReturnsOnCall map[int]struct {
		result1 []worker.VolumeMount
	}
	WorkerNameStub        func() string
	workerNameMutex       sync.RWMutex
	workerNameArgsForCall []struct {
	}
	workerNameReturns struct {
		result1 string
	}
	workerNameReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainer) Attach(arg1 context.Context, arg2 string, arg3 garden.ProcessIO) (garden.Process, error) {
	fake.attachMutex.Lock()
	ret, specificReturn := fake.attachReturnsOnCall[len(fake.attachArgsForCall)]
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 garden.ProcessIO
	}{arg1, arg2, arg3})
	fake.recordInvocation("Attach", []interface{}{arg1, arg2, arg3})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		return fake.AttachStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.attachReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeContainer) AttachCalls(stub func(context.Context, string, garden.ProcessIO) (garden.Process, error)) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = stub
}

func (fake *FakeContainer) AttachArgsForCall(i int) (context.Context, string, garden.ProcessIO) {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	argsForCall := fake.attachArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContainer) AttachReturns(result1 garden.Process, result2 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	fake.attachReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) AttachReturnsOnCall(i int, result1 garden.Process, result2 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	if fake.attachReturnsOnCall == nil {
		fake.attachReturnsOnCall = make(map[int]struct {
			result1 garden.Process
			result2 error
		})
	}
	fake.attachReturnsOnCall[i] = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) BulkNetOut(arg1 []garden.NetOutRule) error {
	var arg1Copy []garden.NetOutRule
	if arg1 != nil {
		arg1Copy = make([]garden.NetOutRule, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.bulkNetOutMutex.Lock()
	ret, specificReturn := fake.bulkNetOutReturnsOnCall[len(fake.bulkNetOutArgsForCall)]
	fake.bulkNetOutArgsForCall = append(fake.bulkNetOutArgsForCall, struct {
		arg1 []garden.NetOutRule
	}{arg1Copy})
	fake.recordInvocation("BulkNetOut", []interface{}{arg1Copy})
	fake.bulkNetOutMutex.Unlock()
	if fake.BulkNetOutStub != nil {
		return fake.BulkNetOutStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.bulkNetOutReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) BulkNetOutCallCount() int {
	fake.bulkNetOutMutex.RLock()
	defer fake.bulkNetOutMutex.RUnlock()
	return len(fake.bulkNetOutArgsForCall)
}

func (fake *FakeContainer) BulkNetOutCalls(stub func([]garden.NetOutRule) error) {
	fake.bulkNetOutMutex.Lock()
	defer fake.bulkNetOutMutex.Unlock()
	fake.BulkNetOutStub = stub
}

func (fake *FakeContainer) BulkNetOutArgsForCall(i int) []garden.NetOutRule {
	fake.bulkNetOutMutex.RLock()
	defer fake.bulkNetOutMutex.RUnlock()
	argsForCall := fake.bulkNetOutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainer) BulkNetOutReturns(result1 error) {
	fake.bulkNetOutMutex.Lock()
	defer fake.bulkNetOutMutex.Unlock()
	fake.BulkNetOutStub = nil
	fake.bulkNetOutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) BulkNetOutReturnsOnCall(i int, result1 error) {
	fake.bulkNetOutMutex.Lock()
	defer fake.bulkNetOutMutex.Unlock()
	fake.BulkNetOutStub = nil
	if fake.bulkNetOutReturnsOnCall == nil {
		fake.bulkNetOutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bulkNetOutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) CurrentBandwidthLimits() (garden.BandwidthLimits, error) {
	fake.currentBandwidthLimitsMutex.Lock()
	ret, specificReturn := fake.currentBandwidthLimitsReturnsOnCall[len(fake.currentBandwidthLimitsArgsForCall)]
	fake.currentBandwidthLimitsArgsForCall = append(fake.currentBandwidthLimitsArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentBandwidthLimits", []interface{}{})
	fake.currentBandwidthLimitsMutex.Unlock()
	if fake.CurrentBandwidthLimitsStub != nil {
		return fake.CurrentBandwidthLimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentBandwidthLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) CurrentBandwidthLimitsCallCount() int {
	fake.currentBandwidthLimitsMutex.RLock()
	defer fake.currentBandwidthLimitsMutex.RUnlock()
	return len(fake.currentBandwidthLimitsArgsForCall)
}

func (fake *FakeContainer) CurrentBandwidthLimitsCalls(stub func() (garden.BandwidthLimits, error)) {
	fake.currentBandwidthLimitsMutex.Lock()
	defer fake.currentBandwidthLimitsMutex.Unlock()
	fake.CurrentBandwidthLimitsStub = stub
}

func (fake *FakeContainer) CurrentBandwidthLimitsReturns(result1 garden.BandwidthLimits, result2 error) {
	fake.currentBandwidthLimitsMutex.Lock()
	defer fake.currentBandwidthLimitsMutex.Unlock()
	fake.CurrentBandwidthLimitsStub = nil
	fake.currentBandwidthLimitsReturns = struct {
		result1 garden.BandwidthLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentBandwidthLimitsReturnsOnCall(i int, result1 garden.BandwidthLimits, result2 error) {
	fake.currentBandwidthLimitsMutex.Lock()
	defer fake.currentBandwidthLimitsMutex.Unlock()
	fake.CurrentBandwidthLimitsStub = nil
	if fake.currentBandwidthLimitsReturnsOnCall == nil {
		fake.currentBandwidthLimitsReturnsOnCall = make(map[int]struct {
			result1 garden.BandwidthLimits
			result2 error
		})
	}
	fake.currentBandwidthLimitsReturnsOnCall[i] = struct {
		result1 garden.BandwidthLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentCPULimits() (garden.CPULimits, error) {
	fake.currentCPULimitsMutex.Lock()
	ret, specificReturn := fake.currentCPULimitsReturnsOnCall[len(fake.currentCPULimitsArgsForCall)]
	fake.currentCPULimitsArgsForCall = append(fake.currentCPULimitsArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentCPULimits", []interface{}{})
	fake.currentCPULimitsMutex.Unlock()
	if fake.CurrentCPULimitsStub != nil {
		return fake.CurrentCPULimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentCPULimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) CurrentCPULimitsCallCount() int {
	fake.currentCPULimitsMutex.RLock()
	defer fake.currentCPULimitsMutex.RUnlock()
	return len(fake.currentCPULimitsArgsForCall)
}

func (fake *FakeContainer) CurrentCPULimitsCalls(stub func() (garden.CPULimits, error)) {
	fake.currentCPULimitsMutex.Lock()
	defer fake.currentCPULimitsMutex.Unlock()
	fake.CurrentCPULimitsStub = stub
}

func (fake *FakeContainer) CurrentCPULimitsReturns(result1 garden.CPULimits, result2 error) {
	fake.currentCPULimitsMutex.Lock()
	defer fake.currentCPULimitsMutex.Unlock()
	fake.CurrentCPULimitsStub = nil
	fake.currentCPULimitsReturns = struct {
		result1 garden.CPULimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentCPULimitsReturnsOnCall(i int, result1 garden.CPULimits, result2 error) {
	fake.currentCPULimitsMutex.Lock()
	defer fake.currentCPULimitsMutex.Unlock()
	fake.CurrentCPULimitsStub = nil
	if fake.currentCPULimitsReturnsOnCall == nil {
		fake.currentCPULimitsReturnsOnCall = make(map[int]struct {
			result1 garden.CPULimits
			result2 error
		})
	}
	fake.currentCPULimitsReturnsOnCall[i] = struct {
		result1 garden.CPULimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentDiskLimits() (garden.DiskLimits, error) {
	fake.currentDiskLimitsMutex.Lock()
	ret, specificReturn := fake.currentDiskLimitsReturnsOnCall[len(fake.currentDiskLimitsArgsForCall)]
	fake.currentDiskLimitsArgsForCall = append(fake.currentDiskLimitsArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentDiskLimits", []interface{}{})
	fake.currentDiskLimitsMutex.Unlock()
	if fake.CurrentDiskLimitsStub != nil {
		return fake.CurrentDiskLimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentDiskLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) CurrentDiskLimitsCallCount() int {
	fake.currentDiskLimitsMutex.RLock()
	defer fake.currentDiskLimitsMutex.RUnlock()
	return len(fake.currentDiskLimitsArgsForCall)
}

func (fake *FakeContainer) CurrentDiskLimitsCalls(stub func() (garden.DiskLimits, error)) {
	fake.currentDiskLimitsMutex.Lock()
	defer fake.currentDiskLimitsMutex.Unlock()
	fake.CurrentDiskLimitsStub = stub
}

func (fake *FakeContainer) CurrentDiskLimitsReturns(result1 garden.DiskLimits, result2 error) {
	fake.currentDiskLimitsMutex.Lock()
	defer fake.currentDiskLimitsMutex.Unlock()
	fake.CurrentDiskLimitsStub = nil
	fake.currentDiskLimitsReturns = struct {
		result1 garden.DiskLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentDiskLimitsReturnsOnCall(i int, result1 garden.DiskLimits, result2 error) {
	fake.currentDiskLimitsMutex.Lock()
	defer fake.currentDiskLimitsMutex.Unlock()
	fake.CurrentDiskLimitsStub = nil
	if fake.currentDiskLimitsReturnsOnCall == nil {
		fake.currentDiskLimitsReturnsOnCall = make(map[int]struct {
			result1 garden.DiskLimits
			result2 error
		})
	}
	fake.currentDiskLimitsReturnsOnCall[i] = struct {
		result1 garden.DiskLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentMemoryLimits() (garden.MemoryLimits, error) {
	fake.currentMemoryLimitsMutex.Lock()
	ret, specificReturn := fake.currentMemoryLimitsReturnsOnCall[len(fake.currentMemoryLimitsArgsForCall)]
	fake.currentMemoryLimitsArgsForCall = append(fake.currentMemoryLimitsArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentMemoryLimits", []interface{}{})
	fake.currentMemoryLimitsMutex.Unlock()
	if fake.CurrentMemoryLimitsStub != nil {
		return fake.CurrentMemoryLimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentMemoryLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) CurrentMemoryLimitsCallCount() int {
	fake.currentMemoryLimitsMutex.RLock()
	defer fake.currentMemoryLimitsMutex.RUnlock()
	return len(fake.currentMemoryLimitsArgsForCall)
}

func (fake *FakeContainer) CurrentMemoryLimitsCalls(stub func() (garden.MemoryLimits, error)) {
	fake.currentMemoryLimitsMutex.Lock()
	defer fake.currentMemoryLimitsMutex.Unlock()
	fake.CurrentMemoryLimitsStub = stub
}

func (fake *FakeContainer) CurrentMemoryLimitsReturns(result1 garden.MemoryLimits, result2 error) {
	fake.currentMemoryLimitsMutex.Lock()
	defer fake.currentMemoryLimitsMutex.Unlock()
	fake.CurrentMemoryLimitsStub = nil
	fake.currentMemoryLimitsReturns = struct {
		result1 garden.MemoryLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CurrentMemoryLimitsReturnsOnCall(i int, result1 garden.MemoryLimits, result2 error) {
	fake.currentMemoryLimitsMutex.Lock()
	defer fake.currentMemoryLimitsMutex.Unlock()
	fake.CurrentMemoryLimitsStub = nil
	if fake.currentMemoryLimitsReturnsOnCall == nil {
		fake.currentMemoryLimitsReturnsOnCall = make(map[int]struct {
			result1 garden.MemoryLimits
			result2 error
		})
	}
	fake.currentMemoryLimitsReturnsOnCall[i] = struct {
		result1 garden.MemoryLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
	}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.destroyReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeContainer) DestroyCalls(stub func() error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = stub
}

func (fake *FakeContainer) DestroyReturns(result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) DestroyReturnsOnCall(i int, result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Handle() string {
	fake.handleMutex.Lock()
	ret, specificReturn := fake.handleReturnsOnCall[len(fake.handleArgsForCall)]
	fake.handleArgsForCall = append(fake.handleArgsForCall, struct {
	}{})
	fake.recordInvocation("Handle", []interface{}{})
	fake.handleMutex.Unlock()
	if fake.HandleStub != nil {
		return fake.HandleStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.handleReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) HandleCallCount() int {
	fake.handleMutex.RLock()
	defer fake.handleMutex.RUnlock()
	return len(fake.handleArgsForCall)
}

func (fake *FakeContainer) HandleCalls(stub func() string) {
	fake.handleMutex.Lock()
	defer fake.handleMutex.Unlock()
	fake.HandleStub = stub
}

func (fake *FakeContainer) HandleReturns(result1 string) {
	fake.handleMutex.Lock()
	defer fake.handleMutex.Unlock()
	fake.HandleStub = nil
	fake.handleReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContainer) HandleReturnsOnCall(i int, result1 string) {
	fake.handleMutex.Lock()
	defer fake.handleMutex.Unlock()
	fake.HandleStub = nil
	if fake.handleReturnsOnCall == nil {
		fake.handleReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.handleReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContainer) Info() (garden.ContainerInfo, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
	}{})
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.infoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeContainer) InfoCalls(stub func() (garden.ContainerInfo, error)) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeContainer) InfoReturns(result1 garden.ContainerInfo, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 garden.ContainerInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) InfoReturnsOnCall(i int, result1 garden.ContainerInfo, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 garden.ContainerInfo
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 garden.ContainerInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) MarkAsHijacked() error {
	fake.markAsHijackedMutex.Lock()
	ret, specificReturn := fake.markAsHijackedReturnsOnCall[len(fake.markAsHijackedArgsForCall)]
	fake.markAsHijackedArgsForCall = append(fake.markAsHijackedArgsForCall, struct {
	}{})
	fake.recordInvocation("MarkAsHijacked", []interface{}{})
	fake.markAsHijackedMutex.Unlock()
	if fake.MarkAsHijackedStub != nil {
		return fake.MarkAsHijackedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.markAsHijackedReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) MarkAsHijackedCallCount() int {
	fake.markAsHijackedMutex.RLock()
	defer fake.markAsHijackedMutex.RUnlock()
	return len(fake.markAsHijackedArgsForCall)
}

func (fake *FakeContainer) MarkAsHijackedCalls(stub func() error) {
	fake.markAsHijackedMutex.Lock()
	defer fake.markAsHijackedMutex.Unlock()
	fake.MarkAsHijackedStub = stub
}

func (fake *FakeContainer) MarkAsHijackedReturns(result1 error) {
	fake.markAsHijackedMutex.Lock()
	defer fake.markAsHijackedMutex.Unlock()
	fake.MarkAsHijackedStub = nil
	fake.markAsHijackedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) MarkAsHijackedReturnsOnCall(i int, result1 error) {
	fake.markAsHijackedMutex.Lock()
	defer fake.markAsHijackedMutex.Unlock()
	fake.MarkAsHijackedStub = nil
	if fake.markAsHijackedReturnsOnCall == nil {
		fake.markAsHijackedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.markAsHijackedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Metrics() (garden.Metrics, error) {
	fake.metricsMutex.Lock()
	ret, specificReturn := fake.metricsReturnsOnCall[len(fake.metricsArgsForCall)]
	fake.metricsArgsForCall = append(fake.metricsArgsForCall, struct {
	}{})
	fake.recordInvocation("Metrics", []interface{}{})
	fake.metricsMutex.Unlock()
	if fake.MetricsStub != nil {
		return fake.MetricsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.metricsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) MetricsCallCount() int {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return len(fake.metricsArgsForCall)
}

func (fake *FakeContainer) MetricsCalls(stub func() (garden.Metrics, error)) {
	fake.metricsMutex.Lock()
	defer fake.metricsMutex.Unlock()
	fake.MetricsStub = stub
}

func (fake *FakeContainer) MetricsReturns(result1 garden.Metrics, result2 error) {
	fake.metricsMutex.Lock()
	defer fake.metricsMutex.Unlock()
	fake.MetricsStub = nil
	fake.metricsReturns = struct {
		result1 garden.Metrics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) MetricsReturnsOnCall(i int, result1 garden.Metrics, result2 error) {
	fake.metricsMutex.Lock()
	defer fake.metricsMutex.Unlock()
	fake.MetricsStub = nil
	if fake.metricsReturnsOnCall == nil {
		fake.metricsReturnsOnCall = make(map[int]struct {
			result1 garden.Metrics
			result2 error
		})
	}
	fake.metricsReturnsOnCall[i] = struct {
		result1 garden.Metrics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) NetIn(arg1 uint32, arg2 uint32) (uint32, uint32, error) {
	fake.netInMutex.Lock()
	ret, specificReturn := fake.netInReturnsOnCall[len(fake.netInArgsForCall)]
	fake.netInArgsForCall = append(fake.netInArgsForCall, struct {
		arg1 uint32
		arg2 uint32
	}{arg1, arg2})
	fake.recordInvocation("NetIn", []interface{}{arg1, arg2})
	fake.netInMutex.Unlock()
	if fake.NetInStub != nil {
		return fake.NetInStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.netInReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeContainer) NetInCallCount() int {
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	return len(fake.netInArgsForCall)
}

func (fake *FakeContainer) NetInCalls(stub func(uint32, uint32) (uint32, uint32, error)) {
	fake.netInMutex.Lock()
	defer fake.netInMutex.Unlock()
	fake.NetInStub = stub
}

func (fake *FakeContainer) NetInArgsForCall(i int) (uint32, uint32) {
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	argsForCall := fake.netInArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainer) NetInReturns(result1 uint32, result2 uint32, result3 error) {
	fake.netInMutex.Lock()
	defer fake.netInMutex.Unlock()
	fake.NetInStub = nil
	fake.netInReturns = struct {
		result1 uint32
		result2 uint32
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeContainer) NetInReturnsOnCall(i int, result1 uint32, result2 uint32, result3 error) {
	fake.netInMutex.Lock()
	defer fake.netInMutex.Unlock()
	fake.NetInStub = nil
	if fake.netInReturnsOnCall == nil {
		fake.netInReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 uint32
			result3 error
		})
	}
	fake.netInReturnsOnCall[i] = struct {
		result1 uint32
		result2 uint32
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeContainer) NetOut(arg1 garden.NetOutRule) error {
	fake.netOutMutex.Lock()
	ret, specificReturn := fake.netOutReturnsOnCall[len(fake.netOutArgsForCall)]
	fake.netOutArgsForCall = append(fake.netOutArgsForCall, struct {
		arg1 garden.NetOutRule
	}{arg1})
	fake.recordInvocation("NetOut", []interface{}{arg1})
	fake.netOutMutex.Unlock()
	if fake.NetOutStub != nil {
		return fake.NetOutStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.netOutReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) NetOutCallCount() int {
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	return len(fake.netOutArgsForCall)
}

func (fake *FakeContainer) NetOutCalls(stub func(garden.NetOutRule) error) {
	fake.netOutMutex.Lock()
	defer fake.netOutMutex.Unlock()
	fake.NetOutStub = stub
}

func (fake *FakeContainer) NetOutArgsForCall(i int) garden.NetOutRule {
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	argsForCall := fake.netOutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainer) NetOutReturns(result1 error) {
	fake.netOutMutex.Lock()
	defer fake.netOutMutex.Unlock()
	fake.NetOutStub = nil
	fake.netOutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) NetOutReturnsOnCall(i int, result1 error) {
	fake.netOutMutex.Lock()
	defer fake.netOutMutex.Unlock()
	fake.NetOutStub = nil
	if fake.netOutReturnsOnCall == nil {
		fake.netOutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.netOutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Properties() (garden.Properties, error) {
	fake.propertiesMutex.Lock()
	ret, specificReturn := fake.propertiesReturnsOnCall[len(fake.propertiesArgsForCall)]
	fake.propertiesArgsForCall = append(fake.propertiesArgsForCall, struct {
	}{})
	fake.recordInvocation("Properties", []interface{}{})
	fake.propertiesMutex.Unlock()
	if fake.PropertiesStub != nil {
		return fake.PropertiesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.propertiesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) PropertiesCallCount() int {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	return len(fake.propertiesArgsForCall)
}

func (fake *FakeContainer) PropertiesCalls(stub func() (garden.Properties, error)) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = stub
}

func (fake *FakeContainer) PropertiesReturns(result1 garden.Properties, result2 error) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = nil
	fake.propertiesReturns = struct {
		result1 garden.Properties
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) PropertiesReturnsOnCall(i int, result1 garden.Properties, result2 error) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = nil
	if fake.propertiesReturnsOnCall == nil {
		fake.propertiesReturnsOnCall = make(map[int]struct {
			result1 garden.Properties
			result2 error
		})
	}
	fake.propertiesReturnsOnCall[i] = struct {
		result1 garden.Properties
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Property(arg1 string) (string, error) {
	fake.propertyMutex.Lock()
	ret, specificReturn := fake.propertyReturnsOnCall[len(fake.propertyArgsForCall)]
	fake.propertyArgsForCall = append(fake.propertyArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Property", []interface{}{arg1})
	fake.propertyMutex.Unlock()
	if fake.PropertyStub != nil {
		return fake.PropertyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.propertyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) PropertyCallCount() int {
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	return len(fake.propertyArgsForCall)
}

func (fake *FakeContainer) PropertyCalls(stub func(string) (string, error)) {
	fake.propertyMutex.Lock()
	defer fake.propertyMutex.Unlock()
	fake.PropertyStub = stub
}

func (fake *FakeContainer) PropertyArgsForCall(i int) string {
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	argsForCall := fake.propertyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainer) PropertyReturns(result1 string, result2 error) {
	fake.propertyMutex.Lock()
	defer fake.propertyMutex.Unlock()
	fake.PropertyStub = nil
	fake.propertyReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) PropertyReturnsOnCall(i int, result1 string, result2 error) {
	fake.propertyMutex.Lock()
	defer fake.propertyMutex.Unlock()
	fake.PropertyStub = nil
	if fake.propertyReturnsOnCall == nil {
		fake.propertyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.propertyReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) RemoveProperty(arg1 string) error {
	fake.removePropertyMutex.Lock()
	ret, specificReturn := fake.removePropertyReturnsOnCall[len(fake.removePropertyArgsForCall)]
	fake.removePropertyArgsForCall = append(fake.removePropertyArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RemoveProperty", []interface{}{arg1})
	fake.removePropertyMutex.Unlock()
	if fake.RemovePropertyStub != nil {
		return fake.RemovePropertyStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removePropertyReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) RemovePropertyCallCount() int {
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	return len(fake.removePropertyArgsForCall)
}

func (fake *FakeContainer) RemovePropertyCalls(stub func(string) error) {
	fake.removePropertyMutex.Lock()
	defer fake.removePropertyMutex.Unlock()
	fake.RemovePropertyStub = stub
}

func (fake *FakeContainer) RemovePropertyArgsForCall(i int) string {
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	argsForCall := fake.removePropertyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainer) RemovePropertyReturns(result1 error) {
	fake.removePropertyMutex.Lock()
	defer fake.removePropertyMutex.Unlock()
	fake.RemovePropertyStub = nil
	fake.removePropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) RemovePropertyReturnsOnCall(i int, result1 error) {
	fake.removePropertyMutex.Lock()
	defer fake.removePropertyMutex.Unlock()
	fake.RemovePropertyStub = nil
	if fake.removePropertyReturnsOnCall == nil {
		fake.removePropertyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removePropertyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Run(arg1 context.Context, arg2 garden.ProcessSpec, arg3 garden.ProcessIO) (garden.Process, error) {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 context.Context
		arg2 garden.ProcessSpec
		arg3 garden.ProcessIO
	}{arg1, arg2, arg3})
	fake.recordInvocation("Run", []interface{}{arg1, arg2, arg3})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		return fake.RunStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.runReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeContainer) RunCalls(stub func(context.Context, garden.ProcessSpec, garden.ProcessIO) (garden.Process, error)) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeContainer) RunArgsForCall(i int) (context.Context, garden.ProcessSpec, garden.ProcessIO) {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	argsForCall := fake.runArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContainer) RunReturns(result1 garden.Process, result2 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) RunReturnsOnCall(i int, result1 garden.Process, result2 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 garden.Process
			result2 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) RunScript(arg1 context.Context, arg2 string, arg3 []string, arg4 []byte, arg5 interface{}, arg6 io.Writer, arg7 bool) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.runScriptMutex.Lock()
	ret, specificReturn := fake.runScriptReturnsOnCall[len(fake.runScriptArgsForCall)]
	fake.runScriptArgsForCall = append(fake.runScriptArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []byte
		arg5 interface{}
		arg6 io.Writer
		arg7 bool
	}{arg1, arg2, arg3Copy, arg4Copy, arg5, arg6, arg7})
	fake.recordInvocation("RunScript", []interface{}{arg1, arg2, arg3Copy, arg4Copy, arg5, arg6, arg7})
	fake.runScriptMutex.Unlock()
	if fake.RunScriptStub != nil {
		return fake.RunScriptStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.runScriptReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) RunScriptCallCount() int {
	fake.runScriptMutex.RLock()
	defer fake.runScriptMutex.RUnlock()
	return len(fake.runScriptArgsForCall)
}

func (fake *FakeContainer) RunScriptCalls(stub func(context.Context, string, []string, []byte, interface{}, io.Writer, bool) error) {
	fake.runScriptMutex.Lock()
	defer fake.runScriptMutex.Unlock()
	fake.RunScriptStub = stub
}

func (fake *FakeContainer) RunScriptArgsForCall(i int) (context.Context, string, []string, []byte, interface{}, io.Writer, bool) {
	fake.runScriptMutex.RLock()
	defer fake.runScriptMutex.RUnlock()
	argsForCall := fake.runScriptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeContainer) RunScriptReturns(result1 error) {
	fake.runScriptMutex.Lock()
	defer fake.runScriptMutex.Unlock()
	fake.RunScriptStub = nil
	fake.runScriptReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) RunScriptReturnsOnCall(i int, result1 error) {
	fake.runScriptMutex.Lock()
	defer fake.runScriptMutex.Unlock()
	fake.RunScriptStub = nil
	if fake.runScriptReturnsOnCall == nil {
		fake.runScriptReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runScriptReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) SetGraceTime(arg1 time.Duration) error {
	fake.setGraceTimeMutex.Lock()
	ret, specificReturn := fake.setGraceTimeReturnsOnCall[len(fake.setGraceTimeArgsForCall)]
	fake.setGraceTimeArgsForCall = append(fake.setGraceTimeArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("SetGraceTime", []interface{}{arg1})
	fake.setGraceTimeMutex.Unlock()
	if fake.SetGraceTimeStub != nil {
		return fake.SetGraceTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setGraceTimeReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) SetGraceTimeCallCount() int {
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	return len(fake.setGraceTimeArgsForCall)
}

func (fake *FakeContainer) SetGraceTimeCalls(stub func(time.Duration) error) {
	fake.setGraceTimeMutex.Lock()
	defer fake.setGraceTimeMutex.Unlock()
	fake.SetGraceTimeStub = stub
}

func (fake *FakeContainer) SetGraceTimeArgsForCall(i int) time.Duration {
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	argsForCall := fake.setGraceTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainer) SetGraceTimeReturns(result1 error) {
	fake.setGraceTimeMutex.Lock()
	defer fake.setGraceTimeMutex.Unlock()
	fake.SetGraceTimeStub = nil
	fake.setGraceTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) SetGraceTimeReturnsOnCall(i int, result1 error) {
	fake.setGraceTimeMutex.Lock()
	defer fake.setGraceTimeMutex.Unlock()
	fake.SetGraceTimeStub = nil
	if fake.setGraceTimeReturnsOnCall == nil {
		fake.setGraceTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setGraceTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) SetProperty(arg1 string, arg2 string) error {
	fake.setPropertyMutex.Lock()
	ret, specificReturn := fake.setPropertyReturnsOnCall[len(fake.setPropertyArgsForCall)]
	fake.setPropertyArgsForCall = append(fake.setPropertyArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SetProperty", []interface{}{arg1, arg2})
	fake.setPropertyMutex.Unlock()
	if fake.SetPropertyStub != nil {
		return fake.SetPropertyStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setPropertyReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) SetPropertyCallCount() int {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	return len(fake.setPropertyArgsForCall)
}

func (fake *FakeContainer) SetPropertyCalls(stub func(string, string) error) {
	fake.setPropertyMutex.Lock()
	defer fake.setPropertyMutex.Unlock()
	fake.SetPropertyStub = stub
}

func (fake *FakeContainer) SetPropertyArgsForCall(i int) (string, string) {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	argsForCall := fake.setPropertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainer) SetPropertyReturns(result1 error) {
	fake.setPropertyMutex.Lock()
	defer fake.setPropertyMutex.Unlock()
	fake.SetPropertyStub = nil
	fake.setPropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) SetPropertyReturnsOnCall(i int, result1 error) {
	fake.setPropertyMutex.Lock()
	defer fake.setPropertyMutex.Unlock()
	fake.SetPropertyStub = nil
	if fake.setPropertyReturnsOnCall == nil {
		fake.setPropertyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setPropertyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Stop(arg1 bool) error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("Stop", []interface{}{arg1})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stopReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeContainer) StopCalls(stub func(bool) error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeContainer) StopArgsForCall(i int) bool {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	argsForCall := fake.stopArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainer) StopReturns(result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) StopReturnsOnCall(i int, result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) StreamIn(arg1 garden.StreamInSpec) error {
	fake.streamInMutex.Lock()
	ret, specificReturn := fake.streamInReturnsOnCall[len(fake.streamInArgsForCall)]
	fake.streamInArgsForCall = append(fake.streamInArgsForCall, struct {
		arg1 garden.StreamInSpec
	}{arg1})
	fake.recordInvocation("StreamIn", []interface{}{arg1})
	fake.streamInMutex.Unlock()
	if fake.StreamInStub != nil {
		return fake.StreamInStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.streamInReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) StreamInCallCount() int {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return len(fake.streamInArgsForCall)
}

func (fake *FakeContainer) StreamInCalls(stub func(garden.StreamInSpec) error) {
	fake.streamInMutex.Lock()
	defer fake.streamInMutex.Unlock()
	fake.StreamInStub = stub
}

func (fake *FakeContainer) StreamInArgsForCall(i int) garden.StreamInSpec {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	argsForCall := fake.streamInArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainer) StreamInReturns(result1 error) {
	fake.streamInMutex.Lock()
	defer fake.streamInMutex.Unlock()
	fake.StreamInStub = nil
	fake.streamInReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) StreamInReturnsOnCall(i int, result1 error) {
	fake.streamInMutex.Lock()
	defer fake.streamInMutex.Unlock()
	fake.StreamInStub = nil
	if fake.streamInReturnsOnCall == nil {
		fake.streamInReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamInReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) StreamOut(arg1 garden.StreamOutSpec) (io.ReadCloser, error) {
	fake.streamOutMutex.Lock()
	ret, specificReturn := fake.streamOutReturnsOnCall[len(fake.streamOutArgsForCall)]
	fake.streamOutArgsForCall = append(fake.streamOutArgsForCall, struct {
		arg1 garden.StreamOutSpec
	}{arg1})
	fake.recordInvocation("StreamOut", []interface{}{arg1})
	fake.streamOutMutex.Unlock()
	if fake.StreamOutStub != nil {
		return fake.StreamOutStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.streamOutReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainer) StreamOutCallCount() int {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return len(fake.streamOutArgsForCall)
}

func (fake *FakeContainer) StreamOutCalls(stub func(garden.StreamOutSpec) (io.ReadCloser, error)) {
	fake.streamOutMutex.Lock()
	defer fake.streamOutMutex.Unlock()
	fake.StreamOutStub = stub
}

func (fake *FakeContainer) StreamOutArgsForCall(i int) garden.StreamOutSpec {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	argsForCall := fake.streamOutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainer) StreamOutReturns(result1 io.ReadCloser, result2 error) {
	fake.streamOutMutex.Lock()
	defer fake.streamOutMutex.Unlock()
	fake.StreamOutStub = nil
	fake.streamOutReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) StreamOutReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.streamOutMutex.Lock()
	defer fake.streamOutMutex.Unlock()
	fake.StreamOutStub = nil
	if fake.streamOutReturnsOnCall == nil {
		fake.streamOutReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.streamOutReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) VolumeMounts() []worker.VolumeMount {
	fake.volumeMountsMutex.Lock()
	ret, specificReturn := fake.volumeMountsReturnsOnCall[len(fake.volumeMountsArgsForCall)]
	fake.volumeMountsArgsForCall = append(fake.volumeMountsArgsForCall, struct {
	}{})
	fake.recordInvocation("VolumeMounts", []interface{}{})
	fake.volumeMountsMutex.Unlock()
	if fake.VolumeMountsStub != nil {
		return fake.VolumeMountsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.volumeMountsReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) VolumeMountsCallCount() int {
	fake.volumeMountsMutex.RLock()
	defer fake.volumeMountsMutex.RUnlock()
	return len(fake.volumeMountsArgsForCall)
}

func (fake *FakeContainer) VolumeMountsCalls(stub func() []worker.VolumeMount) {
	fake.volumeMountsMutex.Lock()
	defer fake.volumeMountsMutex.Unlock()
	fake.VolumeMountsStub = stub
}

func (fake *FakeContainer) VolumeMountsReturns(result1 []worker.VolumeMount) {
	fake.volumeMountsMutex.Lock()
	defer fake.volumeMountsMutex.Unlock()
	fake.VolumeMountsStub = nil
	fake.volumeMountsReturns = struct {
		result1 []worker.VolumeMount
	}{result1}
}

func (fake *FakeContainer) VolumeMountsReturnsOnCall(i int, result1 []worker.VolumeMount) {
	fake.volumeMountsMutex.Lock()
	defer fake.volumeMountsMutex.Unlock()
	fake.VolumeMountsStub = nil
	if fake.volumeMountsReturnsOnCall == nil {
		fake.volumeMountsReturnsOnCall = make(map[int]struct {
			result1 []worker.VolumeMount
		})
	}
	fake.volumeMountsReturnsOnCall[i] = struct {
		result1 []worker.VolumeMount
	}{result1}
}

func (fake *FakeContainer) WorkerName() string {
	fake.workerNameMutex.Lock()
	ret, specificReturn := fake.workerNameReturnsOnCall[len(fake.workerNameArgsForCall)]
	fake.workerNameArgsForCall = append(fake.workerNameArgsForCall, struct {
	}{})
	fake.recordInvocation("WorkerName", []interface{}{})
	fake.workerNameMutex.Unlock()
	if fake.WorkerNameStub != nil {
		return fake.WorkerNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.workerNameReturns
	return fakeReturns.result1
}

func (fake *FakeContainer) WorkerNameCallCount() int {
	fake.workerNameMutex.RLock()
	defer fake.workerNameMutex.RUnlock()
	return len(fake.workerNameArgsForCall)
}

func (fake *FakeContainer) WorkerNameCalls(stub func() string) {
	fake.workerNameMutex.Lock()
	defer fake.workerNameMutex.Unlock()
	fake.WorkerNameStub = stub
}

func (fake *FakeContainer) WorkerNameReturns(result1 string) {
	fake.workerNameMutex.Lock()
	defer fake.workerNameMutex.Unlock()
	fake.WorkerNameStub = nil
	fake.workerNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContainer) WorkerNameReturnsOnCall(i int, result1 string) {
	fake.workerNameMutex.Lock()
	defer fake.workerNameMutex.Unlock()
	fake.WorkerNameStub = nil
	if fake.workerNameReturnsOnCall == nil {
		fake.workerNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.workerNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContainer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	fake.bulkNetOutMutex.RLock()
	defer fake.bulkNetOutMutex.RUnlock()
	fake.currentBandwidthLimitsMutex.RLock()
	defer fake.currentBandwidthLimitsMutex.RUnlock()
	fake.currentCPULimitsMutex.RLock()
	defer fake.currentCPULimitsMutex.RUnlock()
	fake.currentDiskLimitsMutex.RLock()
	defer fake.currentDiskLimitsMutex.RUnlock()
	fake.currentMemoryLimitsMutex.RLock()
	defer fake.currentMemoryLimitsMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.handleMutex.RLock()
	defer fake.handleMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.markAsHijackedMutex.RLock()
	defer fake.markAsHijackedMutex.RUnlock()
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.runScriptMutex.RLock()
	defer fake.runScriptMutex.RUnlock()
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	fake.volumeMountsMutex.RLock()
	defer fake.volumeMountsMutex.RUnlock()
	fake.workerNameMutex.RLock()
	defer fake.workerNameMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContainer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ worker.Container = new(FakeContainer)
