// Code generated by counterfeiter. DO NOT EDIT.
package connectionfakes

import (
	"context"
	"io"
	"sync"
	"time"

	"code.cloudfoundry.org/garden"
	"github.com/concourse/concourse/atc/worker/gclient/connection"
)

type FakeConnection struct {
	AttachStub        func(context.Context, string, string, garden.ProcessIO) (garden.Process, error)
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 garden.ProcessIO
	}
	attachReturns struct {
		result1 garden.Process
		result2 error
	}
	attachReturnsOnCall map[int]struct {
		result1 garden.Process
		result2 error
	}
	BulkInfoStub        func([]string) (map[string]garden.ContainerInfoEntry, error)
	bulkInfoMutex       sync.RWMutex
	bulkInfoArgsForCall []struct {
		arg1 []string
	}
	bulkInfoReturns struct {
		result1 map[string]garden.ContainerInfoEntry
		result2 error
	}
	bulkInfoReturnsOnCall map[int]struct {
		result1 map[string]garden.ContainerInfoEntry
		result2 error
	}
	BulkMetricsStub        func([]string) (map[string]garden.ContainerMetricsEntry, error)
	bulkMetricsMutex       sync.RWMutex
	bulkMetricsArgsForCall []struct {
		arg1 []string
	}
	bulkMetricsReturns struct {
		result1 map[string]garden.ContainerMetricsEntry
		result2 error
	}
	bulkMetricsReturnsOnCall map[int]struct {
		result1 map[string]garden.ContainerMetricsEntry
		result2 error
	}
	BulkNetOutStub        func(string, []garden.NetOutRule) error
	bulkNetOutMutex       sync.RWMutex
	bulkNetOutArgsForCall []struct {
		arg1 string
		arg2 []garden.NetOutRule
	}
	bulkNetOutReturns struct {
		result1 error
	}
	bulkNetOutReturnsOnCall map[int]struct {
		result1 error
	}
	CapacityStub        func() (garden.Capacity, error)
	capacityMutex       sync.RWMutex
	capacityArgsForCall []struct {
	}
	capacityReturns struct {
		result1 garden.Capacity
		result2 error
	}
	capacityReturnsOnCall map[int]struct {
		result1 garden.Capacity
		result2 error
	}
	CreateStub        func(garden.ContainerSpec) (string, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 garden.ContainerSpec
	}
	createReturns struct {
		result1 string
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CurrentBandwidthLimitsStub        func(string) (garden.BandwidthLimits, error)
	currentBandwidthLimitsMutex       sync.RWMutex
	currentBandwidthLimitsArgsForCall []struct {
		arg1 string
	}
	currentBandwidthLimitsReturns struct {
		result1 garden.BandwidthLimits
		result2 error
	}
	currentBandwidthLimitsReturnsOnCall map[int]struct {
		result1 garden.BandwidthLimits
		result2 error
	}
	CurrentCPULimitsStub        func(string) (garden.CPULimits, error)
	currentCPULimitsMutex       sync.RWMutex
	currentCPULimitsArgsForCall []struct {
		arg1 string
	}
	currentCPULimitsReturns struct {
		result1 garden.CPULimits
		result2 error
	}
	currentCPULimitsReturnsOnCall map[int]struct {
		result1 garden.CPULimits
		result2 error
	}
	CurrentDiskLimitsStub        func(string) (garden.DiskLimits, error)
	currentDiskLimitsMutex       sync.RWMutex
	currentDiskLimitsArgsForCall []struct {
		arg1 string
	}
	currentDiskLimitsReturns struct {
		result1 garden.DiskLimits
		result2 error
	}
	currentDiskLimitsReturnsOnCall map[int]struct {
		result1 garden.DiskLimits
		result2 error
	}
	CurrentMemoryLimitsStub        func(string) (garden.MemoryLimits, error)
	currentMemoryLimitsMutex       sync.RWMutex
	currentMemoryLimitsArgsForCall []struct {
		arg1 string
	}
	currentMemoryLimitsReturns struct {
		result1 garden.MemoryLimits
		result2 error
	}
	currentMemoryLimitsReturnsOnCall map[int]struct {
		result1 garden.MemoryLimits
		result2 error
	}
	DestroyStub        func(string) error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
		arg1 string
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	InfoStub        func(string) (garden.ContainerInfo, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		arg1 string
	}
	infoReturns struct {
		result1 garden.ContainerInfo
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 garden.ContainerInfo
		result2 error
	}
	ListStub        func(garden.Properties) ([]string, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 garden.Properties
	}
	listReturns struct {
		result1 []string
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	MetricsStub        func(string) (garden.Metrics, error)
	metricsMutex       sync.RWMutex
	metricsArgsForCall []struct {
		arg1 string
	}
	metricsReturns struct {
		result1 garden.Metrics
		result2 error
	}
	metricsReturnsOnCall map[int]struct {
		result1 garden.Metrics
		result2 error
	}
	NetInStub        func(string, uint32, uint32) (uint32, uint32, error)
	netInMutex       sync.RWMutex
	netInArgsForCall []struct {
		arg1 string
		arg2 uint32
		arg3 uint32
	}
	netInReturns struct {
		result1 uint32
		result2 uint32
		result3 error
	}
	netInReturnsOnCall map[int]struct {
		result1 uint32
		result2 uint32
		result3 error
	}
	NetOutStub        func(string, garden.NetOutRule) error
	netOutMutex       sync.RWMutex
	netOutArgsForCall []struct {
		arg1 string
		arg2 garden.NetOutRule
	}
	netOutReturns struct {
		result1 error
	}
	netOutReturnsOnCall map[int]struct {
		result1 error
	}
	PingStub        func() error
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
	}
	pingReturns struct {
		result1 error
	}
	pingReturnsOnCall map[int]struct {
		result1 error
	}
	PropertiesStub        func(string) (garden.Properties, error)
	propertiesMutex       sync.RWMutex
	propertiesArgsForCall []struct {
		arg1 string
	}
	propertiesReturns struct {
		result1 garden.Properties
		result2 error
	}
	propertiesReturnsOnCall map[int]struct {
		result1 garden.Properties
		result2 error
	}
	PropertyStub        func(string, string) (string, error)
	propertyMutex       sync.RWMutex
	propertyArgsForCall []struct {
		arg1 string
		arg2 string
	}
	propertyReturns struct {
		result1 string
		result2 error
	}
	propertyReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RemovePropertyStub        func(string, string) error
	removePropertyMutex       sync.RWMutex
	removePropertyArgsForCall []struct {
		arg1 string
		arg2 string
	}
	removePropertyReturns struct {
		result1 error
	}
	removePropertyReturnsOnCall map[int]struct {
		result1 error
	}
	RunStub        func(context.Context, string, garden.ProcessSpec, garden.ProcessIO) (garden.Process, error)
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 garden.ProcessSpec
		arg4 garden.ProcessIO
	}
	runReturns struct {
		result1 garden.Process
		result2 error
	}
	runReturnsOnCall map[int]struct {
		result1 garden.Process
		result2 error
	}
	SetGraceTimeStub        func(string, time.Duration) error
	setGraceTimeMutex       sync.RWMutex
	setGraceTimeArgsForCall []struct {
		arg1 string
		arg2 time.Duration
	}
	setGraceTimeReturns struct {
		result1 error
	}
	setGraceTimeReturnsOnCall map[int]struct {
		result1 error
	}
	SetPropertyStub        func(string, string, string) error
	setPropertyMutex       sync.RWMutex
	setPropertyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	setPropertyReturns struct {
		result1 error
	}
	setPropertyReturnsOnCall map[int]struct {
		result1 error
	}
	StopStub        func(string, bool) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	StreamInStub        func(string, garden.StreamInSpec) error
	streamInMutex       sync.RWMutex
	streamInArgsForCall []struct {
		arg1 string
		arg2 garden.StreamInSpec
	}
	streamInReturns struct {
		result1 error
	}
	streamInReturnsOnCall map[int]struct {
		result1 error
	}
	StreamOutStub        func(string, garden.StreamOutSpec) (io.ReadCloser, error)
	streamOutMutex       sync.RWMutex
	streamOutArgsForCall []struct {
		arg1 string
		arg2 garden.StreamOutSpec
	}
	streamOutReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	streamOutReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConnection) Attach(arg1 context.Context, arg2 string, arg3 string, arg4 garden.ProcessIO) (garden.Process, error) {
	fake.attachMutex.Lock()
	ret, specificReturn := fake.attachReturnsOnCall[len(fake.attachArgsForCall)]
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 garden.ProcessIO
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Attach", []interface{}{arg1, arg2, arg3, arg4})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		return fake.AttachStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.attachReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeConnection) AttachCalls(stub func(context.Context, string, string, garden.ProcessIO) (garden.Process, error)) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = stub
}

func (fake *FakeConnection) AttachArgsForCall(i int) (context.Context, string, string, garden.ProcessIO) {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	argsForCall := fake.attachArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeConnection) AttachReturns(result1 garden.Process, result2 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	fake.attachReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) AttachReturnsOnCall(i int, result1 garden.Process, result2 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	if fake.attachReturnsOnCall == nil {
		fake.attachReturnsOnCall = make(map[int]struct {
			result1 garden.Process
			result2 error
		})
	}
	fake.attachReturnsOnCall[i] = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) BulkInfo(arg1 []string) (map[string]garden.ContainerInfoEntry, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.bulkInfoMutex.Lock()
	ret, specificReturn := fake.bulkInfoReturnsOnCall[len(fake.bulkInfoArgsForCall)]
	fake.bulkInfoArgsForCall = append(fake.bulkInfoArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("BulkInfo", []interface{}{arg1Copy})
	fake.bulkInfoMutex.Unlock()
	if fake.BulkInfoStub != nil {
		return fake.BulkInfoStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.bulkInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) BulkInfoCallCount() int {
	fake.bulkInfoMutex.RLock()
	defer fake.bulkInfoMutex.RUnlock()
	return len(fake.bulkInfoArgsForCall)
}

func (fake *FakeConnection) BulkInfoCalls(stub func([]string) (map[string]garden.ContainerInfoEntry, error)) {
	fake.bulkInfoMutex.Lock()
	defer fake.bulkInfoMutex.Unlock()
	fake.BulkInfoStub = stub
}

func (fake *FakeConnection) BulkInfoArgsForCall(i int) []string {
	fake.bulkInfoMutex.RLock()
	defer fake.bulkInfoMutex.RUnlock()
	argsForCall := fake.bulkInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) BulkInfoReturns(result1 map[string]garden.ContainerInfoEntry, result2 error) {
	fake.bulkInfoMutex.Lock()
	defer fake.bulkInfoMutex.Unlock()
	fake.BulkInfoStub = nil
	fake.bulkInfoReturns = struct {
		result1 map[string]garden.ContainerInfoEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) BulkInfoReturnsOnCall(i int, result1 map[string]garden.ContainerInfoEntry, result2 error) {
	fake.bulkInfoMutex.Lock()
	defer fake.bulkInfoMutex.Unlock()
	fake.BulkInfoStub = nil
	if fake.bulkInfoReturnsOnCall == nil {
		fake.bulkInfoReturnsOnCall = make(map[int]struct {
			result1 map[string]garden.ContainerInfoEntry
			result2 error
		})
	}
	fake.bulkInfoReturnsOnCall[i] = struct {
		result1 map[string]garden.ContainerInfoEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) BulkMetrics(arg1 []string) (map[string]garden.ContainerMetricsEntry, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.bulkMetricsMutex.Lock()
	ret, specificReturn := fake.bulkMetricsReturnsOnCall[len(fake.bulkMetricsArgsForCall)]
	fake.bulkMetricsArgsForCall = append(fake.bulkMetricsArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("BulkMetrics", []interface{}{arg1Copy})
	fake.bulkMetricsMutex.Unlock()
	if fake.BulkMetricsStub != nil {
		return fake.BulkMetricsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.bulkMetricsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) BulkMetricsCallCount() int {
	fake.bulkMetricsMutex.RLock()
	defer fake.bulkMetricsMutex.RUnlock()
	return len(fake.bulkMetricsArgsForCall)
}

func (fake *FakeConnection) BulkMetricsCalls(stub func([]string) (map[string]garden.ContainerMetricsEntry, error)) {
	fake.bulkMetricsMutex.Lock()
	defer fake.bulkMetricsMutex.Unlock()
	fake.BulkMetricsStub = stub
}

func (fake *FakeConnection) BulkMetricsArgsForCall(i int) []string {
	fake.bulkMetricsMutex.RLock()
	defer fake.bulkMetricsMutex.RUnlock()
	argsForCall := fake.bulkMetricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) BulkMetricsReturns(result1 map[string]garden.ContainerMetricsEntry, result2 error) {
	fake.bulkMetricsMutex.Lock()
	defer fake.bulkMetricsMutex.Unlock()
	fake.BulkMetricsStub = nil
	fake.bulkMetricsReturns = struct {
		result1 map[string]garden.ContainerMetricsEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) BulkMetricsReturnsOnCall(i int, result1 map[string]garden.ContainerMetricsEntry, result2 error) {
	fake.bulkMetricsMutex.Lock()
	defer fake.bulkMetricsMutex.Unlock()
	fake.BulkMetricsStub = nil
	if fake.bulkMetricsReturnsOnCall == nil {
		fake.bulkMetricsReturnsOnCall = make(map[int]struct {
			result1 map[string]garden.ContainerMetricsEntry
			result2 error
		})
	}
	fake.bulkMetricsReturnsOnCall[i] = struct {
		result1 map[string]garden.ContainerMetricsEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) BulkNetOut(arg1 string, arg2 []garden.NetOutRule) error {
	var arg2Copy []garden.NetOutRule
	if arg2 != nil {
		arg2Copy = make([]garden.NetOutRule, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.bulkNetOutMutex.Lock()
	ret, specificReturn := fake.bulkNetOutReturnsOnCall[len(fake.bulkNetOutArgsForCall)]
	fake.bulkNetOutArgsForCall = append(fake.bulkNetOutArgsForCall, struct {
		arg1 string
		arg2 []garden.NetOutRule
	}{arg1, arg2Copy})
	fake.recordInvocation("BulkNetOut", []interface{}{arg1, arg2Copy})
	fake.bulkNetOutMutex.Unlock()
	if fake.BulkNetOutStub != nil {
		return fake.BulkNetOutStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.bulkNetOutReturns
	return fakeReturns.result1
}

func (fake *FakeConnection) BulkNetOutCallCount() int {
	fake.bulkNetOutMutex.RLock()
	defer fake.bulkNetOutMutex.RUnlock()
	return len(fake.bulkNetOutArgsForCall)
}

func (fake *FakeConnection) BulkNetOutCalls(stub func(string, []garden.NetOutRule) error) {
	fake.bulkNetOutMutex.Lock()
	defer fake.bulkNetOutMutex.Unlock()
	fake.BulkNetOutStub = stub
}

func (fake *FakeConnection) BulkNetOutArgsForCall(i int) (string, []garden.NetOutRule) {
	fake.bulkNetOutMutex.RLock()
	defer fake.bulkNetOutMutex.RUnlock()
	argsForCall := fake.bulkNetOutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) BulkNetOutReturns(result1 error) {
	fake.bulkNetOutMutex.Lock()
	defer fake.bulkNetOutMutex.Unlock()
	fake.BulkNetOutStub = nil
	fake.bulkNetOutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) BulkNetOutReturnsOnCall(i int, result1 error) {
	fake.bulkNetOutMutex.Lock()
	defer fake.bulkNetOutMutex.Unlock()
	fake.BulkNetOutStub = nil
	if fake.bulkNetOutReturnsOnCall == nil {
		fake.bulkNetOutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bulkNetOutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) Capacity() (garden.Capacity, error) {
	fake.capacityMutex.Lock()
	ret, specificReturn := fake.capacityReturnsOnCall[len(fake.capacityArgsForCall)]
	fake.capacityArgsForCall = append(fake.capacityArgsForCall, struct {
	}{})
	fake.recordInvocation("Capacity", []interface{}{})
	fake.capacityMutex.Unlock()
	if fake.CapacityStub != nil {
		return fake.CapacityStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.capacityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) CapacityCallCount() int {
	fake.capacityMutex.RLock()
	defer fake.capacityMutex.RUnlock()
	return len(fake.capacityArgsForCall)
}

func (fake *FakeConnection) CapacityCalls(stub func() (garden.Capacity, error)) {
	fake.capacityMutex.Lock()
	defer fake.capacityMutex.Unlock()
	fake.CapacityStub = stub
}

func (fake *FakeConnection) CapacityReturns(result1 garden.Capacity, result2 error) {
	fake.capacityMutex.Lock()
	defer fake.capacityMutex.Unlock()
	fake.CapacityStub = nil
	fake.capacityReturns = struct {
		result1 garden.Capacity
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CapacityReturnsOnCall(i int, result1 garden.Capacity, result2 error) {
	fake.capacityMutex.Lock()
	defer fake.capacityMutex.Unlock()
	fake.CapacityStub = nil
	if fake.capacityReturnsOnCall == nil {
		fake.capacityReturnsOnCall = make(map[int]struct {
			result1 garden.Capacity
			result2 error
		})
	}
	fake.capacityReturnsOnCall[i] = struct {
		result1 garden.Capacity
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) Create(arg1 garden.ContainerSpec) (string, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 garden.ContainerSpec
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeConnection) CreateCalls(stub func(garden.ContainerSpec) (string, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeConnection) CreateArgsForCall(i int) garden.ContainerSpec {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) CreateReturns(result1 string, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CreateReturnsOnCall(i int, result1 string, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CurrentBandwidthLimits(arg1 string) (garden.BandwidthLimits, error) {
	fake.currentBandwidthLimitsMutex.Lock()
	ret, specificReturn := fake.currentBandwidthLimitsReturnsOnCall[len(fake.currentBandwidthLimitsArgsForCall)]
	fake.currentBandwidthLimitsArgsForCall = append(fake.currentBandwidthLimitsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CurrentBandwidthLimits", []interface{}{arg1})
	fake.currentBandwidthLimitsMutex.Unlock()
	if fake.CurrentBandwidthLimitsStub != nil {
		return fake.CurrentBandwidthLimitsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentBandwidthLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) CurrentBandwidthLimitsCallCount() int {
	fake.currentBandwidthLimitsMutex.RLock()
	defer fake.currentBandwidthLimitsMutex.RUnlock()
	return len(fake.currentBandwidthLimitsArgsForCall)
}

func (fake *FakeConnection) CurrentBandwidthLimitsCalls(stub func(string) (garden.BandwidthLimits, error)) {
	fake.currentBandwidthLimitsMutex.Lock()
	defer fake.currentBandwidthLimitsMutex.Unlock()
	fake.CurrentBandwidthLimitsStub = stub
}

func (fake *FakeConnection) CurrentBandwidthLimitsArgsForCall(i int) string {
	fake.currentBandwidthLimitsMutex.RLock()
	defer fake.currentBandwidthLimitsMutex.RUnlock()
	argsForCall := fake.currentBandwidthLimitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) CurrentBandwidthLimitsReturns(result1 garden.BandwidthLimits, result2 error) {
	fake.currentBandwidthLimitsMutex.Lock()
	defer fake.currentBandwidthLimitsMutex.Unlock()
	fake.CurrentBandwidthLimitsStub = nil
	fake.currentBandwidthLimitsReturns = struct {
		result1 garden.BandwidthLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CurrentBandwidthLimitsReturnsOnCall(i int, result1 garden.BandwidthLimits, result2 error) {
	fake.currentBandwidthLimitsMutex.Lock()
	defer fake.currentBandwidthLimitsMutex.Unlock()
	fake.CurrentBandwidthLimitsStub = nil
	if fake.currentBandwidthLimitsReturnsOnCall == nil {
		fake.currentBandwidthLimitsReturnsOnCall = make(map[int]struct {
			result1 garden.BandwidthLimits
			result2 error
		})
	}
	fake.currentBandwidthLimitsReturnsOnCall[i] = struct {
		result1 garden.BandwidthLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CurrentCPULimits(arg1 string) (garden.CPULimits, error) {
	fake.currentCPULimitsMutex.Lock()
	ret, specificReturn := fake.currentCPULimitsReturnsOnCall[len(fake.currentCPULimitsArgsForCall)]
	fake.currentCPULimitsArgsForCall = append(fake.currentCPULimitsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CurrentCPULimits", []interface{}{arg1})
	fake.currentCPULimitsMutex.Unlock()
	if fake.CurrentCPULimitsStub != nil {
		return fake.CurrentCPULimitsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentCPULimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) CurrentCPULimitsCallCount() int {
	fake.currentCPULimitsMutex.RLock()
	defer fake.currentCPULimitsMutex.RUnlock()
	return len(fake.currentCPULimitsArgsForCall)
}

func (fake *FakeConnection) CurrentCPULimitsCalls(stub func(string) (garden.CPULimits, error)) {
	fake.currentCPULimitsMutex.Lock()
	defer fake.currentCPULimitsMutex.Unlock()
	fake.CurrentCPULimitsStub = stub
}

func (fake *FakeConnection) CurrentCPULimitsArgsForCall(i int) string {
	fake.currentCPULimitsMutex.RLock()
	defer fake.currentCPULimitsMutex.RUnlock()
	argsForCall := fake.currentCPULimitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) CurrentCPULimitsReturns(result1 garden.CPULimits, result2 error) {
	fake.currentCPULimitsMutex.Lock()
	defer fake.currentCPULimitsMutex.Unlock()
	fake.CurrentCPULimitsStub = nil
	fake.currentCPULimitsReturns = struct {
		result1 garden.CPULimits
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CurrentCPULimitsReturnsOnCall(i int, result1 garden.CPULimits, result2 error) {
	fake.currentCPULimitsMutex.Lock()
	defer fake.currentCPULimitsMutex.Unlock()
	fake.CurrentCPULimitsStub = nil
	if fake.currentCPULimitsReturnsOnCall == nil {
		fake.currentCPULimitsReturnsOnCall = make(map[int]struct {
			result1 garden.CPULimits
			result2 error
		})
	}
	fake.currentCPULimitsReturnsOnCall[i] = struct {
		result1 garden.CPULimits
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CurrentDiskLimits(arg1 string) (garden.DiskLimits, error) {
	fake.currentDiskLimitsMutex.Lock()
	ret, specificReturn := fake.currentDiskLimitsReturnsOnCall[len(fake.currentDiskLimitsArgsForCall)]
	fake.currentDiskLimitsArgsForCall = append(fake.currentDiskLimitsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CurrentDiskLimits", []interface{}{arg1})
	fake.currentDiskLimitsMutex.Unlock()
	if fake.CurrentDiskLimitsStub != nil {
		return fake.CurrentDiskLimitsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentDiskLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) CurrentDiskLimitsCallCount() int {
	fake.currentDiskLimitsMutex.RLock()
	defer fake.currentDiskLimitsMutex.RUnlock()
	return len(fake.currentDiskLimitsArgsForCall)
}

func (fake *FakeConnection) CurrentDiskLimitsCalls(stub func(string) (garden.DiskLimits, error)) {
	fake.currentDiskLimitsMutex.Lock()
	defer fake.currentDiskLimitsMutex.Unlock()
	fake.CurrentDiskLimitsStub = stub
}

func (fake *FakeConnection) CurrentDiskLimitsArgsForCall(i int) string {
	fake.currentDiskLimitsMutex.RLock()
	defer fake.currentDiskLimitsMutex.RUnlock()
	argsForCall := fake.currentDiskLimitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) CurrentDiskLimitsReturns(result1 garden.DiskLimits, result2 error) {
	fake.currentDiskLimitsMutex.Lock()
	defer fake.currentDiskLimitsMutex.Unlock()
	fake.CurrentDiskLimitsStub = nil
	fake.currentDiskLimitsReturns = struct {
		result1 garden.DiskLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CurrentDiskLimitsReturnsOnCall(i int, result1 garden.DiskLimits, result2 error) {
	fake.currentDiskLimitsMutex.Lock()
	defer fake.currentDiskLimitsMutex.Unlock()
	fake.CurrentDiskLimitsStub = nil
	if fake.currentDiskLimitsReturnsOnCall == nil {
		fake.currentDiskLimitsReturnsOnCall = make(map[int]struct {
			result1 garden.DiskLimits
			result2 error
		})
	}
	fake.currentDiskLimitsReturnsOnCall[i] = struct {
		result1 garden.DiskLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CurrentMemoryLimits(arg1 string) (garden.MemoryLimits, error) {
	fake.currentMemoryLimitsMutex.Lock()
	ret, specificReturn := fake.currentMemoryLimitsReturnsOnCall[len(fake.currentMemoryLimitsArgsForCall)]
	fake.currentMemoryLimitsArgsForCall = append(fake.currentMemoryLimitsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CurrentMemoryLimits", []interface{}{arg1})
	fake.currentMemoryLimitsMutex.Unlock()
	if fake.CurrentMemoryLimitsStub != nil {
		return fake.CurrentMemoryLimitsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentMemoryLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) CurrentMemoryLimitsCallCount() int {
	fake.currentMemoryLimitsMutex.RLock()
	defer fake.currentMemoryLimitsMutex.RUnlock()
	return len(fake.currentMemoryLimitsArgsForCall)
}

func (fake *FakeConnection) CurrentMemoryLimitsCalls(stub func(string) (garden.MemoryLimits, error)) {
	fake.currentMemoryLimitsMutex.Lock()
	defer fake.currentMemoryLimitsMutex.Unlock()
	fake.CurrentMemoryLimitsStub = stub
}

func (fake *FakeConnection) CurrentMemoryLimitsArgsForCall(i int) string {
	fake.currentMemoryLimitsMutex.RLock()
	defer fake.currentMemoryLimitsMutex.RUnlock()
	argsForCall := fake.currentMemoryLimitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) CurrentMemoryLimitsReturns(result1 garden.MemoryLimits, result2 error) {
	fake.currentMemoryLimitsMutex.Lock()
	defer fake.currentMemoryLimitsMutex.Unlock()
	fake.CurrentMemoryLimitsStub = nil
	fake.currentMemoryLimitsReturns = struct {
		result1 garden.MemoryLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) CurrentMemoryLimitsReturnsOnCall(i int, result1 garden.MemoryLimits, result2 error) {
	fake.currentMemoryLimitsMutex.Lock()
	defer fake.currentMemoryLimitsMutex.Unlock()
	fake.CurrentMemoryLimitsStub = nil
	if fake.currentMemoryLimitsReturnsOnCall == nil {
		fake.currentMemoryLimitsReturnsOnCall = make(map[int]struct {
			result1 garden.MemoryLimits
			result2 error
		})
	}
	fake.currentMemoryLimitsReturnsOnCall[i] = struct {
		result1 garden.MemoryLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) Destroy(arg1 string) error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Destroy", []interface{}{arg1})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.destroyReturns
	return fakeReturns.result1
}

func (fake *FakeConnection) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeConnection) DestroyCalls(stub func(string) error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = stub
}

func (fake *FakeConnection) DestroyArgsForCall(i int) string {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	argsForCall := fake.destroyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) DestroyReturns(result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) DestroyReturnsOnCall(i int, result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) Info(arg1 string) (garden.ContainerInfo, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Info", []interface{}{arg1})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.infoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeConnection) InfoCalls(stub func(string) (garden.ContainerInfo, error)) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeConnection) InfoArgsForCall(i int) string {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	argsForCall := fake.infoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) InfoReturns(result1 garden.ContainerInfo, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 garden.ContainerInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) InfoReturnsOnCall(i int, result1 garden.ContainerInfo, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 garden.ContainerInfo
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 garden.ContainerInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) List(arg1 garden.Properties) ([]string, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 garden.Properties
	}{arg1})
	fake.recordInvocation("List", []interface{}{arg1})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeConnection) ListCalls(stub func(garden.Properties) ([]string, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeConnection) ListArgsForCall(i int) garden.Properties {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) ListReturns(result1 []string, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) ListReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) Metrics(arg1 string) (garden.Metrics, error) {
	fake.metricsMutex.Lock()
	ret, specificReturn := fake.metricsReturnsOnCall[len(fake.metricsArgsForCall)]
	fake.metricsArgsForCall = append(fake.metricsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Metrics", []interface{}{arg1})
	fake.metricsMutex.Unlock()
	if fake.MetricsStub != nil {
		return fake.MetricsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.metricsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) MetricsCallCount() int {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	return len(fake.metricsArgsForCall)
}

func (fake *FakeConnection) MetricsCalls(stub func(string) (garden.Metrics, error)) {
	fake.metricsMutex.Lock()
	defer fake.metricsMutex.Unlock()
	fake.MetricsStub = stub
}

func (fake *FakeConnection) MetricsArgsForCall(i int) string {
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	argsForCall := fake.metricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) MetricsReturns(result1 garden.Metrics, result2 error) {
	fake.metricsMutex.Lock()
	defer fake.metricsMutex.Unlock()
	fake.MetricsStub = nil
	fake.metricsReturns = struct {
		result1 garden.Metrics
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) MetricsReturnsOnCall(i int, result1 garden.Metrics, result2 error) {
	fake.metricsMutex.Lock()
	defer fake.metricsMutex.Unlock()
	fake.MetricsStub = nil
	if fake.metricsReturnsOnCall == nil {
		fake.metricsReturnsOnCall = make(map[int]struct {
			result1 garden.Metrics
			result2 error
		})
	}
	fake.metricsReturnsOnCall[i] = struct {
		result1 garden.Metrics
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) NetIn(arg1 string, arg2 uint32, arg3 uint32) (uint32, uint32, error) {
	fake.netInMutex.Lock()
	ret, specificReturn := fake.netInReturnsOnCall[len(fake.netInArgsForCall)]
	fake.netInArgsForCall = append(fake.netInArgsForCall, struct {
		arg1 string
		arg2 uint32
		arg3 uint32
	}{arg1, arg2, arg3})
	fake.recordInvocation("NetIn", []interface{}{arg1, arg2, arg3})
	fake.netInMutex.Unlock()
	if fake.NetInStub != nil {
		return fake.NetInStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.netInReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeConnection) NetInCallCount() int {
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	return len(fake.netInArgsForCall)
}

func (fake *FakeConnection) NetInCalls(stub func(string, uint32, uint32) (uint32, uint32, error)) {
	fake.netInMutex.Lock()
	defer fake.netInMutex.Unlock()
	fake.NetInStub = stub
}

func (fake *FakeConnection) NetInArgsForCall(i int) (string, uint32, uint32) {
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	argsForCall := fake.netInArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeConnection) NetInReturns(result1 uint32, result2 uint32, result3 error) {
	fake.netInMutex.Lock()
	defer fake.netInMutex.Unlock()
	fake.NetInStub = nil
	fake.netInReturns = struct {
		result1 uint32
		result2 uint32
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConnection) NetInReturnsOnCall(i int, result1 uint32, result2 uint32, result3 error) {
	fake.netInMutex.Lock()
	defer fake.netInMutex.Unlock()
	fake.NetInStub = nil
	if fake.netInReturnsOnCall == nil {
		fake.netInReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 uint32
			result3 error
		})
	}
	fake.netInReturnsOnCall[i] = struct {
		result1 uint32
		result2 uint32
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConnection) NetOut(arg1 string, arg2 garden.NetOutRule) error {
	fake.netOutMutex.Lock()
	ret, specificReturn := fake.netOutReturnsOnCall[len(fake.netOutArgsForCall)]
	fake.netOutArgsForCall = append(fake.netOutArgsForCall, struct {
		arg1 string
		arg2 garden.NetOutRule
	}{arg1, arg2})
	fake.recordInvocation("NetOut", []interface{}{arg1, arg2})
	fake.netOutMutex.Unlock()
	if fake.NetOutStub != nil {
		return fake.NetOutStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.netOutReturns
	return fakeReturns.result1
}

func (fake *FakeConnection) NetOutCallCount() int {
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	return len(fake.netOutArgsForCall)
}

func (fake *FakeConnection) NetOutCalls(stub func(string, garden.NetOutRule) error) {
	fake.netOutMutex.Lock()
	defer fake.netOutMutex.Unlock()
	fake.NetOutStub = stub
}

func (fake *FakeConnection) NetOutArgsForCall(i int) (string, garden.NetOutRule) {
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	argsForCall := fake.netOutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) NetOutReturns(result1 error) {
	fake.netOutMutex.Lock()
	defer fake.netOutMutex.Unlock()
	fake.NetOutStub = nil
	fake.netOutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) NetOutReturnsOnCall(i int, result1 error) {
	fake.netOutMutex.Lock()
	defer fake.netOutMutex.Unlock()
	fake.NetOutStub = nil
	if fake.netOutReturnsOnCall == nil {
		fake.netOutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.netOutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) Ping() error {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
	}{})
	fake.recordInvocation("Ping", []interface{}{})
	fake.pingMutex.Unlock()
	if fake.PingStub != nil {
		return fake.PingStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pingReturns
	return fakeReturns.result1
}

func (fake *FakeConnection) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeConnection) PingCalls(stub func() error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeConnection) PingReturns(result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) PingReturnsOnCall(i int, result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) Properties(arg1 string) (garden.Properties, error) {
	fake.propertiesMutex.Lock()
	ret, specificReturn := fake.propertiesReturnsOnCall[len(fake.propertiesArgsForCall)]
	fake.propertiesArgsForCall = append(fake.propertiesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Properties", []interface{}{arg1})
	fake.propertiesMutex.Unlock()
	if fake.PropertiesStub != nil {
		return fake.PropertiesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.propertiesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) PropertiesCallCount() int {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	return len(fake.propertiesArgsForCall)
}

func (fake *FakeConnection) PropertiesCalls(stub func(string) (garden.Properties, error)) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = stub
}

func (fake *FakeConnection) PropertiesArgsForCall(i int) string {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	argsForCall := fake.propertiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnection) PropertiesReturns(result1 garden.Properties, result2 error) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = nil
	fake.propertiesReturns = struct {
		result1 garden.Properties
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) PropertiesReturnsOnCall(i int, result1 garden.Properties, result2 error) {
	fake.propertiesMutex.Lock()
	defer fake.propertiesMutex.Unlock()
	fake.PropertiesStub = nil
	if fake.propertiesReturnsOnCall == nil {
		fake.propertiesReturnsOnCall = make(map[int]struct {
			result1 garden.Properties
			result2 error
		})
	}
	fake.propertiesReturnsOnCall[i] = struct {
		result1 garden.Properties
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) Property(arg1 string, arg2 string) (string, error) {
	fake.propertyMutex.Lock()
	ret, specificReturn := fake.propertyReturnsOnCall[len(fake.propertyArgsForCall)]
	fake.propertyArgsForCall = append(fake.propertyArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Property", []interface{}{arg1, arg2})
	fake.propertyMutex.Unlock()
	if fake.PropertyStub != nil {
		return fake.PropertyStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.propertyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) PropertyCallCount() int {
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	return len(fake.propertyArgsForCall)
}

func (fake *FakeConnection) PropertyCalls(stub func(string, string) (string, error)) {
	fake.propertyMutex.Lock()
	defer fake.propertyMutex.Unlock()
	fake.PropertyStub = stub
}

func (fake *FakeConnection) PropertyArgsForCall(i int) (string, string) {
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	argsForCall := fake.propertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) PropertyReturns(result1 string, result2 error) {
	fake.propertyMutex.Lock()
	defer fake.propertyMutex.Unlock()
	fake.PropertyStub = nil
	fake.propertyReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) PropertyReturnsOnCall(i int, result1 string, result2 error) {
	fake.propertyMutex.Lock()
	defer fake.propertyMutex.Unlock()
	fake.PropertyStub = nil
	if fake.propertyReturnsOnCall == nil {
		fake.propertyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.propertyReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) RemoveProperty(arg1 string, arg2 string) error {
	fake.removePropertyMutex.Lock()
	ret, specificReturn := fake.removePropertyReturnsOnCall[len(fake.removePropertyArgsForCall)]
	fake.removePropertyArgsForCall = append(fake.removePropertyArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RemoveProperty", []interface{}{arg1, arg2})
	fake.removePropertyMutex.Unlock()
	if fake.RemovePropertyStub != nil {
		return fake.RemovePropertyStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removePropertyReturns
	return fakeReturns.result1
}

func (fake *FakeConnection) RemovePropertyCallCount() int {
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	return len(fake.removePropertyArgsForCall)
}

func (fake *FakeConnection) RemovePropertyCalls(stub func(string, string) error) {
	fake.removePropertyMutex.Lock()
	defer fake.removePropertyMutex.Unlock()
	fake.RemovePropertyStub = stub
}

func (fake *FakeConnection) RemovePropertyArgsForCall(i int) (string, string) {
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	argsForCall := fake.removePropertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) RemovePropertyReturns(result1 error) {
	fake.removePropertyMutex.Lock()
	defer fake.removePropertyMutex.Unlock()
	fake.RemovePropertyStub = nil
	fake.removePropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) RemovePropertyReturnsOnCall(i int, result1 error) {
	fake.removePropertyMutex.Lock()
	defer fake.removePropertyMutex.Unlock()
	fake.RemovePropertyStub = nil
	if fake.removePropertyReturnsOnCall == nil {
		fake.removePropertyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removePropertyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) Run(arg1 context.Context, arg2 string, arg3 garden.ProcessSpec, arg4 garden.ProcessIO) (garden.Process, error) {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 garden.ProcessSpec
		arg4 garden.ProcessIO
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Run", []interface{}{arg1, arg2, arg3, arg4})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		return fake.RunStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.runReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeConnection) RunCalls(stub func(context.Context, string, garden.ProcessSpec, garden.ProcessIO) (garden.Process, error)) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeConnection) RunArgsForCall(i int) (context.Context, string, garden.ProcessSpec, garden.ProcessIO) {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	argsForCall := fake.runArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeConnection) RunReturns(result1 garden.Process, result2 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) RunReturnsOnCall(i int, result1 garden.Process, result2 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 garden.Process
			result2 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 garden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) SetGraceTime(arg1 string, arg2 time.Duration) error {
	fake.setGraceTimeMutex.Lock()
	ret, specificReturn := fake.setGraceTimeReturnsOnCall[len(fake.setGraceTimeArgsForCall)]
	fake.setGraceTimeArgsForCall = append(fake.setGraceTimeArgsForCall, struct {
		arg1 string
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("SetGraceTime", []interface{}{arg1, arg2})
	fake.setGraceTimeMutex.Unlock()
	if fake.SetGraceTimeStub != nil {
		return fake.SetGraceTimeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setGraceTimeReturns
	return fakeReturns.result1
}

func (fake *FakeConnection) SetGraceTimeCallCount() int {
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	return len(fake.setGraceTimeArgsForCall)
}

func (fake *FakeConnection) SetGraceTimeCalls(stub func(string, time.Duration) error) {
	fake.setGraceTimeMutex.Lock()
	defer fake.setGraceTimeMutex.Unlock()
	fake.SetGraceTimeStub = stub
}

func (fake *FakeConnection) SetGraceTimeArgsForCall(i int) (string, time.Duration) {
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	argsForCall := fake.setGraceTimeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) SetGraceTimeReturns(result1 error) {
	fake.setGraceTimeMutex.Lock()
	defer fake.setGraceTimeMutex.Unlock()
	fake.SetGraceTimeStub = nil
	fake.setGraceTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) SetGraceTimeReturnsOnCall(i int, result1 error) {
	fake.setGraceTimeMutex.Lock()
	defer fake.setGraceTimeMutex.Unlock()
	fake.SetGraceTimeStub = nil
	if fake.setGraceTimeReturnsOnCall == nil {
		fake.setGraceTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setGraceTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) SetProperty(arg1 string, arg2 string, arg3 string) error {
	fake.setPropertyMutex.Lock()
	ret, specificReturn := fake.setPropertyReturnsOnCall[len(fake.setPropertyArgsForCall)]
	fake.setPropertyArgsForCall = append(fake.setPropertyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetProperty", []interface{}{arg1, arg2, arg3})
	fake.setPropertyMutex.Unlock()
	if fake.SetPropertyStub != nil {
		return fake.SetPropertyStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setPropertyReturns
	return fakeReturns.result1
}

func (fake *FakeConnection) SetPropertyCallCount() int {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	return len(fake.setPropertyArgsForCall)
}

func (fake *FakeConnection) SetPropertyCalls(stub func(string, string, string) error) {
	fake.setPropertyMutex.Lock()
	defer fake.setPropertyMutex.Unlock()
	fake.SetPropertyStub = stub
}

func (fake *FakeConnection) SetPropertyArgsForCall(i int) (string, string, string) {
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	argsForCall := fake.setPropertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeConnection) SetPropertyReturns(result1 error) {
	fake.setPropertyMutex.Lock()
	defer fake.setPropertyMutex.Unlock()
	fake.SetPropertyStub = nil
	fake.setPropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) SetPropertyReturnsOnCall(i int, result1 error) {
	fake.setPropertyMutex.Lock()
	defer fake.setPropertyMutex.Unlock()
	fake.SetPropertyStub = nil
	if fake.setPropertyReturnsOnCall == nil {
		fake.setPropertyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setPropertyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) Stop(arg1 string, arg2 bool) error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("Stop", []interface{}{arg1, arg2})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stopReturns
	return fakeReturns.result1
}

func (fake *FakeConnection) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeConnection) StopCalls(stub func(string, bool) error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeConnection) StopArgsForCall(i int) (string, bool) {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	argsForCall := fake.stopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) StopReturns(result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) StopReturnsOnCall(i int, result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) StreamIn(arg1 string, arg2 garden.StreamInSpec) error {
	fake.streamInMutex.Lock()
	ret, specificReturn := fake.streamInReturnsOnCall[len(fake.streamInArgsForCall)]
	fake.streamInArgsForCall = append(fake.streamInArgsForCall, struct {
		arg1 string
		arg2 garden.StreamInSpec
	}{arg1, arg2})
	fake.recordInvocation("StreamIn", []interface{}{arg1, arg2})
	fake.streamInMutex.Unlock()
	if fake.StreamInStub != nil {
		return fake.StreamInStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.streamInReturns
	return fakeReturns.result1
}

func (fake *FakeConnection) StreamInCallCount() int {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	return len(fake.streamInArgsForCall)
}

func (fake *FakeConnection) StreamInCalls(stub func(string, garden.StreamInSpec) error) {
	fake.streamInMutex.Lock()
	defer fake.streamInMutex.Unlock()
	fake.StreamInStub = stub
}

func (fake *FakeConnection) StreamInArgsForCall(i int) (string, garden.StreamInSpec) {
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	argsForCall := fake.streamInArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) StreamInReturns(result1 error) {
	fake.streamInMutex.Lock()
	defer fake.streamInMutex.Unlock()
	fake.StreamInStub = nil
	fake.streamInReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) StreamInReturnsOnCall(i int, result1 error) {
	fake.streamInMutex.Lock()
	defer fake.streamInMutex.Unlock()
	fake.StreamInStub = nil
	if fake.streamInReturnsOnCall == nil {
		fake.streamInReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamInReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnection) StreamOut(arg1 string, arg2 garden.StreamOutSpec) (io.ReadCloser, error) {
	fake.streamOutMutex.Lock()
	ret, specificReturn := fake.streamOutReturnsOnCall[len(fake.streamOutArgsForCall)]
	fake.streamOutArgsForCall = append(fake.streamOutArgsForCall, struct {
		arg1 string
		arg2 garden.StreamOutSpec
	}{arg1, arg2})
	fake.recordInvocation("StreamOut", []interface{}{arg1, arg2})
	fake.streamOutMutex.Unlock()
	if fake.StreamOutStub != nil {
		return fake.StreamOutStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.streamOutReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConnection) StreamOutCallCount() int {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	return len(fake.streamOutArgsForCall)
}

func (fake *FakeConnection) StreamOutCalls(stub func(string, garden.StreamOutSpec) (io.ReadCloser, error)) {
	fake.streamOutMutex.Lock()
	defer fake.streamOutMutex.Unlock()
	fake.StreamOutStub = stub
}

func (fake *FakeConnection) StreamOutArgsForCall(i int) (string, garden.StreamOutSpec) {
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	argsForCall := fake.streamOutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConnection) StreamOutReturns(result1 io.ReadCloser, result2 error) {
	fake.streamOutMutex.Lock()
	defer fake.streamOutMutex.Unlock()
	fake.StreamOutStub = nil
	fake.streamOutReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) StreamOutReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.streamOutMutex.Lock()
	defer fake.streamOutMutex.Unlock()
	fake.StreamOutStub = nil
	if fake.streamOutReturnsOnCall == nil {
		fake.streamOutReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.streamOutReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeConnection) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	fake.bulkInfoMutex.RLock()
	defer fake.bulkInfoMutex.RUnlock()
	fake.bulkMetricsMutex.RLock()
	defer fake.bulkMetricsMutex.RUnlock()
	fake.bulkNetOutMutex.RLock()
	defer fake.bulkNetOutMutex.RUnlock()
	fake.capacityMutex.RLock()
	defer fake.capacityMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.currentBandwidthLimitsMutex.RLock()
	defer fake.currentBandwidthLimitsMutex.RUnlock()
	fake.currentCPULimitsMutex.RLock()
	defer fake.currentCPULimitsMutex.RUnlock()
	fake.currentDiskLimitsMutex.RLock()
	defer fake.currentDiskLimitsMutex.RUnlock()
	fake.currentMemoryLimitsMutex.RLock()
	defer fake.currentMemoryLimitsMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.metricsMutex.RLock()
	defer fake.metricsMutex.RUnlock()
	fake.netInMutex.RLock()
	defer fake.netInMutex.RUnlock()
	fake.netOutMutex.RLock()
	defer fake.netOutMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	fake.propertyMutex.RLock()
	defer fake.propertyMutex.RUnlock()
	fake.removePropertyMutex.RLock()
	defer fake.removePropertyMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.setGraceTimeMutex.RLock()
	defer fake.setGraceTimeMutex.RUnlock()
	fake.setPropertyMutex.RLock()
	defer fake.setPropertyMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.streamInMutex.RLock()
	defer fake.streamInMutex.RUnlock()
	fake.streamOutMutex.RLock()
	defer fake.streamOutMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConnection) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ connection.Connection = new(FakeConnection)
