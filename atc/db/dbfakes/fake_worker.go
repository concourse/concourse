// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
)

type FakeWorker struct {
	ActiveContainersStub        func() int
	activeContainersMutex       sync.RWMutex
	activeContainersArgsForCall []struct {
	}
	activeContainersReturns struct {
		result1 int
	}
	activeContainersReturnsOnCall map[int]struct {
		result1 int
	}
	ActiveTasksStub        func() (int, error)
	activeTasksMutex       sync.RWMutex
	activeTasksArgsForCall []struct {
	}
	activeTasksReturns struct {
		result1 int
		result2 error
	}
	activeTasksReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ActiveVolumesStub        func() int
	activeVolumesMutex       sync.RWMutex
	activeVolumesArgsForCall []struct {
	}
	activeVolumesReturns struct {
		result1 int
	}
	activeVolumesReturnsOnCall map[int]struct {
		result1 int
	}
	AllocatableMemoryStub        func() *atc.MemoryLimit
	allocatableMemoryMutex       sync.RWMutex
	allocatableMemoryArgsForCall []struct {
	}
	allocatableMemoryReturns struct {
		result1 *atc.MemoryLimit
	}
	allocatableMemoryReturnsOnCall map[int]struct {
		result1 *atc.MemoryLimit
	}
	BaggageclaimURLStub        func() *string
	baggageclaimURLMutex       sync.RWMutex
	baggageclaimURLArgsForCall []struct {
	}
	baggageclaimURLReturns struct {
		result1 *string
	}
	baggageclaimURLReturnsOnCall map[int]struct {
		result1 *string
	}
	CertsPathStub        func() *string
	certsPathMutex       sync.RWMutex
	certsPathArgsForCall []struct {
	}
	certsPathReturns struct {
		result1 *string
	}
	certsPathReturnsOnCall map[int]struct {
		result1 *string
	}
	CreateContainerStub        func(db.ContainerOwner, db.ContainerMetadata) (db.CreatingContainer, error)
	createContainerMutex       sync.RWMutex
	createContainerArgsForCall []struct {
		arg1 db.ContainerOwner
		arg2 db.ContainerMetadata
	}
	createContainerReturns struct {
		result1 db.CreatingContainer
		result2 error
	}
	createContainerReturnsOnCall map[int]struct {
		result1 db.CreatingContainer
		result2 error
	}
	DecreaseActiveTasksStub        func() (int, error)
	decreaseActiveTasksMutex       sync.RWMutex
	decreaseActiveTasksArgsForCall []struct {
	}
	decreaseActiveTasksReturns struct {
		result1 int
		result2 error
	}
	decreaseActiveTasksReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	DeleteStub        func() error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	EphemeralStub        func() bool
	ephemeralMutex       sync.RWMutex
	ephemeralArgsForCall []struct {
	}
	ephemeralReturns struct {
		result1 bool
	}
	ephemeralReturnsOnCall map[int]struct {
		result1 bool
	}
	ExpiresAtStub        func() time.Time
	expiresAtMutex       sync.RWMutex
	expiresAtArgsForCall []struct {
	}
	expiresAtReturns struct {
		result1 time.Time
	}
	expiresAtReturnsOnCall map[int]struct {
		result1 time.Time
	}
	FindContainerStub        func(db.ContainerOwner) (db.CreatingContainer, db.CreatedContainer, error)
	findContainerMutex       sync.RWMutex
	findContainerArgsForCall []struct {
		arg1 db.ContainerOwner
	}
	findContainerReturns struct {
		result1 db.CreatingContainer
		result2 db.CreatedContainer
		result3 error
	}
	findContainerReturnsOnCall map[int]struct {
		result1 db.CreatingContainer
		result2 db.CreatedContainer
		result3 error
	}
	GardenAddrStub        func() *string
	gardenAddrMutex       sync.RWMutex
	gardenAddrArgsForCall []struct {
	}
	gardenAddrReturns struct {
		result1 *string
	}
	gardenAddrReturnsOnCall map[int]struct {
		result1 *string
	}
	HTTPProxyURLStub        func() string
	hTTPProxyURLMutex       sync.RWMutex
	hTTPProxyURLArgsForCall []struct {
	}
	hTTPProxyURLReturns struct {
		result1 string
	}
	hTTPProxyURLReturnsOnCall map[int]struct {
		result1 string
	}
	HTTPSProxyURLStub        func() string
	hTTPSProxyURLMutex       sync.RWMutex
	hTTPSProxyURLArgsForCall []struct {
	}
	hTTPSProxyURLReturns struct {
		result1 string
	}
	hTTPSProxyURLReturnsOnCall map[int]struct {
		result1 string
	}
	IncreaseActiveTasksStub        func() (int, error)
	increaseActiveTasksMutex       sync.RWMutex
	increaseActiveTasksArgsForCall []struct {
	}
	increaseActiveTasksReturns struct {
		result1 int
		result2 error
	}
	increaseActiveTasksReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	LandStub        func() error
	landMutex       sync.RWMutex
	landArgsForCall []struct {
	}
	landReturns struct {
		result1 error
	}
	landReturnsOnCall map[int]struct {
		result1 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	NoProxyStub        func() string
	noProxyMutex       sync.RWMutex
	noProxyArgsForCall []struct {
	}
	noProxyReturns struct {
		result1 string
	}
	noProxyReturnsOnCall map[int]struct {
		result1 string
	}
	PlatformStub        func() string
	platformMutex       sync.RWMutex
	platformArgsForCall []struct {
	}
	platformReturns struct {
		result1 string
	}
	platformReturnsOnCall map[int]struct {
		result1 string
	}
	PruneStub        func() error
	pruneMutex       sync.RWMutex
	pruneArgsForCall []struct {
	}
	pruneReturns struct {
		result1 error
	}
	pruneReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
	}
	reloadReturns struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ResourceCertsStub        func() (*db.UsedWorkerResourceCerts, bool, error)
	resourceCertsMutex       sync.RWMutex
	resourceCertsArgsForCall []struct {
	}
	resourceCertsReturns struct {
		result1 *db.UsedWorkerResourceCerts
		result2 bool
		result3 error
	}
	resourceCertsReturnsOnCall map[int]struct {
		result1 *db.UsedWorkerResourceCerts
		result2 bool
		result3 error
	}
	ResourceTypesStub        func() []atc.WorkerResourceType
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct {
	}
	resourceTypesReturns struct {
		result1 []atc.WorkerResourceType
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 []atc.WorkerResourceType
	}
	RetireStub        func() error
	retireMutex       sync.RWMutex
	retireArgsForCall []struct {
	}
	retireReturns struct {
		result1 error
	}
	retireReturnsOnCall map[int]struct {
		result1 error
	}
	StartTimeStub        func() time.Time
	startTimeMutex       sync.RWMutex
	startTimeArgsForCall []struct {
	}
	startTimeReturns struct {
		result1 time.Time
	}
	startTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	StateStub        func() db.WorkerState
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
	}
	stateReturns struct {
		result1 db.WorkerState
	}
	stateReturnsOnCall map[int]struct {
		result1 db.WorkerState
	}
	TagsStub        func() []string
	tagsMutex       sync.RWMutex
	tagsArgsForCall []struct {
	}
	tagsReturns struct {
		result1 []string
	}
	tagsReturnsOnCall map[int]struct {
		result1 []string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	VersionStub        func() *string
	versionMutex       sync.RWMutex
	versionArgsForCall []struct {
	}
	versionReturns struct {
		result1 *string
	}
	versionReturnsOnCall map[int]struct {
		result1 *string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorker) ActiveContainers() int {
	fake.activeContainersMutex.Lock()
	ret, specificReturn := fake.activeContainersReturnsOnCall[len(fake.activeContainersArgsForCall)]
	fake.activeContainersArgsForCall = append(fake.activeContainersArgsForCall, struct {
	}{})
	stub := fake.ActiveContainersStub
	fakeReturns := fake.activeContainersReturns
	fake.recordInvocation("ActiveContainers", []interface{}{})
	fake.activeContainersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ActiveContainersCallCount() int {
	fake.activeContainersMutex.RLock()
	defer fake.activeContainersMutex.RUnlock()
	return len(fake.activeContainersArgsForCall)
}

func (fake *FakeWorker) ActiveContainersCalls(stub func() int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = stub
}

func (fake *FakeWorker) ActiveContainersReturns(result1 int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = nil
	fake.activeContainersReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveContainersReturnsOnCall(i int, result1 int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = nil
	if fake.activeContainersReturnsOnCall == nil {
		fake.activeContainersReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.activeContainersReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveTasks() (int, error) {
	fake.activeTasksMutex.Lock()
	ret, specificReturn := fake.activeTasksReturnsOnCall[len(fake.activeTasksArgsForCall)]
	fake.activeTasksArgsForCall = append(fake.activeTasksArgsForCall, struct {
	}{})
	stub := fake.ActiveTasksStub
	fakeReturns := fake.activeTasksReturns
	fake.recordInvocation("ActiveTasks", []interface{}{})
	fake.activeTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) ActiveTasksCallCount() int {
	fake.activeTasksMutex.RLock()
	defer fake.activeTasksMutex.RUnlock()
	return len(fake.activeTasksArgsForCall)
}

func (fake *FakeWorker) ActiveTasksCalls(stub func() (int, error)) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = stub
}

func (fake *FakeWorker) ActiveTasksReturns(result1 int, result2 error) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = nil
	fake.activeTasksReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ActiveTasksReturnsOnCall(i int, result1 int, result2 error) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = nil
	if fake.activeTasksReturnsOnCall == nil {
		fake.activeTasksReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.activeTasksReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ActiveVolumes() int {
	fake.activeVolumesMutex.Lock()
	ret, specificReturn := fake.activeVolumesReturnsOnCall[len(fake.activeVolumesArgsForCall)]
	fake.activeVolumesArgsForCall = append(fake.activeVolumesArgsForCall, struct {
	}{})
	stub := fake.ActiveVolumesStub
	fakeReturns := fake.activeVolumesReturns
	fake.recordInvocation("ActiveVolumes", []interface{}{})
	fake.activeVolumesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ActiveVolumesCallCount() int {
	fake.activeVolumesMutex.RLock()
	defer fake.activeVolumesMutex.RUnlock()
	return len(fake.activeVolumesArgsForCall)
}

func (fake *FakeWorker) ActiveVolumesCalls(stub func() int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = stub
}

func (fake *FakeWorker) ActiveVolumesReturns(result1 int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = nil
	fake.activeVolumesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveVolumesReturnsOnCall(i int, result1 int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = nil
	if fake.activeVolumesReturnsOnCall == nil {
		fake.activeVolumesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.activeVolumesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) AllocatableMemory() *atc.MemoryLimit {
	fake.allocatableMemoryMutex.Lock()
	ret, specificReturn := fake.allocatableMemoryReturnsOnCall[len(fake.allocatableMemoryArgsForCall)]
	fake.allocatableMemoryArgsForCall = append(fake.allocatableMemoryArgsForCall, struct {
	}{})
	stub := fake.AllocatableMemoryStub
	fakeReturns := fake.allocatableMemoryReturns
	fake.recordInvocation("AllocatableMemory", []interface{}{})
	fake.allocatableMemoryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) AllocatableMemoryCallCount() int {
	fake.allocatableMemoryMutex.RLock()
	defer fake.allocatableMemoryMutex.RUnlock()
	return len(fake.allocatableMemoryArgsForCall)
}

func (fake *FakeWorker) AllocatableMemoryCalls(stub func() *atc.MemoryLimit) {
	fake.allocatableMemoryMutex.Lock()
	defer fake.allocatableMemoryMutex.Unlock()
	fake.AllocatableMemoryStub = stub
}

func (fake *FakeWorker) AllocatableMemoryReturns(result1 *atc.MemoryLimit) {
	fake.allocatableMemoryMutex.Lock()
	defer fake.allocatableMemoryMutex.Unlock()
	fake.AllocatableMemoryStub = nil
	fake.allocatableMemoryReturns = struct {
		result1 *atc.MemoryLimit
	}{result1}
}

func (fake *FakeWorker) AllocatableMemoryReturnsOnCall(i int, result1 *atc.MemoryLimit) {
	fake.allocatableMemoryMutex.Lock()
	defer fake.allocatableMemoryMutex.Unlock()
	fake.AllocatableMemoryStub = nil
	if fake.allocatableMemoryReturnsOnCall == nil {
		fake.allocatableMemoryReturnsOnCall = make(map[int]struct {
			result1 *atc.MemoryLimit
		})
	}
	fake.allocatableMemoryReturnsOnCall[i] = struct {
		result1 *atc.MemoryLimit
	}{result1}
}

func (fake *FakeWorker) BaggageclaimURL() *string {
	fake.baggageclaimURLMutex.Lock()
	ret, specificReturn := fake.baggageclaimURLReturnsOnCall[len(fake.baggageclaimURLArgsForCall)]
	fake.baggageclaimURLArgsForCall = append(fake.baggageclaimURLArgsForCall, struct {
	}{})
	stub := fake.BaggageclaimURLStub
	fakeReturns := fake.baggageclaimURLReturns
	fake.recordInvocation("BaggageclaimURL", []interface{}{})
	fake.baggageclaimURLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) BaggageclaimURLCallCount() int {
	fake.baggageclaimURLMutex.RLock()
	defer fake.baggageclaimURLMutex.RUnlock()
	return len(fake.baggageclaimURLArgsForCall)
}

func (fake *FakeWorker) BaggageclaimURLCalls(stub func() *string) {
	fake.baggageclaimURLMutex.Lock()
	defer fake.baggageclaimURLMutex.Unlock()
	fake.BaggageclaimURLStub = stub
}

func (fake *FakeWorker) BaggageclaimURLReturns(result1 *string) {
	fake.baggageclaimURLMutex.Lock()
	defer fake.baggageclaimURLMutex.Unlock()
	fake.BaggageclaimURLStub = nil
	fake.baggageclaimURLReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) BaggageclaimURLReturnsOnCall(i int, result1 *string) {
	fake.baggageclaimURLMutex.Lock()
	defer fake.baggageclaimURLMutex.Unlock()
	fake.BaggageclaimURLStub = nil
	if fake.baggageclaimURLReturnsOnCall == nil {
		fake.baggageclaimURLReturnsOnCall = make(map[int]struct {
			result1 *string
		})
	}
	fake.baggageclaimURLReturnsOnCall[i] = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) CertsPath() *string {
	fake.certsPathMutex.Lock()
	ret, specificReturn := fake.certsPathReturnsOnCall[len(fake.certsPathArgsForCall)]
	fake.certsPathArgsForCall = append(fake.certsPathArgsForCall, struct {
	}{})
	stub := fake.CertsPathStub
	fakeReturns := fake.certsPathReturns
	fake.recordInvocation("CertsPath", []interface{}{})
	fake.certsPathMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) CertsPathCallCount() int {
	fake.certsPathMutex.RLock()
	defer fake.certsPathMutex.RUnlock()
	return len(fake.certsPathArgsForCall)
}

func (fake *FakeWorker) CertsPathCalls(stub func() *string) {
	fake.certsPathMutex.Lock()
	defer fake.certsPathMutex.Unlock()
	fake.CertsPathStub = stub
}

func (fake *FakeWorker) CertsPathReturns(result1 *string) {
	fake.certsPathMutex.Lock()
	defer fake.certsPathMutex.Unlock()
	fake.CertsPathStub = nil
	fake.certsPathReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) CertsPathReturnsOnCall(i int, result1 *string) {
	fake.certsPathMutex.Lock()
	defer fake.certsPathMutex.Unlock()
	fake.CertsPathStub = nil
	if fake.certsPathReturnsOnCall == nil {
		fake.certsPathReturnsOnCall = make(map[int]struct {
			result1 *string
		})
	}
	fake.certsPathReturnsOnCall[i] = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) CreateContainer(arg1 db.ContainerOwner, arg2 db.ContainerMetadata) (db.CreatingContainer, error) {
	fake.createContainerMutex.Lock()
	ret, specificReturn := fake.createContainerReturnsOnCall[len(fake.createContainerArgsForCall)]
	fake.createContainerArgsForCall = append(fake.createContainerArgsForCall, struct {
		arg1 db.ContainerOwner
		arg2 db.ContainerMetadata
	}{arg1, arg2})
	stub := fake.CreateContainerStub
	fakeReturns := fake.createContainerReturns
	fake.recordInvocation("CreateContainer", []interface{}{arg1, arg2})
	fake.createContainerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) CreateContainerCallCount() int {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	return len(fake.createContainerArgsForCall)
}

func (fake *FakeWorker) CreateContainerCalls(stub func(db.ContainerOwner, db.ContainerMetadata) (db.CreatingContainer, error)) {
	fake.createContainerMutex.Lock()
	defer fake.createContainerMutex.Unlock()
	fake.CreateContainerStub = stub
}

func (fake *FakeWorker) CreateContainerArgsForCall(i int) (db.ContainerOwner, db.ContainerMetadata) {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	argsForCall := fake.createContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) CreateContainerReturns(result1 db.CreatingContainer, result2 error) {
	fake.createContainerMutex.Lock()
	defer fake.createContainerMutex.Unlock()
	fake.CreateContainerStub = nil
	fake.createContainerReturns = struct {
		result1 db.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) CreateContainerReturnsOnCall(i int, result1 db.CreatingContainer, result2 error) {
	fake.createContainerMutex.Lock()
	defer fake.createContainerMutex.Unlock()
	fake.CreateContainerStub = nil
	if fake.createContainerReturnsOnCall == nil {
		fake.createContainerReturnsOnCall = make(map[int]struct {
			result1 db.CreatingContainer
			result2 error
		})
	}
	fake.createContainerReturnsOnCall[i] = struct {
		result1 db.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) DecreaseActiveTasks() (int, error) {
	fake.decreaseActiveTasksMutex.Lock()
	ret, specificReturn := fake.decreaseActiveTasksReturnsOnCall[len(fake.decreaseActiveTasksArgsForCall)]
	fake.decreaseActiveTasksArgsForCall = append(fake.decreaseActiveTasksArgsForCall, struct {
	}{})
	stub := fake.DecreaseActiveTasksStub
	fakeReturns := fake.decreaseActiveTasksReturns
	fake.recordInvocation("DecreaseActiveTasks", []interface{}{})
	fake.decreaseActiveTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) DecreaseActiveTasksCallCount() int {
	fake.decreaseActiveTasksMutex.RLock()
	defer fake.decreaseActiveTasksMutex.RUnlock()
	return len(fake.decreaseActiveTasksArgsForCall)
}

func (fake *FakeWorker) DecreaseActiveTasksCalls(stub func() (int, error)) {
	fake.decreaseActiveTasksMutex.Lock()
	defer fake.decreaseActiveTasksMutex.Unlock()
	fake.DecreaseActiveTasksStub = stub
}

func (fake *FakeWorker) DecreaseActiveTasksReturns(result1 int, result2 error) {
	fake.decreaseActiveTasksMutex.Lock()
	defer fake.decreaseActiveTasksMutex.Unlock()
	fake.DecreaseActiveTasksStub = nil
	fake.decreaseActiveTasksReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) DecreaseActiveTasksReturnsOnCall(i int, result1 int, result2 error) {
	fake.decreaseActiveTasksMutex.Lock()
	defer fake.decreaseActiveTasksMutex.Unlock()
	fake.DecreaseActiveTasksStub = nil
	if fake.decreaseActiveTasksReturnsOnCall == nil {
		fake.decreaseActiveTasksReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.decreaseActiveTasksReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) Delete() error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
	}{})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeWorker) DeleteCalls(stub func() error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeWorker) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) Ephemeral() bool {
	fake.ephemeralMutex.Lock()
	ret, specificReturn := fake.ephemeralReturnsOnCall[len(fake.ephemeralArgsForCall)]
	fake.ephemeralArgsForCall = append(fake.ephemeralArgsForCall, struct {
	}{})
	stub := fake.EphemeralStub
	fakeReturns := fake.ephemeralReturns
	fake.recordInvocation("Ephemeral", []interface{}{})
	fake.ephemeralMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) EphemeralCallCount() int {
	fake.ephemeralMutex.RLock()
	defer fake.ephemeralMutex.RUnlock()
	return len(fake.ephemeralArgsForCall)
}

func (fake *FakeWorker) EphemeralCalls(stub func() bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = stub
}

func (fake *FakeWorker) EphemeralReturns(result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	fake.ephemeralReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) EphemeralReturnsOnCall(i int, result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	if fake.ephemeralReturnsOnCall == nil {
		fake.ephemeralReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ephemeralReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) ExpiresAt() time.Time {
	fake.expiresAtMutex.Lock()
	ret, specificReturn := fake.expiresAtReturnsOnCall[len(fake.expiresAtArgsForCall)]
	fake.expiresAtArgsForCall = append(fake.expiresAtArgsForCall, struct {
	}{})
	stub := fake.ExpiresAtStub
	fakeReturns := fake.expiresAtReturns
	fake.recordInvocation("ExpiresAt", []interface{}{})
	fake.expiresAtMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ExpiresAtCallCount() int {
	fake.expiresAtMutex.RLock()
	defer fake.expiresAtMutex.RUnlock()
	return len(fake.expiresAtArgsForCall)
}

func (fake *FakeWorker) ExpiresAtCalls(stub func() time.Time) {
	fake.expiresAtMutex.Lock()
	defer fake.expiresAtMutex.Unlock()
	fake.ExpiresAtStub = stub
}

func (fake *FakeWorker) ExpiresAtReturns(result1 time.Time) {
	fake.expiresAtMutex.Lock()
	defer fake.expiresAtMutex.Unlock()
	fake.ExpiresAtStub = nil
	fake.expiresAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeWorker) ExpiresAtReturnsOnCall(i int, result1 time.Time) {
	fake.expiresAtMutex.Lock()
	defer fake.expiresAtMutex.Unlock()
	fake.ExpiresAtStub = nil
	if fake.expiresAtReturnsOnCall == nil {
		fake.expiresAtReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.expiresAtReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeWorker) FindContainer(arg1 db.ContainerOwner) (db.CreatingContainer, db.CreatedContainer, error) {
	fake.findContainerMutex.Lock()
	ret, specificReturn := fake.findContainerReturnsOnCall[len(fake.findContainerArgsForCall)]
	fake.findContainerArgsForCall = append(fake.findContainerArgsForCall, struct {
		arg1 db.ContainerOwner
	}{arg1})
	stub := fake.FindContainerStub
	fakeReturns := fake.findContainerReturns
	fake.recordInvocation("FindContainer", []interface{}{arg1})
	fake.findContainerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindContainerCallCount() int {
	fake.findContainerMutex.RLock()
	defer fake.findContainerMutex.RUnlock()
	return len(fake.findContainerArgsForCall)
}

func (fake *FakeWorker) FindContainerCalls(stub func(db.ContainerOwner) (db.CreatingContainer, db.CreatedContainer, error)) {
	fake.findContainerMutex.Lock()
	defer fake.findContainerMutex.Unlock()
	fake.FindContainerStub = stub
}

func (fake *FakeWorker) FindContainerArgsForCall(i int) db.ContainerOwner {
	fake.findContainerMutex.RLock()
	defer fake.findContainerMutex.RUnlock()
	argsForCall := fake.findContainerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorker) FindContainerReturns(result1 db.CreatingContainer, result2 db.CreatedContainer, result3 error) {
	fake.findContainerMutex.Lock()
	defer fake.findContainerMutex.Unlock()
	fake.FindContainerStub = nil
	fake.findContainerReturns = struct {
		result1 db.CreatingContainer
		result2 db.CreatedContainer
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindContainerReturnsOnCall(i int, result1 db.CreatingContainer, result2 db.CreatedContainer, result3 error) {
	fake.findContainerMutex.Lock()
	defer fake.findContainerMutex.Unlock()
	fake.FindContainerStub = nil
	if fake.findContainerReturnsOnCall == nil {
		fake.findContainerReturnsOnCall = make(map[int]struct {
			result1 db.CreatingContainer
			result2 db.CreatedContainer
			result3 error
		})
	}
	fake.findContainerReturnsOnCall[i] = struct {
		result1 db.CreatingContainer
		result2 db.CreatedContainer
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) GardenAddr() *string {
	fake.gardenAddrMutex.Lock()
	ret, specificReturn := fake.gardenAddrReturnsOnCall[len(fake.gardenAddrArgsForCall)]
	fake.gardenAddrArgsForCall = append(fake.gardenAddrArgsForCall, struct {
	}{})
	stub := fake.GardenAddrStub
	fakeReturns := fake.gardenAddrReturns
	fake.recordInvocation("GardenAddr", []interface{}{})
	fake.gardenAddrMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) GardenAddrCallCount() int {
	fake.gardenAddrMutex.RLock()
	defer fake.gardenAddrMutex.RUnlock()
	return len(fake.gardenAddrArgsForCall)
}

func (fake *FakeWorker) GardenAddrCalls(stub func() *string) {
	fake.gardenAddrMutex.Lock()
	defer fake.gardenAddrMutex.Unlock()
	fake.GardenAddrStub = stub
}

func (fake *FakeWorker) GardenAddrReturns(result1 *string) {
	fake.gardenAddrMutex.Lock()
	defer fake.gardenAddrMutex.Unlock()
	fake.GardenAddrStub = nil
	fake.gardenAddrReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) GardenAddrReturnsOnCall(i int, result1 *string) {
	fake.gardenAddrMutex.Lock()
	defer fake.gardenAddrMutex.Unlock()
	fake.GardenAddrStub = nil
	if fake.gardenAddrReturnsOnCall == nil {
		fake.gardenAddrReturnsOnCall = make(map[int]struct {
			result1 *string
		})
	}
	fake.gardenAddrReturnsOnCall[i] = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) HTTPProxyURL() string {
	fake.hTTPProxyURLMutex.Lock()
	ret, specificReturn := fake.hTTPProxyURLReturnsOnCall[len(fake.hTTPProxyURLArgsForCall)]
	fake.hTTPProxyURLArgsForCall = append(fake.hTTPProxyURLArgsForCall, struct {
	}{})
	stub := fake.HTTPProxyURLStub
	fakeReturns := fake.hTTPProxyURLReturns
	fake.recordInvocation("HTTPProxyURL", []interface{}{})
	fake.hTTPProxyURLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) HTTPProxyURLCallCount() int {
	fake.hTTPProxyURLMutex.RLock()
	defer fake.hTTPProxyURLMutex.RUnlock()
	return len(fake.hTTPProxyURLArgsForCall)
}

func (fake *FakeWorker) HTTPProxyURLCalls(stub func() string) {
	fake.hTTPProxyURLMutex.Lock()
	defer fake.hTTPProxyURLMutex.Unlock()
	fake.HTTPProxyURLStub = stub
}

func (fake *FakeWorker) HTTPProxyURLReturns(result1 string) {
	fake.hTTPProxyURLMutex.Lock()
	defer fake.hTTPProxyURLMutex.Unlock()
	fake.HTTPProxyURLStub = nil
	fake.hTTPProxyURLReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) HTTPProxyURLReturnsOnCall(i int, result1 string) {
	fake.hTTPProxyURLMutex.Lock()
	defer fake.hTTPProxyURLMutex.Unlock()
	fake.HTTPProxyURLStub = nil
	if fake.hTTPProxyURLReturnsOnCall == nil {
		fake.hTTPProxyURLReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.hTTPProxyURLReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) HTTPSProxyURL() string {
	fake.hTTPSProxyURLMutex.Lock()
	ret, specificReturn := fake.hTTPSProxyURLReturnsOnCall[len(fake.hTTPSProxyURLArgsForCall)]
	fake.hTTPSProxyURLArgsForCall = append(fake.hTTPSProxyURLArgsForCall, struct {
	}{})
	stub := fake.HTTPSProxyURLStub
	fakeReturns := fake.hTTPSProxyURLReturns
	fake.recordInvocation("HTTPSProxyURL", []interface{}{})
	fake.hTTPSProxyURLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) HTTPSProxyURLCallCount() int {
	fake.hTTPSProxyURLMutex.RLock()
	defer fake.hTTPSProxyURLMutex.RUnlock()
	return len(fake.hTTPSProxyURLArgsForCall)
}

func (fake *FakeWorker) HTTPSProxyURLCalls(stub func() string) {
	fake.hTTPSProxyURLMutex.Lock()
	defer fake.hTTPSProxyURLMutex.Unlock()
	fake.HTTPSProxyURLStub = stub
}

func (fake *FakeWorker) HTTPSProxyURLReturns(result1 string) {
	fake.hTTPSProxyURLMutex.Lock()
	defer fake.hTTPSProxyURLMutex.Unlock()
	fake.HTTPSProxyURLStub = nil
	fake.hTTPSProxyURLReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) HTTPSProxyURLReturnsOnCall(i int, result1 string) {
	fake.hTTPSProxyURLMutex.Lock()
	defer fake.hTTPSProxyURLMutex.Unlock()
	fake.HTTPSProxyURLStub = nil
	if fake.hTTPSProxyURLReturnsOnCall == nil {
		fake.hTTPSProxyURLReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.hTTPSProxyURLReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) IncreaseActiveTasks() (int, error) {
	fake.increaseActiveTasksMutex.Lock()
	ret, specificReturn := fake.increaseActiveTasksReturnsOnCall[len(fake.increaseActiveTasksArgsForCall)]
	fake.increaseActiveTasksArgsForCall = append(fake.increaseActiveTasksArgsForCall, struct {
	}{})
	stub := fake.IncreaseActiveTasksStub
	fakeReturns := fake.increaseActiveTasksReturns
	fake.recordInvocation("IncreaseActiveTasks", []interface{}{})
	fake.increaseActiveTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) IncreaseActiveTasksCallCount() int {
	fake.increaseActiveTasksMutex.RLock()
	defer fake.increaseActiveTasksMutex.RUnlock()
	return len(fake.increaseActiveTasksArgsForCall)
}

func (fake *FakeWorker) IncreaseActiveTasksCalls(stub func() (int, error)) {
	fake.increaseActiveTasksMutex.Lock()
	defer fake.increaseActiveTasksMutex.Unlock()
	fake.IncreaseActiveTasksStub = stub
}

func (fake *FakeWorker) IncreaseActiveTasksReturns(result1 int, result2 error) {
	fake.increaseActiveTasksMutex.Lock()
	defer fake.increaseActiveTasksMutex.Unlock()
	fake.IncreaseActiveTasksStub = nil
	fake.increaseActiveTasksReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) IncreaseActiveTasksReturnsOnCall(i int, result1 int, result2 error) {
	fake.increaseActiveTasksMutex.Lock()
	defer fake.increaseActiveTasksMutex.Unlock()
	fake.IncreaseActiveTasksStub = nil
	if fake.increaseActiveTasksReturnsOnCall == nil {
		fake.increaseActiveTasksReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.increaseActiveTasksReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) Land() error {
	fake.landMutex.Lock()
	ret, specificReturn := fake.landReturnsOnCall[len(fake.landArgsForCall)]
	fake.landArgsForCall = append(fake.landArgsForCall, struct {
	}{})
	stub := fake.LandStub
	fakeReturns := fake.landReturns
	fake.recordInvocation("Land", []interface{}{})
	fake.landMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) LandCallCount() int {
	fake.landMutex.RLock()
	defer fake.landMutex.RUnlock()
	return len(fake.landArgsForCall)
}

func (fake *FakeWorker) LandCalls(stub func() error) {
	fake.landMutex.Lock()
	defer fake.landMutex.Unlock()
	fake.LandStub = stub
}

func (fake *FakeWorker) LandReturns(result1 error) {
	fake.landMutex.Lock()
	defer fake.landMutex.Unlock()
	fake.LandStub = nil
	fake.landReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) LandReturnsOnCall(i int, result1 error) {
	fake.landMutex.Lock()
	defer fake.landMutex.Unlock()
	fake.LandStub = nil
	if fake.landReturnsOnCall == nil {
		fake.landReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.landReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeWorker) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeWorker) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) NoProxy() string {
	fake.noProxyMutex.Lock()
	ret, specificReturn := fake.noProxyReturnsOnCall[len(fake.noProxyArgsForCall)]
	fake.noProxyArgsForCall = append(fake.noProxyArgsForCall, struct {
	}{})
	stub := fake.NoProxyStub
	fakeReturns := fake.noProxyReturns
	fake.recordInvocation("NoProxy", []interface{}{})
	fake.noProxyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) NoProxyCallCount() int {
	fake.noProxyMutex.RLock()
	defer fake.noProxyMutex.RUnlock()
	return len(fake.noProxyArgsForCall)
}

func (fake *FakeWorker) NoProxyCalls(stub func() string) {
	fake.noProxyMutex.Lock()
	defer fake.noProxyMutex.Unlock()
	fake.NoProxyStub = stub
}

func (fake *FakeWorker) NoProxyReturns(result1 string) {
	fake.noProxyMutex.Lock()
	defer fake.noProxyMutex.Unlock()
	fake.NoProxyStub = nil
	fake.noProxyReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) NoProxyReturnsOnCall(i int, result1 string) {
	fake.noProxyMutex.Lock()
	defer fake.noProxyMutex.Unlock()
	fake.NoProxyStub = nil
	if fake.noProxyReturnsOnCall == nil {
		fake.noProxyReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.noProxyReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Platform() string {
	fake.platformMutex.Lock()
	ret, specificReturn := fake.platformReturnsOnCall[len(fake.platformArgsForCall)]
	fake.platformArgsForCall = append(fake.platformArgsForCall, struct {
	}{})
	stub := fake.PlatformStub
	fakeReturns := fake.platformReturns
	fake.recordInvocation("Platform", []interface{}{})
	fake.platformMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) PlatformCallCount() int {
	fake.platformMutex.RLock()
	defer fake.platformMutex.RUnlock()
	return len(fake.platformArgsForCall)
}

func (fake *FakeWorker) PlatformCalls(stub func() string) {
	fake.platformMutex.Lock()
	defer fake.platformMutex.Unlock()
	fake.PlatformStub = stub
}

func (fake *FakeWorker) PlatformReturns(result1 string) {
	fake.platformMutex.Lock()
	defer fake.platformMutex.Unlock()
	fake.PlatformStub = nil
	fake.platformReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) PlatformReturnsOnCall(i int, result1 string) {
	fake.platformMutex.Lock()
	defer fake.platformMutex.Unlock()
	fake.PlatformStub = nil
	if fake.platformReturnsOnCall == nil {
		fake.platformReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.platformReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Prune() error {
	fake.pruneMutex.Lock()
	ret, specificReturn := fake.pruneReturnsOnCall[len(fake.pruneArgsForCall)]
	fake.pruneArgsForCall = append(fake.pruneArgsForCall, struct {
	}{})
	stub := fake.PruneStub
	fakeReturns := fake.pruneReturns
	fake.recordInvocation("Prune", []interface{}{})
	fake.pruneMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) PruneCallCount() int {
	fake.pruneMutex.RLock()
	defer fake.pruneMutex.RUnlock()
	return len(fake.pruneArgsForCall)
}

func (fake *FakeWorker) PruneCalls(stub func() error) {
	fake.pruneMutex.Lock()
	defer fake.pruneMutex.Unlock()
	fake.PruneStub = stub
}

func (fake *FakeWorker) PruneReturns(result1 error) {
	fake.pruneMutex.Lock()
	defer fake.pruneMutex.Unlock()
	fake.PruneStub = nil
	fake.pruneReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) PruneReturnsOnCall(i int, result1 error) {
	fake.pruneMutex.Lock()
	defer fake.pruneMutex.Unlock()
	fake.PruneStub = nil
	if fake.pruneReturnsOnCall == nil {
		fake.pruneReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pruneReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
	}{})
	stub := fake.ReloadStub
	fakeReturns := fake.reloadReturns
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakeWorker) ReloadCalls(stub func() (bool, error)) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = stub
}

func (fake *FakeWorker) ReloadReturns(result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ResourceCerts() (*db.UsedWorkerResourceCerts, bool, error) {
	fake.resourceCertsMutex.Lock()
	ret, specificReturn := fake.resourceCertsReturnsOnCall[len(fake.resourceCertsArgsForCall)]
	fake.resourceCertsArgsForCall = append(fake.resourceCertsArgsForCall, struct {
	}{})
	stub := fake.ResourceCertsStub
	fakeReturns := fake.resourceCertsReturns
	fake.recordInvocation("ResourceCerts", []interface{}{})
	fake.resourceCertsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) ResourceCertsCallCount() int {
	fake.resourceCertsMutex.RLock()
	defer fake.resourceCertsMutex.RUnlock()
	return len(fake.resourceCertsArgsForCall)
}

func (fake *FakeWorker) ResourceCertsCalls(stub func() (*db.UsedWorkerResourceCerts, bool, error)) {
	fake.resourceCertsMutex.Lock()
	defer fake.resourceCertsMutex.Unlock()
	fake.ResourceCertsStub = stub
}

func (fake *FakeWorker) ResourceCertsReturns(result1 *db.UsedWorkerResourceCerts, result2 bool, result3 error) {
	fake.resourceCertsMutex.Lock()
	defer fake.resourceCertsMutex.Unlock()
	fake.ResourceCertsStub = nil
	fake.resourceCertsReturns = struct {
		result1 *db.UsedWorkerResourceCerts
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) ResourceCertsReturnsOnCall(i int, result1 *db.UsedWorkerResourceCerts, result2 bool, result3 error) {
	fake.resourceCertsMutex.Lock()
	defer fake.resourceCertsMutex.Unlock()
	fake.ResourceCertsStub = nil
	if fake.resourceCertsReturnsOnCall == nil {
		fake.resourceCertsReturnsOnCall = make(map[int]struct {
			result1 *db.UsedWorkerResourceCerts
			result2 bool
			result3 error
		})
	}
	fake.resourceCertsReturnsOnCall[i] = struct {
		result1 *db.UsedWorkerResourceCerts
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) ResourceTypes() []atc.WorkerResourceType {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct {
	}{})
	stub := fake.ResourceTypesStub
	fakeReturns := fake.resourceTypesReturns
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakeWorker) ResourceTypesCalls(stub func() []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = stub
}

func (fake *FakeWorker) ResourceTypesReturns(result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) ResourceTypesReturnsOnCall(i int, result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 []atc.WorkerResourceType
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) Retire() error {
	fake.retireMutex.Lock()
	ret, specificReturn := fake.retireReturnsOnCall[len(fake.retireArgsForCall)]
	fake.retireArgsForCall = append(fake.retireArgsForCall, struct {
	}{})
	stub := fake.RetireStub
	fakeReturns := fake.retireReturns
	fake.recordInvocation("Retire", []interface{}{})
	fake.retireMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) RetireCallCount() int {
	fake.retireMutex.RLock()
	defer fake.retireMutex.RUnlock()
	return len(fake.retireArgsForCall)
}

func (fake *FakeWorker) RetireCalls(stub func() error) {
	fake.retireMutex.Lock()
	defer fake.retireMutex.Unlock()
	fake.RetireStub = stub
}

func (fake *FakeWorker) RetireReturns(result1 error) {
	fake.retireMutex.Lock()
	defer fake.retireMutex.Unlock()
	fake.RetireStub = nil
	fake.retireReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) RetireReturnsOnCall(i int, result1 error) {
	fake.retireMutex.Lock()
	defer fake.retireMutex.Unlock()
	fake.RetireStub = nil
	if fake.retireReturnsOnCall == nil {
		fake.retireReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.retireReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) StartTime() time.Time {
	fake.startTimeMutex.Lock()
	ret, specificReturn := fake.startTimeReturnsOnCall[len(fake.startTimeArgsForCall)]
	fake.startTimeArgsForCall = append(fake.startTimeArgsForCall, struct {
	}{})
	stub := fake.StartTimeStub
	fakeReturns := fake.startTimeReturns
	fake.recordInvocation("StartTime", []interface{}{})
	fake.startTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) StartTimeCallCount() int {
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	return len(fake.startTimeArgsForCall)
}

func (fake *FakeWorker) StartTimeCalls(stub func() time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = stub
}

func (fake *FakeWorker) StartTimeReturns(result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	fake.startTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeWorker) StartTimeReturnsOnCall(i int, result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	if fake.startTimeReturnsOnCall == nil {
		fake.startTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.startTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeWorker) State() db.WorkerState {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
	}{})
	stub := fake.StateStub
	fakeReturns := fake.stateReturns
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeWorker) StateCalls(stub func() db.WorkerState) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *FakeWorker) StateReturns(result1 db.WorkerState) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 db.WorkerState
	}{result1}
}

func (fake *FakeWorker) StateReturnsOnCall(i int, result1 db.WorkerState) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 db.WorkerState
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 db.WorkerState
	}{result1}
}

func (fake *FakeWorker) Tags() []string {
	fake.tagsMutex.Lock()
	ret, specificReturn := fake.tagsReturnsOnCall[len(fake.tagsArgsForCall)]
	fake.tagsArgsForCall = append(fake.tagsArgsForCall, struct {
	}{})
	stub := fake.TagsStub
	fakeReturns := fake.tagsReturns
	fake.recordInvocation("Tags", []interface{}{})
	fake.tagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) TagsCallCount() int {
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	return len(fake.tagsArgsForCall)
}

func (fake *FakeWorker) TagsCalls(stub func() []string) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = stub
}

func (fake *FakeWorker) TagsReturns(result1 []string) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	fake.tagsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeWorker) TagsReturnsOnCall(i int, result1 []string) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	if fake.tagsReturnsOnCall == nil {
		fake.tagsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.tagsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeWorker) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	stub := fake.TeamIDStub
	fakeReturns := fake.teamIDReturns
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakeWorker) TeamIDCalls(stub func() int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = stub
}

func (fake *FakeWorker) TeamIDReturns(result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) TeamIDReturnsOnCall(i int, result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	stub := fake.TeamNameStub
	fakeReturns := fake.teamNameReturns
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakeWorker) TeamNameCalls(stub func() string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = stub
}

func (fake *FakeWorker) TeamNameReturns(result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) TeamNameReturnsOnCall(i int, result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Version() *string {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct {
	}{})
	stub := fake.VersionStub
	fakeReturns := fake.versionReturns
	fake.recordInvocation("Version", []interface{}{})
	fake.versionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeWorker) VersionCalls(stub func() *string) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = stub
}

func (fake *FakeWorker) VersionReturns(result1 *string) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) VersionReturnsOnCall(i int, result1 *string) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 *string
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activeContainersMutex.RLock()
	defer fake.activeContainersMutex.RUnlock()
	fake.activeTasksMutex.RLock()
	defer fake.activeTasksMutex.RUnlock()
	fake.activeVolumesMutex.RLock()
	defer fake.activeVolumesMutex.RUnlock()
	fake.allocatableMemoryMutex.RLock()
	defer fake.allocatableMemoryMutex.RUnlock()
	fake.baggageclaimURLMutex.RLock()
	defer fake.baggageclaimURLMutex.RUnlock()
	fake.certsPathMutex.RLock()
	defer fake.certsPathMutex.RUnlock()
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	fake.decreaseActiveTasksMutex.RLock()
	defer fake.decreaseActiveTasksMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.ephemeralMutex.RLock()
	defer fake.ephemeralMutex.RUnlock()
	fake.expiresAtMutex.RLock()
	defer fake.expiresAtMutex.RUnlock()
	fake.findContainerMutex.RLock()
	defer fake.findContainerMutex.RUnlock()
	fake.gardenAddrMutex.RLock()
	defer fake.gardenAddrMutex.RUnlock()
	fake.hTTPProxyURLMutex.RLock()
	defer fake.hTTPProxyURLMutex.RUnlock()
	fake.hTTPSProxyURLMutex.RLock()
	defer fake.hTTPSProxyURLMutex.RUnlock()
	fake.increaseActiveTasksMutex.RLock()
	defer fake.increaseActiveTasksMutex.RUnlock()
	fake.landMutex.RLock()
	defer fake.landMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.noProxyMutex.RLock()
	defer fake.noProxyMutex.RUnlock()
	fake.platformMutex.RLock()
	defer fake.platformMutex.RUnlock()
	fake.pruneMutex.RLock()
	defer fake.pruneMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.resourceCertsMutex.RLock()
	defer fake.resourceCertsMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.retireMutex.RLock()
	defer fake.retireMutex.RUnlock()
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorker) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Worker = new(FakeWorker)
