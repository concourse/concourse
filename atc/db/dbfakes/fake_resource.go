// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"context"
	"sync"
	"time"

	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/util"
)

type FakeResource struct {
	APIPinnedVersionStub        func() atc.Version
	aPIPinnedVersionMutex       sync.RWMutex
	aPIPinnedVersionArgsForCall []struct {
	}
	aPIPinnedVersionReturns struct {
		result1 atc.Version
	}
	aPIPinnedVersionReturnsOnCall map[int]struct {
		result1 atc.Version
	}
	BuildSummaryStub        func() *atc.BuildSummary
	buildSummaryMutex       sync.RWMutex
	buildSummaryArgsForCall []struct {
	}
	buildSummaryReturns struct {
		result1 *atc.BuildSummary
	}
	buildSummaryReturnsOnCall map[int]struct {
		result1 *atc.BuildSummary
	}
	CausalityStub        func(int, db.CausalityDirection) (atc.Causality, bool, error)
	causalityMutex       sync.RWMutex
	causalityArgsForCall []struct {
		arg1 int
		arg2 db.CausalityDirection
	}
	causalityReturns struct {
		result1 atc.Causality
		result2 bool
		result3 error
	}
	causalityReturnsOnCall map[int]struct {
		result1 atc.Causality
		result2 bool
		result3 error
	}
	CheckEveryStub        func() *atc.CheckEvery
	checkEveryMutex       sync.RWMutex
	checkEveryArgsForCall []struct {
	}
	checkEveryReturns struct {
		result1 *atc.CheckEvery
	}
	checkEveryReturnsOnCall map[int]struct {
		result1 *atc.CheckEvery
	}
	CheckPlanStub        func(atc.PlanFactory, atc.ImagePlanner, atc.Version, atc.CheckEvery, atc.Source, bool, bool) atc.Plan
	checkPlanMutex       sync.RWMutex
	checkPlanArgsForCall []struct {
		arg1 atc.PlanFactory
		arg2 atc.ImagePlanner
		arg3 atc.Version
		arg4 atc.CheckEvery
		arg5 atc.Source
		arg6 bool
		arg7 bool
	}
	checkPlanReturns struct {
		result1 atc.Plan
	}
	checkPlanReturnsOnCall map[int]struct {
		result1 atc.Plan
	}
	CheckTimeoutStub        func() string
	checkTimeoutMutex       sync.RWMutex
	checkTimeoutArgsForCall []struct {
	}
	checkTimeoutReturns struct {
		result1 string
	}
	checkTimeoutReturnsOnCall map[int]struct {
		result1 string
	}
	ClearResourceCacheStub        func(atc.Version) (int64, error)
	clearResourceCacheMutex       sync.RWMutex
	clearResourceCacheArgsForCall []struct {
		arg1 atc.Version
	}
	clearResourceCacheReturns struct {
		result1 int64
		result2 error
	}
	clearResourceCacheReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	ConfigStub        func() atc.ResourceConfig
	configMutex       sync.RWMutex
	configArgsForCall []struct {
	}
	configReturns struct {
		result1 atc.ResourceConfig
	}
	configReturnsOnCall map[int]struct {
		result1 atc.ResourceConfig
	}
	ConfigPinnedVersionStub        func() atc.Version
	configPinnedVersionMutex       sync.RWMutex
	configPinnedVersionArgsForCall []struct {
	}
	configPinnedVersionReturns struct {
		result1 atc.Version
	}
	configPinnedVersionReturnsOnCall map[int]struct {
		result1 atc.Version
	}
	CreateBuildStub        func(context.Context, bool, atc.Plan) (db.Build, bool, error)
	createBuildMutex       sync.RWMutex
	createBuildArgsForCall []struct {
		arg1 context.Context
		arg2 bool
		arg3 atc.Plan
	}
	createBuildReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	createBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	CreateInMemoryBuildStub        func(context.Context, atc.Plan, util.SequenceGenerator) (db.Build, error)
	createInMemoryBuildMutex       sync.RWMutex
	createInMemoryBuildArgsForCall []struct {
		arg1 context.Context
		arg2 atc.Plan
		arg3 util.SequenceGenerator
	}
	createInMemoryBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createInMemoryBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	CurrentPinnedVersionStub        func() atc.Version
	currentPinnedVersionMutex       sync.RWMutex
	currentPinnedVersionArgsForCall []struct {
	}
	currentPinnedVersionReturns struct {
		result1 atc.Version
	}
	currentPinnedVersionReturnsOnCall map[int]struct {
		result1 atc.Version
	}
	DisableVersionStub        func(int) error
	disableVersionMutex       sync.RWMutex
	disableVersionArgsForCall []struct {
		arg1 int
	}
	disableVersionReturns struct {
		result1 error
	}
	disableVersionReturnsOnCall map[int]struct {
		result1 error
	}
	EnableVersionStub        func(int) error
	enableVersionMutex       sync.RWMutex
	enableVersionArgsForCall []struct {
		arg1 int
	}
	enableVersionReturns struct {
		result1 error
	}
	enableVersionReturnsOnCall map[int]struct {
		result1 error
	}
	FindVersionStub        func(atc.Version) (db.ResourceConfigVersion, bool, error)
	findVersionMutex       sync.RWMutex
	findVersionArgsForCall []struct {
		arg1 atc.Version
	}
	findVersionReturns struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	findVersionReturnsOnCall map[int]struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	HasWebhookStub        func() bool
	hasWebhookMutex       sync.RWMutex
	hasWebhookArgsForCall []struct {
	}
	hasWebhookReturns struct {
		result1 bool
	}
	hasWebhookReturnsOnCall map[int]struct {
		result1 bool
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	IconStub        func() string
	iconMutex       sync.RWMutex
	iconArgsForCall []struct {
	}
	iconReturns struct {
		result1 string
	}
	iconReturnsOnCall map[int]struct {
		result1 string
	}
	LastCheckEndTimeStub        func() time.Time
	lastCheckEndTimeMutex       sync.RWMutex
	lastCheckEndTimeArgsForCall []struct {
	}
	lastCheckEndTimeReturns struct {
		result1 time.Time
	}
	lastCheckEndTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	NotifyScanStub        func() error
	notifyScanMutex       sync.RWMutex
	notifyScanArgsForCall []struct {
	}
	notifyScanReturns struct {
		result1 error
	}
	notifyScanReturnsOnCall map[int]struct {
		result1 error
	}
	PinCommentStub        func() string
	pinCommentMutex       sync.RWMutex
	pinCommentArgsForCall []struct {
	}
	pinCommentReturns struct {
		result1 string
	}
	pinCommentReturnsOnCall map[int]struct {
		result1 string
	}
	PinVersionStub        func(int) (bool, error)
	pinVersionMutex       sync.RWMutex
	pinVersionArgsForCall []struct {
		arg1 int
	}
	pinVersionReturns struct {
		result1 bool
		result2 error
	}
	pinVersionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PipelineStub        func() (db.Pipeline, bool, error)
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct {
	}
	pipelineReturns struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	pipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	PipelineIDStub        func() int
	pipelineIDMutex       sync.RWMutex
	pipelineIDArgsForCall []struct {
	}
	pipelineIDReturns struct {
		result1 int
	}
	pipelineIDReturnsOnCall map[int]struct {
		result1 int
	}
	PipelineInstanceVarsStub        func() atc.InstanceVars
	pipelineInstanceVarsMutex       sync.RWMutex
	pipelineInstanceVarsArgsForCall []struct {
	}
	pipelineInstanceVarsReturns struct {
		result1 atc.InstanceVars
	}
	pipelineInstanceVarsReturnsOnCall map[int]struct {
		result1 atc.InstanceVars
	}
	PipelineNameStub        func() string
	pipelineNameMutex       sync.RWMutex
	pipelineNameArgsForCall []struct {
	}
	pipelineNameReturns struct {
		result1 string
	}
	pipelineNameReturnsOnCall map[int]struct {
		result1 string
	}
	PipelineRefStub        func() atc.PipelineRef
	pipelineRefMutex       sync.RWMutex
	pipelineRefArgsForCall []struct {
	}
	pipelineRefReturns struct {
		result1 atc.PipelineRef
	}
	pipelineRefReturnsOnCall map[int]struct {
		result1 atc.PipelineRef
	}
	PublicStub        func() bool
	publicMutex       sync.RWMutex
	publicArgsForCall []struct {
	}
	publicReturns struct {
		result1 bool
	}
	publicReturnsOnCall map[int]struct {
		result1 bool
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
	}
	reloadReturns struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ResourceConfigIDStub        func() int
	resourceConfigIDMutex       sync.RWMutex
	resourceConfigIDArgsForCall []struct {
	}
	resourceConfigIDReturns struct {
		result1 int
	}
	resourceConfigIDReturnsOnCall map[int]struct {
		result1 int
	}
	ResourceConfigScopeIDStub        func() int
	resourceConfigScopeIDMutex       sync.RWMutex
	resourceConfigScopeIDArgsForCall []struct {
	}
	resourceConfigScopeIDReturns struct {
		result1 int
	}
	resourceConfigScopeIDReturnsOnCall map[int]struct {
		result1 int
	}
	SetPinCommentStub        func(string) error
	setPinCommentMutex       sync.RWMutex
	setPinCommentArgsForCall []struct {
		arg1 string
	}
	setPinCommentReturns struct {
		result1 error
	}
	setPinCommentReturnsOnCall map[int]struct {
		result1 error
	}
	SetResourceConfigScopeStub        func(db.ResourceConfigScope) error
	setResourceConfigScopeMutex       sync.RWMutex
	setResourceConfigScopeArgsForCall []struct {
		arg1 db.ResourceConfigScope
	}
	setResourceConfigScopeReturns struct {
		result1 error
	}
	setResourceConfigScopeReturnsOnCall map[int]struct {
		result1 error
	}
	SourceStub        func() atc.Source
	sourceMutex       sync.RWMutex
	sourceArgsForCall []struct {
	}
	sourceReturns struct {
		result1 atc.Source
	}
	sourceReturnsOnCall map[int]struct {
		result1 atc.Source
	}
	TagsStub        func() atc.Tags
	tagsMutex       sync.RWMutex
	tagsArgsForCall []struct {
	}
	tagsReturns struct {
		result1 atc.Tags
	}
	tagsReturnsOnCall map[int]struct {
		result1 atc.Tags
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	TimeToCheckStub        func() bool
	timeToCheckMutex       sync.RWMutex
	timeToCheckArgsForCall []struct {
	}
	timeToCheckReturns struct {
		result1 bool
	}
	timeToCheckReturnsOnCall map[int]struct {
		result1 bool
	}
	TypeStub        func() string
	typeMutex       sync.RWMutex
	typeArgsForCall []struct {
	}
	typeReturns struct {
		result1 string
	}
	typeReturnsOnCall map[int]struct {
		result1 string
	}
	UnpinVersionStub        func() error
	unpinVersionMutex       sync.RWMutex
	unpinVersionArgsForCall []struct {
	}
	unpinVersionReturns struct {
		result1 error
	}
	unpinVersionReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateMetadataStub        func(atc.Version, db.ResourceConfigMetadataFields) (bool, error)
	updateMetadataMutex       sync.RWMutex
	updateMetadataArgsForCall []struct {
		arg1 atc.Version
		arg2 db.ResourceConfigMetadataFields
	}
	updateMetadataReturns struct {
		result1 bool
		result2 error
	}
	updateMetadataReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	VersionsStub        func(db.Page, atc.Version) ([]atc.ResourceVersion, db.Pagination, bool, error)
	versionsMutex       sync.RWMutex
	versionsArgsForCall []struct {
		arg1 db.Page
		arg2 atc.Version
	}
	versionsReturns struct {
		result1 []atc.ResourceVersion
		result2 db.Pagination
		result3 bool
		result4 error
	}
	versionsReturnsOnCall map[int]struct {
		result1 []atc.ResourceVersion
		result2 db.Pagination
		result3 bool
		result4 error
	}
	WebhookTokenStub        func() string
	webhookTokenMutex       sync.RWMutex
	webhookTokenArgsForCall []struct {
	}
	webhookTokenReturns struct {
		result1 string
	}
	webhookTokenReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResource) APIPinnedVersion() atc.Version {
	fake.aPIPinnedVersionMutex.Lock()
	ret, specificReturn := fake.aPIPinnedVersionReturnsOnCall[len(fake.aPIPinnedVersionArgsForCall)]
	fake.aPIPinnedVersionArgsForCall = append(fake.aPIPinnedVersionArgsForCall, struct {
	}{})
	stub := fake.APIPinnedVersionStub
	fakeReturns := fake.aPIPinnedVersionReturns
	fake.recordInvocation("APIPinnedVersion", []interface{}{})
	fake.aPIPinnedVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) APIPinnedVersionCallCount() int {
	fake.aPIPinnedVersionMutex.RLock()
	defer fake.aPIPinnedVersionMutex.RUnlock()
	return len(fake.aPIPinnedVersionArgsForCall)
}

func (fake *FakeResource) APIPinnedVersionCalls(stub func() atc.Version) {
	fake.aPIPinnedVersionMutex.Lock()
	defer fake.aPIPinnedVersionMutex.Unlock()
	fake.APIPinnedVersionStub = stub
}

func (fake *FakeResource) APIPinnedVersionReturns(result1 atc.Version) {
	fake.aPIPinnedVersionMutex.Lock()
	defer fake.aPIPinnedVersionMutex.Unlock()
	fake.APIPinnedVersionStub = nil
	fake.aPIPinnedVersionReturns = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeResource) APIPinnedVersionReturnsOnCall(i int, result1 atc.Version) {
	fake.aPIPinnedVersionMutex.Lock()
	defer fake.aPIPinnedVersionMutex.Unlock()
	fake.APIPinnedVersionStub = nil
	if fake.aPIPinnedVersionReturnsOnCall == nil {
		fake.aPIPinnedVersionReturnsOnCall = make(map[int]struct {
			result1 atc.Version
		})
	}
	fake.aPIPinnedVersionReturnsOnCall[i] = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeResource) BuildSummary() *atc.BuildSummary {
	fake.buildSummaryMutex.Lock()
	ret, specificReturn := fake.buildSummaryReturnsOnCall[len(fake.buildSummaryArgsForCall)]
	fake.buildSummaryArgsForCall = append(fake.buildSummaryArgsForCall, struct {
	}{})
	stub := fake.BuildSummaryStub
	fakeReturns := fake.buildSummaryReturns
	fake.recordInvocation("BuildSummary", []interface{}{})
	fake.buildSummaryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) BuildSummaryCallCount() int {
	fake.buildSummaryMutex.RLock()
	defer fake.buildSummaryMutex.RUnlock()
	return len(fake.buildSummaryArgsForCall)
}

func (fake *FakeResource) BuildSummaryCalls(stub func() *atc.BuildSummary) {
	fake.buildSummaryMutex.Lock()
	defer fake.buildSummaryMutex.Unlock()
	fake.BuildSummaryStub = stub
}

func (fake *FakeResource) BuildSummaryReturns(result1 *atc.BuildSummary) {
	fake.buildSummaryMutex.Lock()
	defer fake.buildSummaryMutex.Unlock()
	fake.BuildSummaryStub = nil
	fake.buildSummaryReturns = struct {
		result1 *atc.BuildSummary
	}{result1}
}

func (fake *FakeResource) BuildSummaryReturnsOnCall(i int, result1 *atc.BuildSummary) {
	fake.buildSummaryMutex.Lock()
	defer fake.buildSummaryMutex.Unlock()
	fake.BuildSummaryStub = nil
	if fake.buildSummaryReturnsOnCall == nil {
		fake.buildSummaryReturnsOnCall = make(map[int]struct {
			result1 *atc.BuildSummary
		})
	}
	fake.buildSummaryReturnsOnCall[i] = struct {
		result1 *atc.BuildSummary
	}{result1}
}

func (fake *FakeResource) Causality(arg1 int, arg2 db.CausalityDirection) (atc.Causality, bool, error) {
	fake.causalityMutex.Lock()
	ret, specificReturn := fake.causalityReturnsOnCall[len(fake.causalityArgsForCall)]
	fake.causalityArgsForCall = append(fake.causalityArgsForCall, struct {
		arg1 int
		arg2 db.CausalityDirection
	}{arg1, arg2})
	stub := fake.CausalityStub
	fakeReturns := fake.causalityReturns
	fake.recordInvocation("Causality", []interface{}{arg1, arg2})
	fake.causalityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResource) CausalityCallCount() int {
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	return len(fake.causalityArgsForCall)
}

func (fake *FakeResource) CausalityCalls(stub func(int, db.CausalityDirection) (atc.Causality, bool, error)) {
	fake.causalityMutex.Lock()
	defer fake.causalityMutex.Unlock()
	fake.CausalityStub = stub
}

func (fake *FakeResource) CausalityArgsForCall(i int) (int, db.CausalityDirection) {
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	argsForCall := fake.causalityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResource) CausalityReturns(result1 atc.Causality, result2 bool, result3 error) {
	fake.causalityMutex.Lock()
	defer fake.causalityMutex.Unlock()
	fake.CausalityStub = nil
	fake.causalityReturns = struct {
		result1 atc.Causality
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResource) CausalityReturnsOnCall(i int, result1 atc.Causality, result2 bool, result3 error) {
	fake.causalityMutex.Lock()
	defer fake.causalityMutex.Unlock()
	fake.CausalityStub = nil
	if fake.causalityReturnsOnCall == nil {
		fake.causalityReturnsOnCall = make(map[int]struct {
			result1 atc.Causality
			result2 bool
			result3 error
		})
	}
	fake.causalityReturnsOnCall[i] = struct {
		result1 atc.Causality
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResource) CheckEvery() *atc.CheckEvery {
	fake.checkEveryMutex.Lock()
	ret, specificReturn := fake.checkEveryReturnsOnCall[len(fake.checkEveryArgsForCall)]
	fake.checkEveryArgsForCall = append(fake.checkEveryArgsForCall, struct {
	}{})
	stub := fake.CheckEveryStub
	fakeReturns := fake.checkEveryReturns
	fake.recordInvocation("CheckEvery", []interface{}{})
	fake.checkEveryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) CheckEveryCallCount() int {
	fake.checkEveryMutex.RLock()
	defer fake.checkEveryMutex.RUnlock()
	return len(fake.checkEveryArgsForCall)
}

func (fake *FakeResource) CheckEveryCalls(stub func() *atc.CheckEvery) {
	fake.checkEveryMutex.Lock()
	defer fake.checkEveryMutex.Unlock()
	fake.CheckEveryStub = stub
}

func (fake *FakeResource) CheckEveryReturns(result1 *atc.CheckEvery) {
	fake.checkEveryMutex.Lock()
	defer fake.checkEveryMutex.Unlock()
	fake.CheckEveryStub = nil
	fake.checkEveryReturns = struct {
		result1 *atc.CheckEvery
	}{result1}
}

func (fake *FakeResource) CheckEveryReturnsOnCall(i int, result1 *atc.CheckEvery) {
	fake.checkEveryMutex.Lock()
	defer fake.checkEveryMutex.Unlock()
	fake.CheckEveryStub = nil
	if fake.checkEveryReturnsOnCall == nil {
		fake.checkEveryReturnsOnCall = make(map[int]struct {
			result1 *atc.CheckEvery
		})
	}
	fake.checkEveryReturnsOnCall[i] = struct {
		result1 *atc.CheckEvery
	}{result1}
}

func (fake *FakeResource) CheckPlan(arg1 atc.PlanFactory, arg2 atc.ImagePlanner, arg3 atc.Version, arg4 atc.CheckEvery, arg5 atc.Source, arg6 bool, arg7 bool) atc.Plan {
	fake.checkPlanMutex.Lock()
	ret, specificReturn := fake.checkPlanReturnsOnCall[len(fake.checkPlanArgsForCall)]
	fake.checkPlanArgsForCall = append(fake.checkPlanArgsForCall, struct {
		arg1 atc.PlanFactory
		arg2 atc.ImagePlanner
		arg3 atc.Version
		arg4 atc.CheckEvery
		arg5 atc.Source
		arg6 bool
		arg7 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.CheckPlanStub
	fakeReturns := fake.checkPlanReturns
	fake.recordInvocation("CheckPlan", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.checkPlanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) CheckPlanCallCount() int {
	fake.checkPlanMutex.RLock()
	defer fake.checkPlanMutex.RUnlock()
	return len(fake.checkPlanArgsForCall)
}

func (fake *FakeResource) CheckPlanCalls(stub func(atc.PlanFactory, atc.ImagePlanner, atc.Version, atc.CheckEvery, atc.Source, bool, bool) atc.Plan) {
	fake.checkPlanMutex.Lock()
	defer fake.checkPlanMutex.Unlock()
	fake.CheckPlanStub = stub
}

func (fake *FakeResource) CheckPlanArgsForCall(i int) (atc.PlanFactory, atc.ImagePlanner, atc.Version, atc.CheckEvery, atc.Source, bool, bool) {
	fake.checkPlanMutex.RLock()
	defer fake.checkPlanMutex.RUnlock()
	argsForCall := fake.checkPlanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeResource) CheckPlanReturns(result1 atc.Plan) {
	fake.checkPlanMutex.Lock()
	defer fake.checkPlanMutex.Unlock()
	fake.CheckPlanStub = nil
	fake.checkPlanReturns = struct {
		result1 atc.Plan
	}{result1}
}

func (fake *FakeResource) CheckPlanReturnsOnCall(i int, result1 atc.Plan) {
	fake.checkPlanMutex.Lock()
	defer fake.checkPlanMutex.Unlock()
	fake.CheckPlanStub = nil
	if fake.checkPlanReturnsOnCall == nil {
		fake.checkPlanReturnsOnCall = make(map[int]struct {
			result1 atc.Plan
		})
	}
	fake.checkPlanReturnsOnCall[i] = struct {
		result1 atc.Plan
	}{result1}
}

func (fake *FakeResource) CheckTimeout() string {
	fake.checkTimeoutMutex.Lock()
	ret, specificReturn := fake.checkTimeoutReturnsOnCall[len(fake.checkTimeoutArgsForCall)]
	fake.checkTimeoutArgsForCall = append(fake.checkTimeoutArgsForCall, struct {
	}{})
	stub := fake.CheckTimeoutStub
	fakeReturns := fake.checkTimeoutReturns
	fake.recordInvocation("CheckTimeout", []interface{}{})
	fake.checkTimeoutMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) CheckTimeoutCallCount() int {
	fake.checkTimeoutMutex.RLock()
	defer fake.checkTimeoutMutex.RUnlock()
	return len(fake.checkTimeoutArgsForCall)
}

func (fake *FakeResource) CheckTimeoutCalls(stub func() string) {
	fake.checkTimeoutMutex.Lock()
	defer fake.checkTimeoutMutex.Unlock()
	fake.CheckTimeoutStub = stub
}

func (fake *FakeResource) CheckTimeoutReturns(result1 string) {
	fake.checkTimeoutMutex.Lock()
	defer fake.checkTimeoutMutex.Unlock()
	fake.CheckTimeoutStub = nil
	fake.checkTimeoutReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) CheckTimeoutReturnsOnCall(i int, result1 string) {
	fake.checkTimeoutMutex.Lock()
	defer fake.checkTimeoutMutex.Unlock()
	fake.CheckTimeoutStub = nil
	if fake.checkTimeoutReturnsOnCall == nil {
		fake.checkTimeoutReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.checkTimeoutReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) ClearResourceCache(arg1 atc.Version) (int64, error) {
	fake.clearResourceCacheMutex.Lock()
	ret, specificReturn := fake.clearResourceCacheReturnsOnCall[len(fake.clearResourceCacheArgsForCall)]
	fake.clearResourceCacheArgsForCall = append(fake.clearResourceCacheArgsForCall, struct {
		arg1 atc.Version
	}{arg1})
	stub := fake.ClearResourceCacheStub
	fakeReturns := fake.clearResourceCacheReturns
	fake.recordInvocation("ClearResourceCache", []interface{}{arg1})
	fake.clearResourceCacheMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResource) ClearResourceCacheCallCount() int {
	fake.clearResourceCacheMutex.RLock()
	defer fake.clearResourceCacheMutex.RUnlock()
	return len(fake.clearResourceCacheArgsForCall)
}

func (fake *FakeResource) ClearResourceCacheCalls(stub func(atc.Version) (int64, error)) {
	fake.clearResourceCacheMutex.Lock()
	defer fake.clearResourceCacheMutex.Unlock()
	fake.ClearResourceCacheStub = stub
}

func (fake *FakeResource) ClearResourceCacheArgsForCall(i int) atc.Version {
	fake.clearResourceCacheMutex.RLock()
	defer fake.clearResourceCacheMutex.RUnlock()
	argsForCall := fake.clearResourceCacheArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResource) ClearResourceCacheReturns(result1 int64, result2 error) {
	fake.clearResourceCacheMutex.Lock()
	defer fake.clearResourceCacheMutex.Unlock()
	fake.ClearResourceCacheStub = nil
	fake.clearResourceCacheReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) ClearResourceCacheReturnsOnCall(i int, result1 int64, result2 error) {
	fake.clearResourceCacheMutex.Lock()
	defer fake.clearResourceCacheMutex.Unlock()
	fake.ClearResourceCacheStub = nil
	if fake.clearResourceCacheReturnsOnCall == nil {
		fake.clearResourceCacheReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.clearResourceCacheReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) Config() atc.ResourceConfig {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct {
	}{})
	stub := fake.ConfigStub
	fakeReturns := fake.configReturns
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakeResource) ConfigCalls(stub func() atc.ResourceConfig) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = stub
}

func (fake *FakeResource) ConfigReturns(result1 atc.ResourceConfig) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 atc.ResourceConfig
	}{result1}
}

func (fake *FakeResource) ConfigReturnsOnCall(i int, result1 atc.ResourceConfig) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 atc.ResourceConfig
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 atc.ResourceConfig
	}{result1}
}

func (fake *FakeResource) ConfigPinnedVersion() atc.Version {
	fake.configPinnedVersionMutex.Lock()
	ret, specificReturn := fake.configPinnedVersionReturnsOnCall[len(fake.configPinnedVersionArgsForCall)]
	fake.configPinnedVersionArgsForCall = append(fake.configPinnedVersionArgsForCall, struct {
	}{})
	stub := fake.ConfigPinnedVersionStub
	fakeReturns := fake.configPinnedVersionReturns
	fake.recordInvocation("ConfigPinnedVersion", []interface{}{})
	fake.configPinnedVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) ConfigPinnedVersionCallCount() int {
	fake.configPinnedVersionMutex.RLock()
	defer fake.configPinnedVersionMutex.RUnlock()
	return len(fake.configPinnedVersionArgsForCall)
}

func (fake *FakeResource) ConfigPinnedVersionCalls(stub func() atc.Version) {
	fake.configPinnedVersionMutex.Lock()
	defer fake.configPinnedVersionMutex.Unlock()
	fake.ConfigPinnedVersionStub = stub
}

func (fake *FakeResource) ConfigPinnedVersionReturns(result1 atc.Version) {
	fake.configPinnedVersionMutex.Lock()
	defer fake.configPinnedVersionMutex.Unlock()
	fake.ConfigPinnedVersionStub = nil
	fake.configPinnedVersionReturns = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeResource) ConfigPinnedVersionReturnsOnCall(i int, result1 atc.Version) {
	fake.configPinnedVersionMutex.Lock()
	defer fake.configPinnedVersionMutex.Unlock()
	fake.ConfigPinnedVersionStub = nil
	if fake.configPinnedVersionReturnsOnCall == nil {
		fake.configPinnedVersionReturnsOnCall = make(map[int]struct {
			result1 atc.Version
		})
	}
	fake.configPinnedVersionReturnsOnCall[i] = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeResource) CreateBuild(arg1 context.Context, arg2 bool, arg3 atc.Plan) (db.Build, bool, error) {
	fake.createBuildMutex.Lock()
	ret, specificReturn := fake.createBuildReturnsOnCall[len(fake.createBuildArgsForCall)]
	fake.createBuildArgsForCall = append(fake.createBuildArgsForCall, struct {
		arg1 context.Context
		arg2 bool
		arg3 atc.Plan
	}{arg1, arg2, arg3})
	stub := fake.CreateBuildStub
	fakeReturns := fake.createBuildReturns
	fake.recordInvocation("CreateBuild", []interface{}{arg1, arg2, arg3})
	fake.createBuildMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResource) CreateBuildCallCount() int {
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	return len(fake.createBuildArgsForCall)
}

func (fake *FakeResource) CreateBuildCalls(stub func(context.Context, bool, atc.Plan) (db.Build, bool, error)) {
	fake.createBuildMutex.Lock()
	defer fake.createBuildMutex.Unlock()
	fake.CreateBuildStub = stub
}

func (fake *FakeResource) CreateBuildArgsForCall(i int) (context.Context, bool, atc.Plan) {
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	argsForCall := fake.createBuildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResource) CreateBuildReturns(result1 db.Build, result2 bool, result3 error) {
	fake.createBuildMutex.Lock()
	defer fake.createBuildMutex.Unlock()
	fake.CreateBuildStub = nil
	fake.createBuildReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResource) CreateBuildReturnsOnCall(i int, result1 db.Build, result2 bool, result3 error) {
	fake.createBuildMutex.Lock()
	defer fake.createBuildMutex.Unlock()
	fake.CreateBuildStub = nil
	if fake.createBuildReturnsOnCall == nil {
		fake.createBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 bool
			result3 error
		})
	}
	fake.createBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResource) CreateInMemoryBuild(arg1 context.Context, arg2 atc.Plan, arg3 util.SequenceGenerator) (db.Build, error) {
	fake.createInMemoryBuildMutex.Lock()
	ret, specificReturn := fake.createInMemoryBuildReturnsOnCall[len(fake.createInMemoryBuildArgsForCall)]
	fake.createInMemoryBuildArgsForCall = append(fake.createInMemoryBuildArgsForCall, struct {
		arg1 context.Context
		arg2 atc.Plan
		arg3 util.SequenceGenerator
	}{arg1, arg2, arg3})
	stub := fake.CreateInMemoryBuildStub
	fakeReturns := fake.createInMemoryBuildReturns
	fake.recordInvocation("CreateInMemoryBuild", []interface{}{arg1, arg2, arg3})
	fake.createInMemoryBuildMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResource) CreateInMemoryBuildCallCount() int {
	fake.createInMemoryBuildMutex.RLock()
	defer fake.createInMemoryBuildMutex.RUnlock()
	return len(fake.createInMemoryBuildArgsForCall)
}

func (fake *FakeResource) CreateInMemoryBuildCalls(stub func(context.Context, atc.Plan, util.SequenceGenerator) (db.Build, error)) {
	fake.createInMemoryBuildMutex.Lock()
	defer fake.createInMemoryBuildMutex.Unlock()
	fake.CreateInMemoryBuildStub = stub
}

func (fake *FakeResource) CreateInMemoryBuildArgsForCall(i int) (context.Context, atc.Plan, util.SequenceGenerator) {
	fake.createInMemoryBuildMutex.RLock()
	defer fake.createInMemoryBuildMutex.RUnlock()
	argsForCall := fake.createInMemoryBuildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResource) CreateInMemoryBuildReturns(result1 db.Build, result2 error) {
	fake.createInMemoryBuildMutex.Lock()
	defer fake.createInMemoryBuildMutex.Unlock()
	fake.CreateInMemoryBuildStub = nil
	fake.createInMemoryBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) CreateInMemoryBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.createInMemoryBuildMutex.Lock()
	defer fake.createInMemoryBuildMutex.Unlock()
	fake.CreateInMemoryBuildStub = nil
	if fake.createInMemoryBuildReturnsOnCall == nil {
		fake.createInMemoryBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createInMemoryBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) CurrentPinnedVersion() atc.Version {
	fake.currentPinnedVersionMutex.Lock()
	ret, specificReturn := fake.currentPinnedVersionReturnsOnCall[len(fake.currentPinnedVersionArgsForCall)]
	fake.currentPinnedVersionArgsForCall = append(fake.currentPinnedVersionArgsForCall, struct {
	}{})
	stub := fake.CurrentPinnedVersionStub
	fakeReturns := fake.currentPinnedVersionReturns
	fake.recordInvocation("CurrentPinnedVersion", []interface{}{})
	fake.currentPinnedVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) CurrentPinnedVersionCallCount() int {
	fake.currentPinnedVersionMutex.RLock()
	defer fake.currentPinnedVersionMutex.RUnlock()
	return len(fake.currentPinnedVersionArgsForCall)
}

func (fake *FakeResource) CurrentPinnedVersionCalls(stub func() atc.Version) {
	fake.currentPinnedVersionMutex.Lock()
	defer fake.currentPinnedVersionMutex.Unlock()
	fake.CurrentPinnedVersionStub = stub
}

func (fake *FakeResource) CurrentPinnedVersionReturns(result1 atc.Version) {
	fake.currentPinnedVersionMutex.Lock()
	defer fake.currentPinnedVersionMutex.Unlock()
	fake.CurrentPinnedVersionStub = nil
	fake.currentPinnedVersionReturns = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeResource) CurrentPinnedVersionReturnsOnCall(i int, result1 atc.Version) {
	fake.currentPinnedVersionMutex.Lock()
	defer fake.currentPinnedVersionMutex.Unlock()
	fake.CurrentPinnedVersionStub = nil
	if fake.currentPinnedVersionReturnsOnCall == nil {
		fake.currentPinnedVersionReturnsOnCall = make(map[int]struct {
			result1 atc.Version
		})
	}
	fake.currentPinnedVersionReturnsOnCall[i] = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeResource) DisableVersion(arg1 int) error {
	fake.disableVersionMutex.Lock()
	ret, specificReturn := fake.disableVersionReturnsOnCall[len(fake.disableVersionArgsForCall)]
	fake.disableVersionArgsForCall = append(fake.disableVersionArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.DisableVersionStub
	fakeReturns := fake.disableVersionReturns
	fake.recordInvocation("DisableVersion", []interface{}{arg1})
	fake.disableVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) DisableVersionCallCount() int {
	fake.disableVersionMutex.RLock()
	defer fake.disableVersionMutex.RUnlock()
	return len(fake.disableVersionArgsForCall)
}

func (fake *FakeResource) DisableVersionCalls(stub func(int) error) {
	fake.disableVersionMutex.Lock()
	defer fake.disableVersionMutex.Unlock()
	fake.DisableVersionStub = stub
}

func (fake *FakeResource) DisableVersionArgsForCall(i int) int {
	fake.disableVersionMutex.RLock()
	defer fake.disableVersionMutex.RUnlock()
	argsForCall := fake.disableVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResource) DisableVersionReturns(result1 error) {
	fake.disableVersionMutex.Lock()
	defer fake.disableVersionMutex.Unlock()
	fake.DisableVersionStub = nil
	fake.disableVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) DisableVersionReturnsOnCall(i int, result1 error) {
	fake.disableVersionMutex.Lock()
	defer fake.disableVersionMutex.Unlock()
	fake.DisableVersionStub = nil
	if fake.disableVersionReturnsOnCall == nil {
		fake.disableVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disableVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) EnableVersion(arg1 int) error {
	fake.enableVersionMutex.Lock()
	ret, specificReturn := fake.enableVersionReturnsOnCall[len(fake.enableVersionArgsForCall)]
	fake.enableVersionArgsForCall = append(fake.enableVersionArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.EnableVersionStub
	fakeReturns := fake.enableVersionReturns
	fake.recordInvocation("EnableVersion", []interface{}{arg1})
	fake.enableVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) EnableVersionCallCount() int {
	fake.enableVersionMutex.RLock()
	defer fake.enableVersionMutex.RUnlock()
	return len(fake.enableVersionArgsForCall)
}

func (fake *FakeResource) EnableVersionCalls(stub func(int) error) {
	fake.enableVersionMutex.Lock()
	defer fake.enableVersionMutex.Unlock()
	fake.EnableVersionStub = stub
}

func (fake *FakeResource) EnableVersionArgsForCall(i int) int {
	fake.enableVersionMutex.RLock()
	defer fake.enableVersionMutex.RUnlock()
	argsForCall := fake.enableVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResource) EnableVersionReturns(result1 error) {
	fake.enableVersionMutex.Lock()
	defer fake.enableVersionMutex.Unlock()
	fake.EnableVersionStub = nil
	fake.enableVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) EnableVersionReturnsOnCall(i int, result1 error) {
	fake.enableVersionMutex.Lock()
	defer fake.enableVersionMutex.Unlock()
	fake.EnableVersionStub = nil
	if fake.enableVersionReturnsOnCall == nil {
		fake.enableVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) FindVersion(arg1 atc.Version) (db.ResourceConfigVersion, bool, error) {
	fake.findVersionMutex.Lock()
	ret, specificReturn := fake.findVersionReturnsOnCall[len(fake.findVersionArgsForCall)]
	fake.findVersionArgsForCall = append(fake.findVersionArgsForCall, struct {
		arg1 atc.Version
	}{arg1})
	stub := fake.FindVersionStub
	fakeReturns := fake.findVersionReturns
	fake.recordInvocation("FindVersion", []interface{}{arg1})
	fake.findVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResource) FindVersionCallCount() int {
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	return len(fake.findVersionArgsForCall)
}

func (fake *FakeResource) FindVersionCalls(stub func(atc.Version) (db.ResourceConfigVersion, bool, error)) {
	fake.findVersionMutex.Lock()
	defer fake.findVersionMutex.Unlock()
	fake.FindVersionStub = stub
}

func (fake *FakeResource) FindVersionArgsForCall(i int) atc.Version {
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	argsForCall := fake.findVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResource) FindVersionReturns(result1 db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.findVersionMutex.Lock()
	defer fake.findVersionMutex.Unlock()
	fake.FindVersionStub = nil
	fake.findVersionReturns = struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResource) FindVersionReturnsOnCall(i int, result1 db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.findVersionMutex.Lock()
	defer fake.findVersionMutex.Unlock()
	fake.FindVersionStub = nil
	if fake.findVersionReturnsOnCall == nil {
		fake.findVersionReturnsOnCall = make(map[int]struct {
			result1 db.ResourceConfigVersion
			result2 bool
			result3 error
		})
	}
	fake.findVersionReturnsOnCall[i] = struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResource) HasWebhook() bool {
	fake.hasWebhookMutex.Lock()
	ret, specificReturn := fake.hasWebhookReturnsOnCall[len(fake.hasWebhookArgsForCall)]
	fake.hasWebhookArgsForCall = append(fake.hasWebhookArgsForCall, struct {
	}{})
	stub := fake.HasWebhookStub
	fakeReturns := fake.hasWebhookReturns
	fake.recordInvocation("HasWebhook", []interface{}{})
	fake.hasWebhookMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) HasWebhookCallCount() int {
	fake.hasWebhookMutex.RLock()
	defer fake.hasWebhookMutex.RUnlock()
	return len(fake.hasWebhookArgsForCall)
}

func (fake *FakeResource) HasWebhookCalls(stub func() bool) {
	fake.hasWebhookMutex.Lock()
	defer fake.hasWebhookMutex.Unlock()
	fake.HasWebhookStub = stub
}

func (fake *FakeResource) HasWebhookReturns(result1 bool) {
	fake.hasWebhookMutex.Lock()
	defer fake.hasWebhookMutex.Unlock()
	fake.HasWebhookStub = nil
	fake.hasWebhookReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResource) HasWebhookReturnsOnCall(i int, result1 bool) {
	fake.hasWebhookMutex.Lock()
	defer fake.hasWebhookMutex.Unlock()
	fake.HasWebhookStub = nil
	if fake.hasWebhookReturnsOnCall == nil {
		fake.hasWebhookReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasWebhookReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResource) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeResource) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeResource) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) Icon() string {
	fake.iconMutex.Lock()
	ret, specificReturn := fake.iconReturnsOnCall[len(fake.iconArgsForCall)]
	fake.iconArgsForCall = append(fake.iconArgsForCall, struct {
	}{})
	stub := fake.IconStub
	fakeReturns := fake.iconReturns
	fake.recordInvocation("Icon", []interface{}{})
	fake.iconMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) IconCallCount() int {
	fake.iconMutex.RLock()
	defer fake.iconMutex.RUnlock()
	return len(fake.iconArgsForCall)
}

func (fake *FakeResource) IconCalls(stub func() string) {
	fake.iconMutex.Lock()
	defer fake.iconMutex.Unlock()
	fake.IconStub = stub
}

func (fake *FakeResource) IconReturns(result1 string) {
	fake.iconMutex.Lock()
	defer fake.iconMutex.Unlock()
	fake.IconStub = nil
	fake.iconReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) IconReturnsOnCall(i int, result1 string) {
	fake.iconMutex.Lock()
	defer fake.iconMutex.Unlock()
	fake.IconStub = nil
	if fake.iconReturnsOnCall == nil {
		fake.iconReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iconReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) LastCheckEndTime() time.Time {
	fake.lastCheckEndTimeMutex.Lock()
	ret, specificReturn := fake.lastCheckEndTimeReturnsOnCall[len(fake.lastCheckEndTimeArgsForCall)]
	fake.lastCheckEndTimeArgsForCall = append(fake.lastCheckEndTimeArgsForCall, struct {
	}{})
	stub := fake.LastCheckEndTimeStub
	fakeReturns := fake.lastCheckEndTimeReturns
	fake.recordInvocation("LastCheckEndTime", []interface{}{})
	fake.lastCheckEndTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) LastCheckEndTimeCallCount() int {
	fake.lastCheckEndTimeMutex.RLock()
	defer fake.lastCheckEndTimeMutex.RUnlock()
	return len(fake.lastCheckEndTimeArgsForCall)
}

func (fake *FakeResource) LastCheckEndTimeCalls(stub func() time.Time) {
	fake.lastCheckEndTimeMutex.Lock()
	defer fake.lastCheckEndTimeMutex.Unlock()
	fake.LastCheckEndTimeStub = stub
}

func (fake *FakeResource) LastCheckEndTimeReturns(result1 time.Time) {
	fake.lastCheckEndTimeMutex.Lock()
	defer fake.lastCheckEndTimeMutex.Unlock()
	fake.LastCheckEndTimeStub = nil
	fake.lastCheckEndTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeResource) LastCheckEndTimeReturnsOnCall(i int, result1 time.Time) {
	fake.lastCheckEndTimeMutex.Lock()
	defer fake.lastCheckEndTimeMutex.Unlock()
	fake.LastCheckEndTimeStub = nil
	if fake.lastCheckEndTimeReturnsOnCall == nil {
		fake.lastCheckEndTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.lastCheckEndTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeResource) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeResource) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeResource) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) NotifyScan() error {
	fake.notifyScanMutex.Lock()
	ret, specificReturn := fake.notifyScanReturnsOnCall[len(fake.notifyScanArgsForCall)]
	fake.notifyScanArgsForCall = append(fake.notifyScanArgsForCall, struct {
	}{})
	stub := fake.NotifyScanStub
	fakeReturns := fake.notifyScanReturns
	fake.recordInvocation("NotifyScan", []interface{}{})
	fake.notifyScanMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) NotifyScanCallCount() int {
	fake.notifyScanMutex.RLock()
	defer fake.notifyScanMutex.RUnlock()
	return len(fake.notifyScanArgsForCall)
}

func (fake *FakeResource) NotifyScanCalls(stub func() error) {
	fake.notifyScanMutex.Lock()
	defer fake.notifyScanMutex.Unlock()
	fake.NotifyScanStub = stub
}

func (fake *FakeResource) NotifyScanReturns(result1 error) {
	fake.notifyScanMutex.Lock()
	defer fake.notifyScanMutex.Unlock()
	fake.NotifyScanStub = nil
	fake.notifyScanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) NotifyScanReturnsOnCall(i int, result1 error) {
	fake.notifyScanMutex.Lock()
	defer fake.notifyScanMutex.Unlock()
	fake.NotifyScanStub = nil
	if fake.notifyScanReturnsOnCall == nil {
		fake.notifyScanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.notifyScanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) PinComment() string {
	fake.pinCommentMutex.Lock()
	ret, specificReturn := fake.pinCommentReturnsOnCall[len(fake.pinCommentArgsForCall)]
	fake.pinCommentArgsForCall = append(fake.pinCommentArgsForCall, struct {
	}{})
	stub := fake.PinCommentStub
	fakeReturns := fake.pinCommentReturns
	fake.recordInvocation("PinComment", []interface{}{})
	fake.pinCommentMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) PinCommentCallCount() int {
	fake.pinCommentMutex.RLock()
	defer fake.pinCommentMutex.RUnlock()
	return len(fake.pinCommentArgsForCall)
}

func (fake *FakeResource) PinCommentCalls(stub func() string) {
	fake.pinCommentMutex.Lock()
	defer fake.pinCommentMutex.Unlock()
	fake.PinCommentStub = stub
}

func (fake *FakeResource) PinCommentReturns(result1 string) {
	fake.pinCommentMutex.Lock()
	defer fake.pinCommentMutex.Unlock()
	fake.PinCommentStub = nil
	fake.pinCommentReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) PinCommentReturnsOnCall(i int, result1 string) {
	fake.pinCommentMutex.Lock()
	defer fake.pinCommentMutex.Unlock()
	fake.PinCommentStub = nil
	if fake.pinCommentReturnsOnCall == nil {
		fake.pinCommentReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pinCommentReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) PinVersion(arg1 int) (bool, error) {
	fake.pinVersionMutex.Lock()
	ret, specificReturn := fake.pinVersionReturnsOnCall[len(fake.pinVersionArgsForCall)]
	fake.pinVersionArgsForCall = append(fake.pinVersionArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.PinVersionStub
	fakeReturns := fake.pinVersionReturns
	fake.recordInvocation("PinVersion", []interface{}{arg1})
	fake.pinVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResource) PinVersionCallCount() int {
	fake.pinVersionMutex.RLock()
	defer fake.pinVersionMutex.RUnlock()
	return len(fake.pinVersionArgsForCall)
}

func (fake *FakeResource) PinVersionCalls(stub func(int) (bool, error)) {
	fake.pinVersionMutex.Lock()
	defer fake.pinVersionMutex.Unlock()
	fake.PinVersionStub = stub
}

func (fake *FakeResource) PinVersionArgsForCall(i int) int {
	fake.pinVersionMutex.RLock()
	defer fake.pinVersionMutex.RUnlock()
	argsForCall := fake.pinVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResource) PinVersionReturns(result1 bool, result2 error) {
	fake.pinVersionMutex.Lock()
	defer fake.pinVersionMutex.Unlock()
	fake.PinVersionStub = nil
	fake.pinVersionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) PinVersionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.pinVersionMutex.Lock()
	defer fake.pinVersionMutex.Unlock()
	fake.PinVersionStub = nil
	if fake.pinVersionReturnsOnCall == nil {
		fake.pinVersionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pinVersionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) Pipeline() (db.Pipeline, bool, error) {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct {
	}{})
	stub := fake.PipelineStub
	fakeReturns := fake.pipelineReturns
	fake.recordInvocation("Pipeline", []interface{}{})
	fake.pipelineMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResource) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeResource) PipelineCalls(stub func() (db.Pipeline, bool, error)) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = stub
}

func (fake *FakeResource) PipelineReturns(result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResource) PipelineReturnsOnCall(i int, result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResource) PipelineID() int {
	fake.pipelineIDMutex.Lock()
	ret, specificReturn := fake.pipelineIDReturnsOnCall[len(fake.pipelineIDArgsForCall)]
	fake.pipelineIDArgsForCall = append(fake.pipelineIDArgsForCall, struct {
	}{})
	stub := fake.PipelineIDStub
	fakeReturns := fake.pipelineIDReturns
	fake.recordInvocation("PipelineID", []interface{}{})
	fake.pipelineIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) PipelineIDCallCount() int {
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	return len(fake.pipelineIDArgsForCall)
}

func (fake *FakeResource) PipelineIDCalls(stub func() int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = stub
}

func (fake *FakeResource) PipelineIDReturns(result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	fake.pipelineIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) PipelineIDReturnsOnCall(i int, result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	if fake.pipelineIDReturnsOnCall == nil {
		fake.pipelineIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.pipelineIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) PipelineInstanceVars() atc.InstanceVars {
	fake.pipelineInstanceVarsMutex.Lock()
	ret, specificReturn := fake.pipelineInstanceVarsReturnsOnCall[len(fake.pipelineInstanceVarsArgsForCall)]
	fake.pipelineInstanceVarsArgsForCall = append(fake.pipelineInstanceVarsArgsForCall, struct {
	}{})
	stub := fake.PipelineInstanceVarsStub
	fakeReturns := fake.pipelineInstanceVarsReturns
	fake.recordInvocation("PipelineInstanceVars", []interface{}{})
	fake.pipelineInstanceVarsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) PipelineInstanceVarsCallCount() int {
	fake.pipelineInstanceVarsMutex.RLock()
	defer fake.pipelineInstanceVarsMutex.RUnlock()
	return len(fake.pipelineInstanceVarsArgsForCall)
}

func (fake *FakeResource) PipelineInstanceVarsCalls(stub func() atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = stub
}

func (fake *FakeResource) PipelineInstanceVarsReturns(result1 atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = nil
	fake.pipelineInstanceVarsReturns = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakeResource) PipelineInstanceVarsReturnsOnCall(i int, result1 atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = nil
	if fake.pipelineInstanceVarsReturnsOnCall == nil {
		fake.pipelineInstanceVarsReturnsOnCall = make(map[int]struct {
			result1 atc.InstanceVars
		})
	}
	fake.pipelineInstanceVarsReturnsOnCall[i] = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakeResource) PipelineName() string {
	fake.pipelineNameMutex.Lock()
	ret, specificReturn := fake.pipelineNameReturnsOnCall[len(fake.pipelineNameArgsForCall)]
	fake.pipelineNameArgsForCall = append(fake.pipelineNameArgsForCall, struct {
	}{})
	stub := fake.PipelineNameStub
	fakeReturns := fake.pipelineNameReturns
	fake.recordInvocation("PipelineName", []interface{}{})
	fake.pipelineNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) PipelineNameCallCount() int {
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	return len(fake.pipelineNameArgsForCall)
}

func (fake *FakeResource) PipelineNameCalls(stub func() string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = stub
}

func (fake *FakeResource) PipelineNameReturns(result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	fake.pipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) PipelineNameReturnsOnCall(i int, result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	if fake.pipelineNameReturnsOnCall == nil {
		fake.pipelineNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pipelineNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) PipelineRef() atc.PipelineRef {
	fake.pipelineRefMutex.Lock()
	ret, specificReturn := fake.pipelineRefReturnsOnCall[len(fake.pipelineRefArgsForCall)]
	fake.pipelineRefArgsForCall = append(fake.pipelineRefArgsForCall, struct {
	}{})
	stub := fake.PipelineRefStub
	fakeReturns := fake.pipelineRefReturns
	fake.recordInvocation("PipelineRef", []interface{}{})
	fake.pipelineRefMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) PipelineRefCallCount() int {
	fake.pipelineRefMutex.RLock()
	defer fake.pipelineRefMutex.RUnlock()
	return len(fake.pipelineRefArgsForCall)
}

func (fake *FakeResource) PipelineRefCalls(stub func() atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = stub
}

func (fake *FakeResource) PipelineRefReturns(result1 atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = nil
	fake.pipelineRefReturns = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakeResource) PipelineRefReturnsOnCall(i int, result1 atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = nil
	if fake.pipelineRefReturnsOnCall == nil {
		fake.pipelineRefReturnsOnCall = make(map[int]struct {
			result1 atc.PipelineRef
		})
	}
	fake.pipelineRefReturnsOnCall[i] = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakeResource) Public() bool {
	fake.publicMutex.Lock()
	ret, specificReturn := fake.publicReturnsOnCall[len(fake.publicArgsForCall)]
	fake.publicArgsForCall = append(fake.publicArgsForCall, struct {
	}{})
	stub := fake.PublicStub
	fakeReturns := fake.publicReturns
	fake.recordInvocation("Public", []interface{}{})
	fake.publicMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) PublicCallCount() int {
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	return len(fake.publicArgsForCall)
}

func (fake *FakeResource) PublicCalls(stub func() bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = stub
}

func (fake *FakeResource) PublicReturns(result1 bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = nil
	fake.publicReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResource) PublicReturnsOnCall(i int, result1 bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = nil
	if fake.publicReturnsOnCall == nil {
		fake.publicReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.publicReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResource) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
	}{})
	stub := fake.ReloadStub
	fakeReturns := fake.reloadReturns
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResource) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakeResource) ReloadCalls(stub func() (bool, error)) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = stub
}

func (fake *FakeResource) ReloadReturns(result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) ResourceConfigID() int {
	fake.resourceConfigIDMutex.Lock()
	ret, specificReturn := fake.resourceConfigIDReturnsOnCall[len(fake.resourceConfigIDArgsForCall)]
	fake.resourceConfigIDArgsForCall = append(fake.resourceConfigIDArgsForCall, struct {
	}{})
	stub := fake.ResourceConfigIDStub
	fakeReturns := fake.resourceConfigIDReturns
	fake.recordInvocation("ResourceConfigID", []interface{}{})
	fake.resourceConfigIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) ResourceConfigIDCallCount() int {
	fake.resourceConfigIDMutex.RLock()
	defer fake.resourceConfigIDMutex.RUnlock()
	return len(fake.resourceConfigIDArgsForCall)
}

func (fake *FakeResource) ResourceConfigIDCalls(stub func() int) {
	fake.resourceConfigIDMutex.Lock()
	defer fake.resourceConfigIDMutex.Unlock()
	fake.ResourceConfigIDStub = stub
}

func (fake *FakeResource) ResourceConfigIDReturns(result1 int) {
	fake.resourceConfigIDMutex.Lock()
	defer fake.resourceConfigIDMutex.Unlock()
	fake.ResourceConfigIDStub = nil
	fake.resourceConfigIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) ResourceConfigIDReturnsOnCall(i int, result1 int) {
	fake.resourceConfigIDMutex.Lock()
	defer fake.resourceConfigIDMutex.Unlock()
	fake.ResourceConfigIDStub = nil
	if fake.resourceConfigIDReturnsOnCall == nil {
		fake.resourceConfigIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.resourceConfigIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) ResourceConfigScopeID() int {
	fake.resourceConfigScopeIDMutex.Lock()
	ret, specificReturn := fake.resourceConfigScopeIDReturnsOnCall[len(fake.resourceConfigScopeIDArgsForCall)]
	fake.resourceConfigScopeIDArgsForCall = append(fake.resourceConfigScopeIDArgsForCall, struct {
	}{})
	stub := fake.ResourceConfigScopeIDStub
	fakeReturns := fake.resourceConfigScopeIDReturns
	fake.recordInvocation("ResourceConfigScopeID", []interface{}{})
	fake.resourceConfigScopeIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) ResourceConfigScopeIDCallCount() int {
	fake.resourceConfigScopeIDMutex.RLock()
	defer fake.resourceConfigScopeIDMutex.RUnlock()
	return len(fake.resourceConfigScopeIDArgsForCall)
}

func (fake *FakeResource) ResourceConfigScopeIDCalls(stub func() int) {
	fake.resourceConfigScopeIDMutex.Lock()
	defer fake.resourceConfigScopeIDMutex.Unlock()
	fake.ResourceConfigScopeIDStub = stub
}

func (fake *FakeResource) ResourceConfigScopeIDReturns(result1 int) {
	fake.resourceConfigScopeIDMutex.Lock()
	defer fake.resourceConfigScopeIDMutex.Unlock()
	fake.ResourceConfigScopeIDStub = nil
	fake.resourceConfigScopeIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) ResourceConfigScopeIDReturnsOnCall(i int, result1 int) {
	fake.resourceConfigScopeIDMutex.Lock()
	defer fake.resourceConfigScopeIDMutex.Unlock()
	fake.ResourceConfigScopeIDStub = nil
	if fake.resourceConfigScopeIDReturnsOnCall == nil {
		fake.resourceConfigScopeIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.resourceConfigScopeIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) SetPinComment(arg1 string) error {
	fake.setPinCommentMutex.Lock()
	ret, specificReturn := fake.setPinCommentReturnsOnCall[len(fake.setPinCommentArgsForCall)]
	fake.setPinCommentArgsForCall = append(fake.setPinCommentArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetPinCommentStub
	fakeReturns := fake.setPinCommentReturns
	fake.recordInvocation("SetPinComment", []interface{}{arg1})
	fake.setPinCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) SetPinCommentCallCount() int {
	fake.setPinCommentMutex.RLock()
	defer fake.setPinCommentMutex.RUnlock()
	return len(fake.setPinCommentArgsForCall)
}

func (fake *FakeResource) SetPinCommentCalls(stub func(string) error) {
	fake.setPinCommentMutex.Lock()
	defer fake.setPinCommentMutex.Unlock()
	fake.SetPinCommentStub = stub
}

func (fake *FakeResource) SetPinCommentArgsForCall(i int) string {
	fake.setPinCommentMutex.RLock()
	defer fake.setPinCommentMutex.RUnlock()
	argsForCall := fake.setPinCommentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResource) SetPinCommentReturns(result1 error) {
	fake.setPinCommentMutex.Lock()
	defer fake.setPinCommentMutex.Unlock()
	fake.SetPinCommentStub = nil
	fake.setPinCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) SetPinCommentReturnsOnCall(i int, result1 error) {
	fake.setPinCommentMutex.Lock()
	defer fake.setPinCommentMutex.Unlock()
	fake.SetPinCommentStub = nil
	if fake.setPinCommentReturnsOnCall == nil {
		fake.setPinCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setPinCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) SetResourceConfigScope(arg1 db.ResourceConfigScope) error {
	fake.setResourceConfigScopeMutex.Lock()
	ret, specificReturn := fake.setResourceConfigScopeReturnsOnCall[len(fake.setResourceConfigScopeArgsForCall)]
	fake.setResourceConfigScopeArgsForCall = append(fake.setResourceConfigScopeArgsForCall, struct {
		arg1 db.ResourceConfigScope
	}{arg1})
	stub := fake.SetResourceConfigScopeStub
	fakeReturns := fake.setResourceConfigScopeReturns
	fake.recordInvocation("SetResourceConfigScope", []interface{}{arg1})
	fake.setResourceConfigScopeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) SetResourceConfigScopeCallCount() int {
	fake.setResourceConfigScopeMutex.RLock()
	defer fake.setResourceConfigScopeMutex.RUnlock()
	return len(fake.setResourceConfigScopeArgsForCall)
}

func (fake *FakeResource) SetResourceConfigScopeCalls(stub func(db.ResourceConfigScope) error) {
	fake.setResourceConfigScopeMutex.Lock()
	defer fake.setResourceConfigScopeMutex.Unlock()
	fake.SetResourceConfigScopeStub = stub
}

func (fake *FakeResource) SetResourceConfigScopeArgsForCall(i int) db.ResourceConfigScope {
	fake.setResourceConfigScopeMutex.RLock()
	defer fake.setResourceConfigScopeMutex.RUnlock()
	argsForCall := fake.setResourceConfigScopeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResource) SetResourceConfigScopeReturns(result1 error) {
	fake.setResourceConfigScopeMutex.Lock()
	defer fake.setResourceConfigScopeMutex.Unlock()
	fake.SetResourceConfigScopeStub = nil
	fake.setResourceConfigScopeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) SetResourceConfigScopeReturnsOnCall(i int, result1 error) {
	fake.setResourceConfigScopeMutex.Lock()
	defer fake.setResourceConfigScopeMutex.Unlock()
	fake.SetResourceConfigScopeStub = nil
	if fake.setResourceConfigScopeReturnsOnCall == nil {
		fake.setResourceConfigScopeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setResourceConfigScopeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) Source() atc.Source {
	fake.sourceMutex.Lock()
	ret, specificReturn := fake.sourceReturnsOnCall[len(fake.sourceArgsForCall)]
	fake.sourceArgsForCall = append(fake.sourceArgsForCall, struct {
	}{})
	stub := fake.SourceStub
	fakeReturns := fake.sourceReturns
	fake.recordInvocation("Source", []interface{}{})
	fake.sourceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) SourceCallCount() int {
	fake.sourceMutex.RLock()
	defer fake.sourceMutex.RUnlock()
	return len(fake.sourceArgsForCall)
}

func (fake *FakeResource) SourceCalls(stub func() atc.Source) {
	fake.sourceMutex.Lock()
	defer fake.sourceMutex.Unlock()
	fake.SourceStub = stub
}

func (fake *FakeResource) SourceReturns(result1 atc.Source) {
	fake.sourceMutex.Lock()
	defer fake.sourceMutex.Unlock()
	fake.SourceStub = nil
	fake.sourceReturns = struct {
		result1 atc.Source
	}{result1}
}

func (fake *FakeResource) SourceReturnsOnCall(i int, result1 atc.Source) {
	fake.sourceMutex.Lock()
	defer fake.sourceMutex.Unlock()
	fake.SourceStub = nil
	if fake.sourceReturnsOnCall == nil {
		fake.sourceReturnsOnCall = make(map[int]struct {
			result1 atc.Source
		})
	}
	fake.sourceReturnsOnCall[i] = struct {
		result1 atc.Source
	}{result1}
}

func (fake *FakeResource) Tags() atc.Tags {
	fake.tagsMutex.Lock()
	ret, specificReturn := fake.tagsReturnsOnCall[len(fake.tagsArgsForCall)]
	fake.tagsArgsForCall = append(fake.tagsArgsForCall, struct {
	}{})
	stub := fake.TagsStub
	fakeReturns := fake.tagsReturns
	fake.recordInvocation("Tags", []interface{}{})
	fake.tagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) TagsCallCount() int {
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	return len(fake.tagsArgsForCall)
}

func (fake *FakeResource) TagsCalls(stub func() atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = stub
}

func (fake *FakeResource) TagsReturns(result1 atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	fake.tagsReturns = struct {
		result1 atc.Tags
	}{result1}
}

func (fake *FakeResource) TagsReturnsOnCall(i int, result1 atc.Tags) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	if fake.tagsReturnsOnCall == nil {
		fake.tagsReturnsOnCall = make(map[int]struct {
			result1 atc.Tags
		})
	}
	fake.tagsReturnsOnCall[i] = struct {
		result1 atc.Tags
	}{result1}
}

func (fake *FakeResource) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	stub := fake.TeamIDStub
	fakeReturns := fake.teamIDReturns
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakeResource) TeamIDCalls(stub func() int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = stub
}

func (fake *FakeResource) TeamIDReturns(result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) TeamIDReturnsOnCall(i int, result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeResource) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	stub := fake.TeamNameStub
	fakeReturns := fake.teamNameReturns
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakeResource) TeamNameCalls(stub func() string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = stub
}

func (fake *FakeResource) TeamNameReturns(result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) TeamNameReturnsOnCall(i int, result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) TimeToCheck() bool {
	fake.timeToCheckMutex.Lock()
	ret, specificReturn := fake.timeToCheckReturnsOnCall[len(fake.timeToCheckArgsForCall)]
	fake.timeToCheckArgsForCall = append(fake.timeToCheckArgsForCall, struct {
	}{})
	stub := fake.TimeToCheckStub
	fakeReturns := fake.timeToCheckReturns
	fake.recordInvocation("TimeToCheck", []interface{}{})
	fake.timeToCheckMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) TimeToCheckCallCount() int {
	fake.timeToCheckMutex.RLock()
	defer fake.timeToCheckMutex.RUnlock()
	return len(fake.timeToCheckArgsForCall)
}

func (fake *FakeResource) TimeToCheckCalls(stub func() bool) {
	fake.timeToCheckMutex.Lock()
	defer fake.timeToCheckMutex.Unlock()
	fake.TimeToCheckStub = stub
}

func (fake *FakeResource) TimeToCheckReturns(result1 bool) {
	fake.timeToCheckMutex.Lock()
	defer fake.timeToCheckMutex.Unlock()
	fake.TimeToCheckStub = nil
	fake.timeToCheckReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResource) TimeToCheckReturnsOnCall(i int, result1 bool) {
	fake.timeToCheckMutex.Lock()
	defer fake.timeToCheckMutex.Unlock()
	fake.TimeToCheckStub = nil
	if fake.timeToCheckReturnsOnCall == nil {
		fake.timeToCheckReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.timeToCheckReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResource) Type() string {
	fake.typeMutex.Lock()
	ret, specificReturn := fake.typeReturnsOnCall[len(fake.typeArgsForCall)]
	fake.typeArgsForCall = append(fake.typeArgsForCall, struct {
	}{})
	stub := fake.TypeStub
	fakeReturns := fake.typeReturns
	fake.recordInvocation("Type", []interface{}{})
	fake.typeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) TypeCallCount() int {
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	return len(fake.typeArgsForCall)
}

func (fake *FakeResource) TypeCalls(stub func() string) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = stub
}

func (fake *FakeResource) TypeReturns(result1 string) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = nil
	fake.typeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) TypeReturnsOnCall(i int, result1 string) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = nil
	if fake.typeReturnsOnCall == nil {
		fake.typeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.typeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) UnpinVersion() error {
	fake.unpinVersionMutex.Lock()
	ret, specificReturn := fake.unpinVersionReturnsOnCall[len(fake.unpinVersionArgsForCall)]
	fake.unpinVersionArgsForCall = append(fake.unpinVersionArgsForCall, struct {
	}{})
	stub := fake.UnpinVersionStub
	fakeReturns := fake.unpinVersionReturns
	fake.recordInvocation("UnpinVersion", []interface{}{})
	fake.unpinVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) UnpinVersionCallCount() int {
	fake.unpinVersionMutex.RLock()
	defer fake.unpinVersionMutex.RUnlock()
	return len(fake.unpinVersionArgsForCall)
}

func (fake *FakeResource) UnpinVersionCalls(stub func() error) {
	fake.unpinVersionMutex.Lock()
	defer fake.unpinVersionMutex.Unlock()
	fake.UnpinVersionStub = stub
}

func (fake *FakeResource) UnpinVersionReturns(result1 error) {
	fake.unpinVersionMutex.Lock()
	defer fake.unpinVersionMutex.Unlock()
	fake.UnpinVersionStub = nil
	fake.unpinVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) UnpinVersionReturnsOnCall(i int, result1 error) {
	fake.unpinVersionMutex.Lock()
	defer fake.unpinVersionMutex.Unlock()
	fake.UnpinVersionStub = nil
	if fake.unpinVersionReturnsOnCall == nil {
		fake.unpinVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpinVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResource) UpdateMetadata(arg1 atc.Version, arg2 db.ResourceConfigMetadataFields) (bool, error) {
	fake.updateMetadataMutex.Lock()
	ret, specificReturn := fake.updateMetadataReturnsOnCall[len(fake.updateMetadataArgsForCall)]
	fake.updateMetadataArgsForCall = append(fake.updateMetadataArgsForCall, struct {
		arg1 atc.Version
		arg2 db.ResourceConfigMetadataFields
	}{arg1, arg2})
	stub := fake.UpdateMetadataStub
	fakeReturns := fake.updateMetadataReturns
	fake.recordInvocation("UpdateMetadata", []interface{}{arg1, arg2})
	fake.updateMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResource) UpdateMetadataCallCount() int {
	fake.updateMetadataMutex.RLock()
	defer fake.updateMetadataMutex.RUnlock()
	return len(fake.updateMetadataArgsForCall)
}

func (fake *FakeResource) UpdateMetadataCalls(stub func(atc.Version, db.ResourceConfigMetadataFields) (bool, error)) {
	fake.updateMetadataMutex.Lock()
	defer fake.updateMetadataMutex.Unlock()
	fake.UpdateMetadataStub = stub
}

func (fake *FakeResource) UpdateMetadataArgsForCall(i int) (atc.Version, db.ResourceConfigMetadataFields) {
	fake.updateMetadataMutex.RLock()
	defer fake.updateMetadataMutex.RUnlock()
	argsForCall := fake.updateMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResource) UpdateMetadataReturns(result1 bool, result2 error) {
	fake.updateMetadataMutex.Lock()
	defer fake.updateMetadataMutex.Unlock()
	fake.UpdateMetadataStub = nil
	fake.updateMetadataReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) UpdateMetadataReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateMetadataMutex.Lock()
	defer fake.updateMetadataMutex.Unlock()
	fake.UpdateMetadataStub = nil
	if fake.updateMetadataReturnsOnCall == nil {
		fake.updateMetadataReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateMetadataReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) Versions(arg1 db.Page, arg2 atc.Version) ([]atc.ResourceVersion, db.Pagination, bool, error) {
	fake.versionsMutex.Lock()
	ret, specificReturn := fake.versionsReturnsOnCall[len(fake.versionsArgsForCall)]
	fake.versionsArgsForCall = append(fake.versionsArgsForCall, struct {
		arg1 db.Page
		arg2 atc.Version
	}{arg1, arg2})
	stub := fake.VersionsStub
	fakeReturns := fake.versionsReturns
	fake.recordInvocation("Versions", []interface{}{arg1, arg2})
	fake.versionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeResource) VersionsCallCount() int {
	fake.versionsMutex.RLock()
	defer fake.versionsMutex.RUnlock()
	return len(fake.versionsArgsForCall)
}

func (fake *FakeResource) VersionsCalls(stub func(db.Page, atc.Version) ([]atc.ResourceVersion, db.Pagination, bool, error)) {
	fake.versionsMutex.Lock()
	defer fake.versionsMutex.Unlock()
	fake.VersionsStub = stub
}

func (fake *FakeResource) VersionsArgsForCall(i int) (db.Page, atc.Version) {
	fake.versionsMutex.RLock()
	defer fake.versionsMutex.RUnlock()
	argsForCall := fake.versionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResource) VersionsReturns(result1 []atc.ResourceVersion, result2 db.Pagination, result3 bool, result4 error) {
	fake.versionsMutex.Lock()
	defer fake.versionsMutex.Unlock()
	fake.VersionsStub = nil
	fake.versionsReturns = struct {
		result1 []atc.ResourceVersion
		result2 db.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResource) VersionsReturnsOnCall(i int, result1 []atc.ResourceVersion, result2 db.Pagination, result3 bool, result4 error) {
	fake.versionsMutex.Lock()
	defer fake.versionsMutex.Unlock()
	fake.VersionsStub = nil
	if fake.versionsReturnsOnCall == nil {
		fake.versionsReturnsOnCall = make(map[int]struct {
			result1 []atc.ResourceVersion
			result2 db.Pagination
			result3 bool
			result4 error
		})
	}
	fake.versionsReturnsOnCall[i] = struct {
		result1 []atc.ResourceVersion
		result2 db.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResource) WebhookToken() string {
	fake.webhookTokenMutex.Lock()
	ret, specificReturn := fake.webhookTokenReturnsOnCall[len(fake.webhookTokenArgsForCall)]
	fake.webhookTokenArgsForCall = append(fake.webhookTokenArgsForCall, struct {
	}{})
	stub := fake.WebhookTokenStub
	fakeReturns := fake.webhookTokenReturns
	fake.recordInvocation("WebhookToken", []interface{}{})
	fake.webhookTokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResource) WebhookTokenCallCount() int {
	fake.webhookTokenMutex.RLock()
	defer fake.webhookTokenMutex.RUnlock()
	return len(fake.webhookTokenArgsForCall)
}

func (fake *FakeResource) WebhookTokenCalls(stub func() string) {
	fake.webhookTokenMutex.Lock()
	defer fake.webhookTokenMutex.Unlock()
	fake.WebhookTokenStub = stub
}

func (fake *FakeResource) WebhookTokenReturns(result1 string) {
	fake.webhookTokenMutex.Lock()
	defer fake.webhookTokenMutex.Unlock()
	fake.WebhookTokenStub = nil
	fake.webhookTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) WebhookTokenReturnsOnCall(i int, result1 string) {
	fake.webhookTokenMutex.Lock()
	defer fake.webhookTokenMutex.Unlock()
	fake.WebhookTokenStub = nil
	if fake.webhookTokenReturnsOnCall == nil {
		fake.webhookTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.webhookTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeResource) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aPIPinnedVersionMutex.RLock()
	defer fake.aPIPinnedVersionMutex.RUnlock()
	fake.buildSummaryMutex.RLock()
	defer fake.buildSummaryMutex.RUnlock()
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	fake.checkEveryMutex.RLock()
	defer fake.checkEveryMutex.RUnlock()
	fake.checkPlanMutex.RLock()
	defer fake.checkPlanMutex.RUnlock()
	fake.checkTimeoutMutex.RLock()
	defer fake.checkTimeoutMutex.RUnlock()
	fake.clearResourceCacheMutex.RLock()
	defer fake.clearResourceCacheMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.configPinnedVersionMutex.RLock()
	defer fake.configPinnedVersionMutex.RUnlock()
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	fake.createInMemoryBuildMutex.RLock()
	defer fake.createInMemoryBuildMutex.RUnlock()
	fake.currentPinnedVersionMutex.RLock()
	defer fake.currentPinnedVersionMutex.RUnlock()
	fake.disableVersionMutex.RLock()
	defer fake.disableVersionMutex.RUnlock()
	fake.enableVersionMutex.RLock()
	defer fake.enableVersionMutex.RUnlock()
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	fake.hasWebhookMutex.RLock()
	defer fake.hasWebhookMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.iconMutex.RLock()
	defer fake.iconMutex.RUnlock()
	fake.lastCheckEndTimeMutex.RLock()
	defer fake.lastCheckEndTimeMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.notifyScanMutex.RLock()
	defer fake.notifyScanMutex.RUnlock()
	fake.pinCommentMutex.RLock()
	defer fake.pinCommentMutex.RUnlock()
	fake.pinVersionMutex.RLock()
	defer fake.pinVersionMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	fake.pipelineInstanceVarsMutex.RLock()
	defer fake.pipelineInstanceVarsMutex.RUnlock()
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	fake.pipelineRefMutex.RLock()
	defer fake.pipelineRefMutex.RUnlock()
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.resourceConfigIDMutex.RLock()
	defer fake.resourceConfigIDMutex.RUnlock()
	fake.resourceConfigScopeIDMutex.RLock()
	defer fake.resourceConfigScopeIDMutex.RUnlock()
	fake.setPinCommentMutex.RLock()
	defer fake.setPinCommentMutex.RUnlock()
	fake.setResourceConfigScopeMutex.RLock()
	defer fake.setResourceConfigScopeMutex.RUnlock()
	fake.sourceMutex.RLock()
	defer fake.sourceMutex.RUnlock()
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.timeToCheckMutex.RLock()
	defer fake.timeToCheckMutex.RUnlock()
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	fake.unpinVersionMutex.RLock()
	defer fake.unpinVersionMutex.RUnlock()
	fake.updateMetadataMutex.RLock()
	defer fake.updateMetadataMutex.RUnlock()
	fake.versionsMutex.RLock()
	defer fake.versionsMutex.RUnlock()
	fake.webhookTokenMutex.RLock()
	defer fake.webhookTokenMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResource) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Resource = new(FakeResource)
