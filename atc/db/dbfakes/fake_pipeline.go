// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/creds"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/vars"
)

type FakePipeline struct {
	ArchiveStub        func() error
	archiveMutex       sync.RWMutex
	archiveArgsForCall []struct {
	}
	archiveReturns struct {
		result1 error
	}
	archiveReturnsOnCall map[int]struct {
		result1 error
	}
	ArchivedStub        func() bool
	archivedMutex       sync.RWMutex
	archivedArgsForCall []struct {
	}
	archivedReturns struct {
		result1 bool
	}
	archivedReturnsOnCall map[int]struct {
		result1 bool
	}
	BuildsStub        func(db.Page) ([]db.Build, db.Pagination, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		arg1 db.Page
	}
	buildsReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	BuildsWithTimeStub        func(db.Page) ([]db.Build, db.Pagination, error)
	buildsWithTimeMutex       sync.RWMutex
	buildsWithTimeArgsForCall []struct {
		arg1 db.Page
	}
	buildsWithTimeReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsWithTimeReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	CheckPausedStub        func() (bool, error)
	checkPausedMutex       sync.RWMutex
	checkPausedArgsForCall []struct {
	}
	checkPausedReturns struct {
		result1 bool
		result2 error
	}
	checkPausedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ConfigStub        func() (atc.Config, error)
	configMutex       sync.RWMutex
	configArgsForCall []struct {
	}
	configReturns struct {
		result1 atc.Config
		result2 error
	}
	configReturnsOnCall map[int]struct {
		result1 atc.Config
		result2 error
	}
	ConfigVersionStub        func() db.ConfigVersion
	configVersionMutex       sync.RWMutex
	configVersionArgsForCall []struct {
	}
	configVersionReturns struct {
		result1 db.ConfigVersion
	}
	configVersionReturnsOnCall map[int]struct {
		result1 db.ConfigVersion
	}
	CreateOneOffBuildStub        func() (db.Build, error)
	createOneOffBuildMutex       sync.RWMutex
	createOneOffBuildArgsForCall []struct {
	}
	createOneOffBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createOneOffBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	CreateStartedBuildStub        func(atc.Plan) (db.Build, error)
	createStartedBuildMutex       sync.RWMutex
	createStartedBuildArgsForCall []struct {
		arg1 atc.Plan
	}
	createStartedBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createStartedBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	DashboardStub        func() ([]atc.JobSummary, error)
	dashboardMutex       sync.RWMutex
	dashboardArgsForCall []struct {
	}
	dashboardReturns struct {
		result1 []atc.JobSummary
		result2 error
	}
	dashboardReturnsOnCall map[int]struct {
		result1 []atc.JobSummary
		result2 error
	}
	DeleteBuildEventsByBuildIDsStub        func([]int) error
	deleteBuildEventsByBuildIDsMutex       sync.RWMutex
	deleteBuildEventsByBuildIDsArgsForCall []struct {
		arg1 []int
	}
	deleteBuildEventsByBuildIDsReturns struct {
		result1 error
	}
	deleteBuildEventsByBuildIDsReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	DisplayStub        func() *atc.DisplayConfig
	displayMutex       sync.RWMutex
	displayArgsForCall []struct {
	}
	displayReturns struct {
		result1 *atc.DisplayConfig
	}
	displayReturnsOnCall map[int]struct {
		result1 *atc.DisplayConfig
	}
	ExposeStub        func() error
	exposeMutex       sync.RWMutex
	exposeArgsForCall []struct {
	}
	exposeReturns struct {
		result1 error
	}
	exposeReturnsOnCall map[int]struct {
		result1 error
	}
	GetBuildsWithVersionAsInputStub        func(int, int) ([]db.Build, error)
	getBuildsWithVersionAsInputMutex       sync.RWMutex
	getBuildsWithVersionAsInputArgsForCall []struct {
		arg1 int
		arg2 int
	}
	getBuildsWithVersionAsInputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsInputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	GetBuildsWithVersionAsOutputStub        func(int, int) ([]db.Build, error)
	getBuildsWithVersionAsOutputMutex       sync.RWMutex
	getBuildsWithVersionAsOutputArgsForCall []struct {
		arg1 int
		arg2 int
	}
	getBuildsWithVersionAsOutputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsOutputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	GroupsStub        func() atc.GroupConfigs
	groupsMutex       sync.RWMutex
	groupsArgsForCall []struct {
	}
	groupsReturns struct {
		result1 atc.GroupConfigs
	}
	groupsReturnsOnCall map[int]struct {
		result1 atc.GroupConfigs
	}
	HideStub        func() error
	hideMutex       sync.RWMutex
	hideArgsForCall []struct {
	}
	hideReturns struct {
		result1 error
	}
	hideReturnsOnCall map[int]struct {
		result1 error
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	InstanceVarsStub        func() atc.InstanceVars
	instanceVarsMutex       sync.RWMutex
	instanceVarsArgsForCall []struct {
	}
	instanceVarsReturns struct {
		result1 atc.InstanceVars
	}
	instanceVarsReturnsOnCall map[int]struct {
		result1 atc.InstanceVars
	}
	JobStub        func(string) (db.Job, bool, error)
	jobMutex       sync.RWMutex
	jobArgsForCall []struct {
		arg1 string
	}
	jobReturns struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	jobReturnsOnCall map[int]struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	JobsStub        func() (db.Jobs, error)
	jobsMutex       sync.RWMutex
	jobsArgsForCall []struct {
	}
	jobsReturns struct {
		result1 db.Jobs
		result2 error
	}
	jobsReturnsOnCall map[int]struct {
		result1 db.Jobs
		result2 error
	}
	LastUpdatedStub        func() time.Time
	lastUpdatedMutex       sync.RWMutex
	lastUpdatedArgsForCall []struct {
	}
	lastUpdatedReturns struct {
		result1 time.Time
	}
	lastUpdatedReturnsOnCall map[int]struct {
		result1 time.Time
	}
	LoadDebugVersionsDBStub        func() (*atc.DebugVersionsDB, error)
	loadDebugVersionsDBMutex       sync.RWMutex
	loadDebugVersionsDBArgsForCall []struct {
	}
	loadDebugVersionsDBReturns struct {
		result1 *atc.DebugVersionsDB
		result2 error
	}
	loadDebugVersionsDBReturnsOnCall map[int]struct {
		result1 *atc.DebugVersionsDB
		result2 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ParentBuildIDStub        func() int
	parentBuildIDMutex       sync.RWMutex
	parentBuildIDArgsForCall []struct {
	}
	parentBuildIDReturns struct {
		result1 int
	}
	parentBuildIDReturnsOnCall map[int]struct {
		result1 int
	}
	ParentJobIDStub        func() int
	parentJobIDMutex       sync.RWMutex
	parentJobIDArgsForCall []struct {
	}
	parentJobIDReturns struct {
		result1 int
	}
	parentJobIDReturnsOnCall map[int]struct {
		result1 int
	}
	PauseStub        func(string) error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct {
		arg1 string
	}
	pauseReturns struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	PausedStub        func() bool
	pausedMutex       sync.RWMutex
	pausedArgsForCall []struct {
	}
	pausedReturns struct {
		result1 bool
	}
	pausedReturnsOnCall map[int]struct {
		result1 bool
	}
	PausedAtStub        func() time.Time
	pausedAtMutex       sync.RWMutex
	pausedAtArgsForCall []struct {
	}
	pausedAtReturns struct {
		result1 time.Time
	}
	pausedAtReturnsOnCall map[int]struct {
		result1 time.Time
	}
	PausedByStub        func() string
	pausedByMutex       sync.RWMutex
	pausedByArgsForCall []struct {
	}
	pausedByReturns struct {
		result1 string
	}
	pausedByReturnsOnCall map[int]struct {
		result1 string
	}
	PrototypeStub        func(string) (db.Prototype, bool, error)
	prototypeMutex       sync.RWMutex
	prototypeArgsForCall []struct {
		arg1 string
	}
	prototypeReturns struct {
		result1 db.Prototype
		result2 bool
		result3 error
	}
	prototypeReturnsOnCall map[int]struct {
		result1 db.Prototype
		result2 bool
		result3 error
	}
	PrototypesStub        func() (db.Prototypes, error)
	prototypesMutex       sync.RWMutex
	prototypesArgsForCall []struct {
	}
	prototypesReturns struct {
		result1 db.Prototypes
		result2 error
	}
	prototypesReturnsOnCall map[int]struct {
		result1 db.Prototypes
		result2 error
	}
	PublicStub        func() bool
	publicMutex       sync.RWMutex
	publicArgsForCall []struct {
	}
	publicReturns struct {
		result1 bool
	}
	publicReturnsOnCall map[int]struct {
		result1 bool
	}
	RefStub        func() atc.PipelineRef
	refMutex       sync.RWMutex
	refArgsForCall []struct {
	}
	refReturns struct {
		result1 atc.PipelineRef
	}
	refReturnsOnCall map[int]struct {
		result1 atc.PipelineRef
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
	}
	reloadReturns struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ResourceStub        func(string) (db.Resource, bool, error)
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
		arg1 string
	}
	resourceReturns struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	resourceReturnsOnCall map[int]struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	ResourceByIDStub        func(int) (db.Resource, bool, error)
	resourceByIDMutex       sync.RWMutex
	resourceByIDArgsForCall []struct {
		arg1 int
	}
	resourceByIDReturns struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	resourceByIDReturnsOnCall map[int]struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	ResourceTypeStub        func(string) (db.ResourceType, bool, error)
	resourceTypeMutex       sync.RWMutex
	resourceTypeArgsForCall []struct {
		arg1 string
	}
	resourceTypeReturns struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}
	resourceTypeReturnsOnCall map[int]struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}
	ResourceTypesStub        func() (db.ResourceTypes, error)
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct {
	}
	resourceTypesReturns struct {
		result1 db.ResourceTypes
		result2 error
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 db.ResourceTypes
		result2 error
	}
	ResourceVersionStub        func(int) (atc.ResourceVersion, bool, error)
	resourceVersionMutex       sync.RWMutex
	resourceVersionArgsForCall []struct {
		arg1 int
	}
	resourceVersionReturns struct {
		result1 atc.ResourceVersion
		result2 bool
		result3 error
	}
	resourceVersionReturnsOnCall map[int]struct {
		result1 atc.ResourceVersion
		result2 bool
		result3 error
	}
	ResourcesStub        func() (db.Resources, error)
	resourcesMutex       sync.RWMutex
	resourcesArgsForCall []struct {
	}
	resourcesReturns struct {
		result1 db.Resources
		result2 error
	}
	resourcesReturnsOnCall map[int]struct {
		result1 db.Resources
		result2 error
	}
	SetParentIDsStub        func(int, int) error
	setParentIDsMutex       sync.RWMutex
	setParentIDsArgsForCall []struct {
		arg1 int
		arg2 int
	}
	setParentIDsReturns struct {
		result1 error
	}
	setParentIDsReturnsOnCall map[int]struct {
		result1 error
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	UnpauseStub        func() error
	unpauseMutex       sync.RWMutex
	unpauseArgsForCall []struct {
	}
	unpauseReturns struct {
		result1 error
	}
	unpauseReturnsOnCall map[int]struct {
		result1 error
	}
	VarSourcesStub        func() atc.VarSourceConfigs
	varSourcesMutex       sync.RWMutex
	varSourcesArgsForCall []struct {
	}
	varSourcesReturns struct {
		result1 atc.VarSourceConfigs
	}
	varSourcesReturnsOnCall map[int]struct {
		result1 atc.VarSourceConfigs
	}
	VariablesStub        func(lager.Logger, creds.Secrets, creds.VarSourcePool) (vars.Variables, error)
	variablesMutex       sync.RWMutex
	variablesArgsForCall []struct {
		arg1 lager.Logger
		arg2 creds.Secrets
		arg3 creds.VarSourcePool
	}
	variablesReturns struct {
		result1 vars.Variables
		result2 error
	}
	variablesReturnsOnCall map[int]struct {
		result1 vars.Variables
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePipeline) Archive() error {
	fake.archiveMutex.Lock()
	ret, specificReturn := fake.archiveReturnsOnCall[len(fake.archiveArgsForCall)]
	fake.archiveArgsForCall = append(fake.archiveArgsForCall, struct {
	}{})
	stub := fake.ArchiveStub
	fakeReturns := fake.archiveReturns
	fake.recordInvocation("Archive", []interface{}{})
	fake.archiveMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) ArchiveCallCount() int {
	fake.archiveMutex.RLock()
	defer fake.archiveMutex.RUnlock()
	return len(fake.archiveArgsForCall)
}

func (fake *FakePipeline) ArchiveCalls(stub func() error) {
	fake.archiveMutex.Lock()
	defer fake.archiveMutex.Unlock()
	fake.ArchiveStub = stub
}

func (fake *FakePipeline) ArchiveReturns(result1 error) {
	fake.archiveMutex.Lock()
	defer fake.archiveMutex.Unlock()
	fake.ArchiveStub = nil
	fake.archiveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ArchiveReturnsOnCall(i int, result1 error) {
	fake.archiveMutex.Lock()
	defer fake.archiveMutex.Unlock()
	fake.ArchiveStub = nil
	if fake.archiveReturnsOnCall == nil {
		fake.archiveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.archiveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Archived() bool {
	fake.archivedMutex.Lock()
	ret, specificReturn := fake.archivedReturnsOnCall[len(fake.archivedArgsForCall)]
	fake.archivedArgsForCall = append(fake.archivedArgsForCall, struct {
	}{})
	stub := fake.ArchivedStub
	fakeReturns := fake.archivedReturns
	fake.recordInvocation("Archived", []interface{}{})
	fake.archivedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) ArchivedCallCount() int {
	fake.archivedMutex.RLock()
	defer fake.archivedMutex.RUnlock()
	return len(fake.archivedArgsForCall)
}

func (fake *FakePipeline) ArchivedCalls(stub func() bool) {
	fake.archivedMutex.Lock()
	defer fake.archivedMutex.Unlock()
	fake.ArchivedStub = stub
}

func (fake *FakePipeline) ArchivedReturns(result1 bool) {
	fake.archivedMutex.Lock()
	defer fake.archivedMutex.Unlock()
	fake.ArchivedStub = nil
	fake.archivedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) ArchivedReturnsOnCall(i int, result1 bool) {
	fake.archivedMutex.Lock()
	defer fake.archivedMutex.Unlock()
	fake.ArchivedStub = nil
	if fake.archivedReturnsOnCall == nil {
		fake.archivedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.archivedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) Builds(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	stub := fake.BuildsStub
	fakeReturns := fake.buildsReturns
	fake.recordInvocation("Builds", []interface{}{arg1})
	fake.buildsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakePipeline) BuildsCalls(stub func(db.Page) ([]db.Build, db.Pagination, error)) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = stub
}

func (fake *FakePipeline) BuildsArgsForCall(i int) db.Page {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	argsForCall := fake.buildsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) BuildsReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) BuildsReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) BuildsWithTime(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsWithTimeMutex.Lock()
	ret, specificReturn := fake.buildsWithTimeReturnsOnCall[len(fake.buildsWithTimeArgsForCall)]
	fake.buildsWithTimeArgsForCall = append(fake.buildsWithTimeArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	stub := fake.BuildsWithTimeStub
	fakeReturns := fake.buildsWithTimeReturns
	fake.recordInvocation("BuildsWithTime", []interface{}{arg1})
	fake.buildsWithTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) BuildsWithTimeCallCount() int {
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	return len(fake.buildsWithTimeArgsForCall)
}

func (fake *FakePipeline) BuildsWithTimeCalls(stub func(db.Page) ([]db.Build, db.Pagination, error)) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = stub
}

func (fake *FakePipeline) BuildsWithTimeArgsForCall(i int) db.Page {
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	argsForCall := fake.buildsWithTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) BuildsWithTimeReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = nil
	fake.buildsWithTimeReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) BuildsWithTimeReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = nil
	if fake.buildsWithTimeReturnsOnCall == nil {
		fake.buildsWithTimeReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsWithTimeReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) CheckPaused() (bool, error) {
	fake.checkPausedMutex.Lock()
	ret, specificReturn := fake.checkPausedReturnsOnCall[len(fake.checkPausedArgsForCall)]
	fake.checkPausedArgsForCall = append(fake.checkPausedArgsForCall, struct {
	}{})
	stub := fake.CheckPausedStub
	fakeReturns := fake.checkPausedReturns
	fake.recordInvocation("CheckPaused", []interface{}{})
	fake.checkPausedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CheckPausedCallCount() int {
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	return len(fake.checkPausedArgsForCall)
}

func (fake *FakePipeline) CheckPausedCalls(stub func() (bool, error)) {
	fake.checkPausedMutex.Lock()
	defer fake.checkPausedMutex.Unlock()
	fake.CheckPausedStub = stub
}

func (fake *FakePipeline) CheckPausedReturns(result1 bool, result2 error) {
	fake.checkPausedMutex.Lock()
	defer fake.checkPausedMutex.Unlock()
	fake.CheckPausedStub = nil
	fake.checkPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CheckPausedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkPausedMutex.Lock()
	defer fake.checkPausedMutex.Unlock()
	fake.CheckPausedStub = nil
	if fake.checkPausedReturnsOnCall == nil {
		fake.checkPausedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkPausedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Config() (atc.Config, error) {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct {
	}{})
	stub := fake.ConfigStub
	fakeReturns := fake.configReturns
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakePipeline) ConfigCalls(stub func() (atc.Config, error)) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = stub
}

func (fake *FakePipeline) ConfigReturns(result1 atc.Config, result2 error) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 atc.Config
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ConfigReturnsOnCall(i int, result1 atc.Config, result2 error) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 atc.Config
			result2 error
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 atc.Config
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ConfigVersion() db.ConfigVersion {
	fake.configVersionMutex.Lock()
	ret, specificReturn := fake.configVersionReturnsOnCall[len(fake.configVersionArgsForCall)]
	fake.configVersionArgsForCall = append(fake.configVersionArgsForCall, struct {
	}{})
	stub := fake.ConfigVersionStub
	fakeReturns := fake.configVersionReturns
	fake.recordInvocation("ConfigVersion", []interface{}{})
	fake.configVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) ConfigVersionCallCount() int {
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	return len(fake.configVersionArgsForCall)
}

func (fake *FakePipeline) ConfigVersionCalls(stub func() db.ConfigVersion) {
	fake.configVersionMutex.Lock()
	defer fake.configVersionMutex.Unlock()
	fake.ConfigVersionStub = stub
}

func (fake *FakePipeline) ConfigVersionReturns(result1 db.ConfigVersion) {
	fake.configVersionMutex.Lock()
	defer fake.configVersionMutex.Unlock()
	fake.ConfigVersionStub = nil
	fake.configVersionReturns = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) ConfigVersionReturnsOnCall(i int, result1 db.ConfigVersion) {
	fake.configVersionMutex.Lock()
	defer fake.configVersionMutex.Unlock()
	fake.ConfigVersionStub = nil
	if fake.configVersionReturnsOnCall == nil {
		fake.configVersionReturnsOnCall = make(map[int]struct {
			result1 db.ConfigVersion
		})
	}
	fake.configVersionReturnsOnCall[i] = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) CreateOneOffBuild() (db.Build, error) {
	fake.createOneOffBuildMutex.Lock()
	ret, specificReturn := fake.createOneOffBuildReturnsOnCall[len(fake.createOneOffBuildArgsForCall)]
	fake.createOneOffBuildArgsForCall = append(fake.createOneOffBuildArgsForCall, struct {
	}{})
	stub := fake.CreateOneOffBuildStub
	fakeReturns := fake.createOneOffBuildReturns
	fake.recordInvocation("CreateOneOffBuild", []interface{}{})
	fake.createOneOffBuildMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CreateOneOffBuildCallCount() int {
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	return len(fake.createOneOffBuildArgsForCall)
}

func (fake *FakePipeline) CreateOneOffBuildCalls(stub func() (db.Build, error)) {
	fake.createOneOffBuildMutex.Lock()
	defer fake.createOneOffBuildMutex.Unlock()
	fake.CreateOneOffBuildStub = stub
}

func (fake *FakePipeline) CreateOneOffBuildReturns(result1 db.Build, result2 error) {
	fake.createOneOffBuildMutex.Lock()
	defer fake.createOneOffBuildMutex.Unlock()
	fake.CreateOneOffBuildStub = nil
	fake.createOneOffBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateOneOffBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.createOneOffBuildMutex.Lock()
	defer fake.createOneOffBuildMutex.Unlock()
	fake.CreateOneOffBuildStub = nil
	if fake.createOneOffBuildReturnsOnCall == nil {
		fake.createOneOffBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createOneOffBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateStartedBuild(arg1 atc.Plan) (db.Build, error) {
	fake.createStartedBuildMutex.Lock()
	ret, specificReturn := fake.createStartedBuildReturnsOnCall[len(fake.createStartedBuildArgsForCall)]
	fake.createStartedBuildArgsForCall = append(fake.createStartedBuildArgsForCall, struct {
		arg1 atc.Plan
	}{arg1})
	stub := fake.CreateStartedBuildStub
	fakeReturns := fake.createStartedBuildReturns
	fake.recordInvocation("CreateStartedBuild", []interface{}{arg1})
	fake.createStartedBuildMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CreateStartedBuildCallCount() int {
	fake.createStartedBuildMutex.RLock()
	defer fake.createStartedBuildMutex.RUnlock()
	return len(fake.createStartedBuildArgsForCall)
}

func (fake *FakePipeline) CreateStartedBuildCalls(stub func(atc.Plan) (db.Build, error)) {
	fake.createStartedBuildMutex.Lock()
	defer fake.createStartedBuildMutex.Unlock()
	fake.CreateStartedBuildStub = stub
}

func (fake *FakePipeline) CreateStartedBuildArgsForCall(i int) atc.Plan {
	fake.createStartedBuildMutex.RLock()
	defer fake.createStartedBuildMutex.RUnlock()
	argsForCall := fake.createStartedBuildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) CreateStartedBuildReturns(result1 db.Build, result2 error) {
	fake.createStartedBuildMutex.Lock()
	defer fake.createStartedBuildMutex.Unlock()
	fake.CreateStartedBuildStub = nil
	fake.createStartedBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateStartedBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.createStartedBuildMutex.Lock()
	defer fake.createStartedBuildMutex.Unlock()
	fake.CreateStartedBuildStub = nil
	if fake.createStartedBuildReturnsOnCall == nil {
		fake.createStartedBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createStartedBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Dashboard() ([]atc.JobSummary, error) {
	fake.dashboardMutex.Lock()
	ret, specificReturn := fake.dashboardReturnsOnCall[len(fake.dashboardArgsForCall)]
	fake.dashboardArgsForCall = append(fake.dashboardArgsForCall, struct {
	}{})
	stub := fake.DashboardStub
	fakeReturns := fake.dashboardReturns
	fake.recordInvocation("Dashboard", []interface{}{})
	fake.dashboardMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) DashboardCallCount() int {
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	return len(fake.dashboardArgsForCall)
}

func (fake *FakePipeline) DashboardCalls(stub func() ([]atc.JobSummary, error)) {
	fake.dashboardMutex.Lock()
	defer fake.dashboardMutex.Unlock()
	fake.DashboardStub = stub
}

func (fake *FakePipeline) DashboardReturns(result1 []atc.JobSummary, result2 error) {
	fake.dashboardMutex.Lock()
	defer fake.dashboardMutex.Unlock()
	fake.DashboardStub = nil
	fake.dashboardReturns = struct {
		result1 []atc.JobSummary
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) DashboardReturnsOnCall(i int, result1 []atc.JobSummary, result2 error) {
	fake.dashboardMutex.Lock()
	defer fake.dashboardMutex.Unlock()
	fake.DashboardStub = nil
	if fake.dashboardReturnsOnCall == nil {
		fake.dashboardReturnsOnCall = make(map[int]struct {
			result1 []atc.JobSummary
			result2 error
		})
	}
	fake.dashboardReturnsOnCall[i] = struct {
		result1 []atc.JobSummary
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDs(arg1 []int) error {
	var arg1Copy []int
	if arg1 != nil {
		arg1Copy = make([]int, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	ret, specificReturn := fake.deleteBuildEventsByBuildIDsReturnsOnCall[len(fake.deleteBuildEventsByBuildIDsArgsForCall)]
	fake.deleteBuildEventsByBuildIDsArgsForCall = append(fake.deleteBuildEventsByBuildIDsArgsForCall, struct {
		arg1 []int
	}{arg1Copy})
	stub := fake.DeleteBuildEventsByBuildIDsStub
	fakeReturns := fake.deleteBuildEventsByBuildIDsReturns
	fake.recordInvocation("DeleteBuildEventsByBuildIDs", []interface{}{arg1Copy})
	fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsCallCount() int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	return len(fake.deleteBuildEventsByBuildIDsArgsForCall)
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsCalls(stub func([]int) error) {
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	defer fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	fake.DeleteBuildEventsByBuildIDsStub = stub
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsArgsForCall(i int) []int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	argsForCall := fake.deleteBuildEventsByBuildIDsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturns(result1 error) {
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	defer fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	fake.DeleteBuildEventsByBuildIDsStub = nil
	fake.deleteBuildEventsByBuildIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturnsOnCall(i int, result1 error) {
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	defer fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	fake.DeleteBuildEventsByBuildIDsStub = nil
	if fake.deleteBuildEventsByBuildIDsReturnsOnCall == nil {
		fake.deleteBuildEventsByBuildIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBuildEventsByBuildIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
	}{})
	stub := fake.DestroyStub
	fakeReturns := fake.destroyReturns
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakePipeline) DestroyCalls(stub func() error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = stub
}

func (fake *FakePipeline) DestroyReturns(result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DestroyReturnsOnCall(i int, result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Display() *atc.DisplayConfig {
	fake.displayMutex.Lock()
	ret, specificReturn := fake.displayReturnsOnCall[len(fake.displayArgsForCall)]
	fake.displayArgsForCall = append(fake.displayArgsForCall, struct {
	}{})
	stub := fake.DisplayStub
	fakeReturns := fake.displayReturns
	fake.recordInvocation("Display", []interface{}{})
	fake.displayMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) DisplayCallCount() int {
	fake.displayMutex.RLock()
	defer fake.displayMutex.RUnlock()
	return len(fake.displayArgsForCall)
}

func (fake *FakePipeline) DisplayCalls(stub func() *atc.DisplayConfig) {
	fake.displayMutex.Lock()
	defer fake.displayMutex.Unlock()
	fake.DisplayStub = stub
}

func (fake *FakePipeline) DisplayReturns(result1 *atc.DisplayConfig) {
	fake.displayMutex.Lock()
	defer fake.displayMutex.Unlock()
	fake.DisplayStub = nil
	fake.displayReturns = struct {
		result1 *atc.DisplayConfig
	}{result1}
}

func (fake *FakePipeline) DisplayReturnsOnCall(i int, result1 *atc.DisplayConfig) {
	fake.displayMutex.Lock()
	defer fake.displayMutex.Unlock()
	fake.DisplayStub = nil
	if fake.displayReturnsOnCall == nil {
		fake.displayReturnsOnCall = make(map[int]struct {
			result1 *atc.DisplayConfig
		})
	}
	fake.displayReturnsOnCall[i] = struct {
		result1 *atc.DisplayConfig
	}{result1}
}

func (fake *FakePipeline) Expose() error {
	fake.exposeMutex.Lock()
	ret, specificReturn := fake.exposeReturnsOnCall[len(fake.exposeArgsForCall)]
	fake.exposeArgsForCall = append(fake.exposeArgsForCall, struct {
	}{})
	stub := fake.ExposeStub
	fakeReturns := fake.exposeReturns
	fake.recordInvocation("Expose", []interface{}{})
	fake.exposeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) ExposeCallCount() int {
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	return len(fake.exposeArgsForCall)
}

func (fake *FakePipeline) ExposeCalls(stub func() error) {
	fake.exposeMutex.Lock()
	defer fake.exposeMutex.Unlock()
	fake.ExposeStub = stub
}

func (fake *FakePipeline) ExposeReturns(result1 error) {
	fake.exposeMutex.Lock()
	defer fake.exposeMutex.Unlock()
	fake.ExposeStub = nil
	fake.exposeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ExposeReturnsOnCall(i int, result1 error) {
	fake.exposeMutex.Lock()
	defer fake.exposeMutex.Unlock()
	fake.ExposeStub = nil
	if fake.exposeReturnsOnCall == nil {
		fake.exposeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exposeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInput(arg1 int, arg2 int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsInputReturnsOnCall[len(fake.getBuildsWithVersionAsInputArgsForCall)]
	fake.getBuildsWithVersionAsInputArgsForCall = append(fake.getBuildsWithVersionAsInputArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.GetBuildsWithVersionAsInputStub
	fakeReturns := fake.getBuildsWithVersionAsInputReturns
	fake.recordInvocation("GetBuildsWithVersionAsInput", []interface{}{arg1, arg2})
	fake.getBuildsWithVersionAsInputMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputCallCount() int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsInputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputCalls(stub func(int, int) ([]db.Build, error)) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	defer fake.getBuildsWithVersionAsInputMutex.Unlock()
	fake.GetBuildsWithVersionAsInputStub = stub
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputArgsForCall(i int) (int, int) {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	argsForCall := fake.getBuildsWithVersionAsInputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturns(result1 []db.Build, result2 error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	defer fake.getBuildsWithVersionAsInputMutex.Unlock()
	fake.GetBuildsWithVersionAsInputStub = nil
	fake.getBuildsWithVersionAsInputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	defer fake.getBuildsWithVersionAsInputMutex.Unlock()
	fake.GetBuildsWithVersionAsInputStub = nil
	if fake.getBuildsWithVersionAsInputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsInputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsInputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutput(arg1 int, arg2 int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsOutputReturnsOnCall[len(fake.getBuildsWithVersionAsOutputArgsForCall)]
	fake.getBuildsWithVersionAsOutputArgsForCall = append(fake.getBuildsWithVersionAsOutputArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.GetBuildsWithVersionAsOutputStub
	fakeReturns := fake.getBuildsWithVersionAsOutputReturns
	fake.recordInvocation("GetBuildsWithVersionAsOutput", []interface{}{arg1, arg2})
	fake.getBuildsWithVersionAsOutputMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputCallCount() int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsOutputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputCalls(stub func(int, int) ([]db.Build, error)) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	defer fake.getBuildsWithVersionAsOutputMutex.Unlock()
	fake.GetBuildsWithVersionAsOutputStub = stub
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputArgsForCall(i int) (int, int) {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	argsForCall := fake.getBuildsWithVersionAsOutputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturns(result1 []db.Build, result2 error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	defer fake.getBuildsWithVersionAsOutputMutex.Unlock()
	fake.GetBuildsWithVersionAsOutputStub = nil
	fake.getBuildsWithVersionAsOutputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	defer fake.getBuildsWithVersionAsOutputMutex.Unlock()
	fake.GetBuildsWithVersionAsOutputStub = nil
	if fake.getBuildsWithVersionAsOutputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsOutputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsOutputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Groups() atc.GroupConfigs {
	fake.groupsMutex.Lock()
	ret, specificReturn := fake.groupsReturnsOnCall[len(fake.groupsArgsForCall)]
	fake.groupsArgsForCall = append(fake.groupsArgsForCall, struct {
	}{})
	stub := fake.GroupsStub
	fakeReturns := fake.groupsReturns
	fake.recordInvocation("Groups", []interface{}{})
	fake.groupsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) GroupsCallCount() int {
	fake.groupsMutex.RLock()
	defer fake.groupsMutex.RUnlock()
	return len(fake.groupsArgsForCall)
}

func (fake *FakePipeline) GroupsCalls(stub func() atc.GroupConfigs) {
	fake.groupsMutex.Lock()
	defer fake.groupsMutex.Unlock()
	fake.GroupsStub = stub
}

func (fake *FakePipeline) GroupsReturns(result1 atc.GroupConfigs) {
	fake.groupsMutex.Lock()
	defer fake.groupsMutex.Unlock()
	fake.GroupsStub = nil
	fake.groupsReturns = struct {
		result1 atc.GroupConfigs
	}{result1}
}

func (fake *FakePipeline) GroupsReturnsOnCall(i int, result1 atc.GroupConfigs) {
	fake.groupsMutex.Lock()
	defer fake.groupsMutex.Unlock()
	fake.GroupsStub = nil
	if fake.groupsReturnsOnCall == nil {
		fake.groupsReturnsOnCall = make(map[int]struct {
			result1 atc.GroupConfigs
		})
	}
	fake.groupsReturnsOnCall[i] = struct {
		result1 atc.GroupConfigs
	}{result1}
}

func (fake *FakePipeline) Hide() error {
	fake.hideMutex.Lock()
	ret, specificReturn := fake.hideReturnsOnCall[len(fake.hideArgsForCall)]
	fake.hideArgsForCall = append(fake.hideArgsForCall, struct {
	}{})
	stub := fake.HideStub
	fakeReturns := fake.hideReturns
	fake.recordInvocation("Hide", []interface{}{})
	fake.hideMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) HideCallCount() int {
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	return len(fake.hideArgsForCall)
}

func (fake *FakePipeline) HideCalls(stub func() error) {
	fake.hideMutex.Lock()
	defer fake.hideMutex.Unlock()
	fake.HideStub = stub
}

func (fake *FakePipeline) HideReturns(result1 error) {
	fake.hideMutex.Lock()
	defer fake.hideMutex.Unlock()
	fake.HideStub = nil
	fake.hideReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) HideReturnsOnCall(i int, result1 error) {
	fake.hideMutex.Lock()
	defer fake.hideMutex.Unlock()
	fake.HideStub = nil
	if fake.hideReturnsOnCall == nil {
		fake.hideReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.hideReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakePipeline) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakePipeline) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) InstanceVars() atc.InstanceVars {
	fake.instanceVarsMutex.Lock()
	ret, specificReturn := fake.instanceVarsReturnsOnCall[len(fake.instanceVarsArgsForCall)]
	fake.instanceVarsArgsForCall = append(fake.instanceVarsArgsForCall, struct {
	}{})
	stub := fake.InstanceVarsStub
	fakeReturns := fake.instanceVarsReturns
	fake.recordInvocation("InstanceVars", []interface{}{})
	fake.instanceVarsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) InstanceVarsCallCount() int {
	fake.instanceVarsMutex.RLock()
	defer fake.instanceVarsMutex.RUnlock()
	return len(fake.instanceVarsArgsForCall)
}

func (fake *FakePipeline) InstanceVarsCalls(stub func() atc.InstanceVars) {
	fake.instanceVarsMutex.Lock()
	defer fake.instanceVarsMutex.Unlock()
	fake.InstanceVarsStub = stub
}

func (fake *FakePipeline) InstanceVarsReturns(result1 atc.InstanceVars) {
	fake.instanceVarsMutex.Lock()
	defer fake.instanceVarsMutex.Unlock()
	fake.InstanceVarsStub = nil
	fake.instanceVarsReturns = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakePipeline) InstanceVarsReturnsOnCall(i int, result1 atc.InstanceVars) {
	fake.instanceVarsMutex.Lock()
	defer fake.instanceVarsMutex.Unlock()
	fake.InstanceVarsStub = nil
	if fake.instanceVarsReturnsOnCall == nil {
		fake.instanceVarsReturnsOnCall = make(map[int]struct {
			result1 atc.InstanceVars
		})
	}
	fake.instanceVarsReturnsOnCall[i] = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakePipeline) Job(arg1 string) (db.Job, bool, error) {
	fake.jobMutex.Lock()
	ret, specificReturn := fake.jobReturnsOnCall[len(fake.jobArgsForCall)]
	fake.jobArgsForCall = append(fake.jobArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.JobStub
	fakeReturns := fake.jobReturns
	fake.recordInvocation("Job", []interface{}{arg1})
	fake.jobMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) JobCallCount() int {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return len(fake.jobArgsForCall)
}

func (fake *FakePipeline) JobCalls(stub func(string) (db.Job, bool, error)) {
	fake.jobMutex.Lock()
	defer fake.jobMutex.Unlock()
	fake.JobStub = stub
}

func (fake *FakePipeline) JobArgsForCall(i int) string {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	argsForCall := fake.jobArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) JobReturns(result1 db.Job, result2 bool, result3 error) {
	fake.jobMutex.Lock()
	defer fake.jobMutex.Unlock()
	fake.JobStub = nil
	fake.jobReturns = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) JobReturnsOnCall(i int, result1 db.Job, result2 bool, result3 error) {
	fake.jobMutex.Lock()
	defer fake.jobMutex.Unlock()
	fake.JobStub = nil
	if fake.jobReturnsOnCall == nil {
		fake.jobReturnsOnCall = make(map[int]struct {
			result1 db.Job
			result2 bool
			result3 error
		})
	}
	fake.jobReturnsOnCall[i] = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Jobs() (db.Jobs, error) {
	fake.jobsMutex.Lock()
	ret, specificReturn := fake.jobsReturnsOnCall[len(fake.jobsArgsForCall)]
	fake.jobsArgsForCall = append(fake.jobsArgsForCall, struct {
	}{})
	stub := fake.JobsStub
	fakeReturns := fake.jobsReturns
	fake.recordInvocation("Jobs", []interface{}{})
	fake.jobsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) JobsCallCount() int {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	return len(fake.jobsArgsForCall)
}

func (fake *FakePipeline) JobsCalls(stub func() (db.Jobs, error)) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = stub
}

func (fake *FakePipeline) JobsReturns(result1 db.Jobs, result2 error) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = nil
	fake.jobsReturns = struct {
		result1 db.Jobs
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) JobsReturnsOnCall(i int, result1 db.Jobs, result2 error) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = nil
	if fake.jobsReturnsOnCall == nil {
		fake.jobsReturnsOnCall = make(map[int]struct {
			result1 db.Jobs
			result2 error
		})
	}
	fake.jobsReturnsOnCall[i] = struct {
		result1 db.Jobs
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) LastUpdated() time.Time {
	fake.lastUpdatedMutex.Lock()
	ret, specificReturn := fake.lastUpdatedReturnsOnCall[len(fake.lastUpdatedArgsForCall)]
	fake.lastUpdatedArgsForCall = append(fake.lastUpdatedArgsForCall, struct {
	}{})
	stub := fake.LastUpdatedStub
	fakeReturns := fake.lastUpdatedReturns
	fake.recordInvocation("LastUpdated", []interface{}{})
	fake.lastUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) LastUpdatedCallCount() int {
	fake.lastUpdatedMutex.RLock()
	defer fake.lastUpdatedMutex.RUnlock()
	return len(fake.lastUpdatedArgsForCall)
}

func (fake *FakePipeline) LastUpdatedCalls(stub func() time.Time) {
	fake.lastUpdatedMutex.Lock()
	defer fake.lastUpdatedMutex.Unlock()
	fake.LastUpdatedStub = stub
}

func (fake *FakePipeline) LastUpdatedReturns(result1 time.Time) {
	fake.lastUpdatedMutex.Lock()
	defer fake.lastUpdatedMutex.Unlock()
	fake.LastUpdatedStub = nil
	fake.lastUpdatedReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakePipeline) LastUpdatedReturnsOnCall(i int, result1 time.Time) {
	fake.lastUpdatedMutex.Lock()
	defer fake.lastUpdatedMutex.Unlock()
	fake.LastUpdatedStub = nil
	if fake.lastUpdatedReturnsOnCall == nil {
		fake.lastUpdatedReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.lastUpdatedReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakePipeline) LoadDebugVersionsDB() (*atc.DebugVersionsDB, error) {
	fake.loadDebugVersionsDBMutex.Lock()
	ret, specificReturn := fake.loadDebugVersionsDBReturnsOnCall[len(fake.loadDebugVersionsDBArgsForCall)]
	fake.loadDebugVersionsDBArgsForCall = append(fake.loadDebugVersionsDBArgsForCall, struct {
	}{})
	stub := fake.LoadDebugVersionsDBStub
	fakeReturns := fake.loadDebugVersionsDBReturns
	fake.recordInvocation("LoadDebugVersionsDB", []interface{}{})
	fake.loadDebugVersionsDBMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) LoadDebugVersionsDBCallCount() int {
	fake.loadDebugVersionsDBMutex.RLock()
	defer fake.loadDebugVersionsDBMutex.RUnlock()
	return len(fake.loadDebugVersionsDBArgsForCall)
}

func (fake *FakePipeline) LoadDebugVersionsDBCalls(stub func() (*atc.DebugVersionsDB, error)) {
	fake.loadDebugVersionsDBMutex.Lock()
	defer fake.loadDebugVersionsDBMutex.Unlock()
	fake.LoadDebugVersionsDBStub = stub
}

func (fake *FakePipeline) LoadDebugVersionsDBReturns(result1 *atc.DebugVersionsDB, result2 error) {
	fake.loadDebugVersionsDBMutex.Lock()
	defer fake.loadDebugVersionsDBMutex.Unlock()
	fake.LoadDebugVersionsDBStub = nil
	fake.loadDebugVersionsDBReturns = struct {
		result1 *atc.DebugVersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) LoadDebugVersionsDBReturnsOnCall(i int, result1 *atc.DebugVersionsDB, result2 error) {
	fake.loadDebugVersionsDBMutex.Lock()
	defer fake.loadDebugVersionsDBMutex.Unlock()
	fake.LoadDebugVersionsDBStub = nil
	if fake.loadDebugVersionsDBReturnsOnCall == nil {
		fake.loadDebugVersionsDBReturnsOnCall = make(map[int]struct {
			result1 *atc.DebugVersionsDB
			result2 error
		})
	}
	fake.loadDebugVersionsDBReturnsOnCall[i] = struct {
		result1 *atc.DebugVersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakePipeline) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakePipeline) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) ParentBuildID() int {
	fake.parentBuildIDMutex.Lock()
	ret, specificReturn := fake.parentBuildIDReturnsOnCall[len(fake.parentBuildIDArgsForCall)]
	fake.parentBuildIDArgsForCall = append(fake.parentBuildIDArgsForCall, struct {
	}{})
	stub := fake.ParentBuildIDStub
	fakeReturns := fake.parentBuildIDReturns
	fake.recordInvocation("ParentBuildID", []interface{}{})
	fake.parentBuildIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) ParentBuildIDCallCount() int {
	fake.parentBuildIDMutex.RLock()
	defer fake.parentBuildIDMutex.RUnlock()
	return len(fake.parentBuildIDArgsForCall)
}

func (fake *FakePipeline) ParentBuildIDCalls(stub func() int) {
	fake.parentBuildIDMutex.Lock()
	defer fake.parentBuildIDMutex.Unlock()
	fake.ParentBuildIDStub = stub
}

func (fake *FakePipeline) ParentBuildIDReturns(result1 int) {
	fake.parentBuildIDMutex.Lock()
	defer fake.parentBuildIDMutex.Unlock()
	fake.ParentBuildIDStub = nil
	fake.parentBuildIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) ParentBuildIDReturnsOnCall(i int, result1 int) {
	fake.parentBuildIDMutex.Lock()
	defer fake.parentBuildIDMutex.Unlock()
	fake.ParentBuildIDStub = nil
	if fake.parentBuildIDReturnsOnCall == nil {
		fake.parentBuildIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.parentBuildIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) ParentJobID() int {
	fake.parentJobIDMutex.Lock()
	ret, specificReturn := fake.parentJobIDReturnsOnCall[len(fake.parentJobIDArgsForCall)]
	fake.parentJobIDArgsForCall = append(fake.parentJobIDArgsForCall, struct {
	}{})
	stub := fake.ParentJobIDStub
	fakeReturns := fake.parentJobIDReturns
	fake.recordInvocation("ParentJobID", []interface{}{})
	fake.parentJobIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) ParentJobIDCallCount() int {
	fake.parentJobIDMutex.RLock()
	defer fake.parentJobIDMutex.RUnlock()
	return len(fake.parentJobIDArgsForCall)
}

func (fake *FakePipeline) ParentJobIDCalls(stub func() int) {
	fake.parentJobIDMutex.Lock()
	defer fake.parentJobIDMutex.Unlock()
	fake.ParentJobIDStub = stub
}

func (fake *FakePipeline) ParentJobIDReturns(result1 int) {
	fake.parentJobIDMutex.Lock()
	defer fake.parentJobIDMutex.Unlock()
	fake.ParentJobIDStub = nil
	fake.parentJobIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) ParentJobIDReturnsOnCall(i int, result1 int) {
	fake.parentJobIDMutex.Lock()
	defer fake.parentJobIDMutex.Unlock()
	fake.ParentJobIDStub = nil
	if fake.parentJobIDReturnsOnCall == nil {
		fake.parentJobIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.parentJobIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) Pause(arg1 string) error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PauseStub
	fakeReturns := fake.pauseReturns
	fake.recordInvocation("Pause", []interface{}{arg1})
	fake.pauseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakePipeline) PauseCalls(stub func(string) error) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = stub
}

func (fake *FakePipeline) PauseArgsForCall(i int) string {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	argsForCall := fake.pauseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) PauseReturns(result1 error) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) PauseReturnsOnCall(i int, result1 error) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Paused() bool {
	fake.pausedMutex.Lock()
	ret, specificReturn := fake.pausedReturnsOnCall[len(fake.pausedArgsForCall)]
	fake.pausedArgsForCall = append(fake.pausedArgsForCall, struct {
	}{})
	stub := fake.PausedStub
	fakeReturns := fake.pausedReturns
	fake.recordInvocation("Paused", []interface{}{})
	fake.pausedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) PausedCallCount() int {
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	return len(fake.pausedArgsForCall)
}

func (fake *FakePipeline) PausedCalls(stub func() bool) {
	fake.pausedMutex.Lock()
	defer fake.pausedMutex.Unlock()
	fake.PausedStub = stub
}

func (fake *FakePipeline) PausedReturns(result1 bool) {
	fake.pausedMutex.Lock()
	defer fake.pausedMutex.Unlock()
	fake.PausedStub = nil
	fake.pausedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PausedReturnsOnCall(i int, result1 bool) {
	fake.pausedMutex.Lock()
	defer fake.pausedMutex.Unlock()
	fake.PausedStub = nil
	if fake.pausedReturnsOnCall == nil {
		fake.pausedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pausedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PausedAt() time.Time {
	fake.pausedAtMutex.Lock()
	ret, specificReturn := fake.pausedAtReturnsOnCall[len(fake.pausedAtArgsForCall)]
	fake.pausedAtArgsForCall = append(fake.pausedAtArgsForCall, struct {
	}{})
	stub := fake.PausedAtStub
	fakeReturns := fake.pausedAtReturns
	fake.recordInvocation("PausedAt", []interface{}{})
	fake.pausedAtMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) PausedAtCallCount() int {
	fake.pausedAtMutex.RLock()
	defer fake.pausedAtMutex.RUnlock()
	return len(fake.pausedAtArgsForCall)
}

func (fake *FakePipeline) PausedAtCalls(stub func() time.Time) {
	fake.pausedAtMutex.Lock()
	defer fake.pausedAtMutex.Unlock()
	fake.PausedAtStub = stub
}

func (fake *FakePipeline) PausedAtReturns(result1 time.Time) {
	fake.pausedAtMutex.Lock()
	defer fake.pausedAtMutex.Unlock()
	fake.PausedAtStub = nil
	fake.pausedAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakePipeline) PausedAtReturnsOnCall(i int, result1 time.Time) {
	fake.pausedAtMutex.Lock()
	defer fake.pausedAtMutex.Unlock()
	fake.PausedAtStub = nil
	if fake.pausedAtReturnsOnCall == nil {
		fake.pausedAtReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.pausedAtReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakePipeline) PausedBy() string {
	fake.pausedByMutex.Lock()
	ret, specificReturn := fake.pausedByReturnsOnCall[len(fake.pausedByArgsForCall)]
	fake.pausedByArgsForCall = append(fake.pausedByArgsForCall, struct {
	}{})
	stub := fake.PausedByStub
	fakeReturns := fake.pausedByReturns
	fake.recordInvocation("PausedBy", []interface{}{})
	fake.pausedByMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) PausedByCallCount() int {
	fake.pausedByMutex.RLock()
	defer fake.pausedByMutex.RUnlock()
	return len(fake.pausedByArgsForCall)
}

func (fake *FakePipeline) PausedByCalls(stub func() string) {
	fake.pausedByMutex.Lock()
	defer fake.pausedByMutex.Unlock()
	fake.PausedByStub = stub
}

func (fake *FakePipeline) PausedByReturns(result1 string) {
	fake.pausedByMutex.Lock()
	defer fake.pausedByMutex.Unlock()
	fake.PausedByStub = nil
	fake.pausedByReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) PausedByReturnsOnCall(i int, result1 string) {
	fake.pausedByMutex.Lock()
	defer fake.pausedByMutex.Unlock()
	fake.PausedByStub = nil
	if fake.pausedByReturnsOnCall == nil {
		fake.pausedByReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pausedByReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) Prototype(arg1 string) (db.Prototype, bool, error) {
	fake.prototypeMutex.Lock()
	ret, specificReturn := fake.prototypeReturnsOnCall[len(fake.prototypeArgsForCall)]
	fake.prototypeArgsForCall = append(fake.prototypeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PrototypeStub
	fakeReturns := fake.prototypeReturns
	fake.recordInvocation("Prototype", []interface{}{arg1})
	fake.prototypeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) PrototypeCallCount() int {
	fake.prototypeMutex.RLock()
	defer fake.prototypeMutex.RUnlock()
	return len(fake.prototypeArgsForCall)
}

func (fake *FakePipeline) PrototypeCalls(stub func(string) (db.Prototype, bool, error)) {
	fake.prototypeMutex.Lock()
	defer fake.prototypeMutex.Unlock()
	fake.PrototypeStub = stub
}

func (fake *FakePipeline) PrototypeArgsForCall(i int) string {
	fake.prototypeMutex.RLock()
	defer fake.prototypeMutex.RUnlock()
	argsForCall := fake.prototypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) PrototypeReturns(result1 db.Prototype, result2 bool, result3 error) {
	fake.prototypeMutex.Lock()
	defer fake.prototypeMutex.Unlock()
	fake.PrototypeStub = nil
	fake.prototypeReturns = struct {
		result1 db.Prototype
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) PrototypeReturnsOnCall(i int, result1 db.Prototype, result2 bool, result3 error) {
	fake.prototypeMutex.Lock()
	defer fake.prototypeMutex.Unlock()
	fake.PrototypeStub = nil
	if fake.prototypeReturnsOnCall == nil {
		fake.prototypeReturnsOnCall = make(map[int]struct {
			result1 db.Prototype
			result2 bool
			result3 error
		})
	}
	fake.prototypeReturnsOnCall[i] = struct {
		result1 db.Prototype
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Prototypes() (db.Prototypes, error) {
	fake.prototypesMutex.Lock()
	ret, specificReturn := fake.prototypesReturnsOnCall[len(fake.prototypesArgsForCall)]
	fake.prototypesArgsForCall = append(fake.prototypesArgsForCall, struct {
	}{})
	stub := fake.PrototypesStub
	fakeReturns := fake.prototypesReturns
	fake.recordInvocation("Prototypes", []interface{}{})
	fake.prototypesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) PrototypesCallCount() int {
	fake.prototypesMutex.RLock()
	defer fake.prototypesMutex.RUnlock()
	return len(fake.prototypesArgsForCall)
}

func (fake *FakePipeline) PrototypesCalls(stub func() (db.Prototypes, error)) {
	fake.prototypesMutex.Lock()
	defer fake.prototypesMutex.Unlock()
	fake.PrototypesStub = stub
}

func (fake *FakePipeline) PrototypesReturns(result1 db.Prototypes, result2 error) {
	fake.prototypesMutex.Lock()
	defer fake.prototypesMutex.Unlock()
	fake.PrototypesStub = nil
	fake.prototypesReturns = struct {
		result1 db.Prototypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) PrototypesReturnsOnCall(i int, result1 db.Prototypes, result2 error) {
	fake.prototypesMutex.Lock()
	defer fake.prototypesMutex.Unlock()
	fake.PrototypesStub = nil
	if fake.prototypesReturnsOnCall == nil {
		fake.prototypesReturnsOnCall = make(map[int]struct {
			result1 db.Prototypes
			result2 error
		})
	}
	fake.prototypesReturnsOnCall[i] = struct {
		result1 db.Prototypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Public() bool {
	fake.publicMutex.Lock()
	ret, specificReturn := fake.publicReturnsOnCall[len(fake.publicArgsForCall)]
	fake.publicArgsForCall = append(fake.publicArgsForCall, struct {
	}{})
	stub := fake.PublicStub
	fakeReturns := fake.publicReturns
	fake.recordInvocation("Public", []interface{}{})
	fake.publicMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) PublicCallCount() int {
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	return len(fake.publicArgsForCall)
}

func (fake *FakePipeline) PublicCalls(stub func() bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = stub
}

func (fake *FakePipeline) PublicReturns(result1 bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = nil
	fake.publicReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PublicReturnsOnCall(i int, result1 bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = nil
	if fake.publicReturnsOnCall == nil {
		fake.publicReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.publicReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) Ref() atc.PipelineRef {
	fake.refMutex.Lock()
	ret, specificReturn := fake.refReturnsOnCall[len(fake.refArgsForCall)]
	fake.refArgsForCall = append(fake.refArgsForCall, struct {
	}{})
	stub := fake.RefStub
	fakeReturns := fake.refReturns
	fake.recordInvocation("Ref", []interface{}{})
	fake.refMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) RefCallCount() int {
	fake.refMutex.RLock()
	defer fake.refMutex.RUnlock()
	return len(fake.refArgsForCall)
}

func (fake *FakePipeline) RefCalls(stub func() atc.PipelineRef) {
	fake.refMutex.Lock()
	defer fake.refMutex.Unlock()
	fake.RefStub = stub
}

func (fake *FakePipeline) RefReturns(result1 atc.PipelineRef) {
	fake.refMutex.Lock()
	defer fake.refMutex.Unlock()
	fake.RefStub = nil
	fake.refReturns = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakePipeline) RefReturnsOnCall(i int, result1 atc.PipelineRef) {
	fake.refMutex.Lock()
	defer fake.refMutex.Unlock()
	fake.RefStub = nil
	if fake.refReturnsOnCall == nil {
		fake.refReturnsOnCall = make(map[int]struct {
			result1 atc.PipelineRef
		})
	}
	fake.refReturnsOnCall[i] = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakePipeline) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
	}{})
	stub := fake.ReloadStub
	fakeReturns := fake.reloadReturns
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakePipeline) ReloadCalls(stub func() (bool, error)) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = stub
}

func (fake *FakePipeline) ReloadReturns(result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Resource(arg1 string) (db.Resource, bool, error) {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResourceStub
	fakeReturns := fake.resourceReturns
	fake.recordInvocation("Resource", []interface{}{arg1})
	fake.resourceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakePipeline) ResourceCalls(stub func(string) (db.Resource, bool, error)) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = stub
}

func (fake *FakePipeline) ResourceArgsForCall(i int) string {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	argsForCall := fake.resourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ResourceReturns(result1 db.Resource, result2 bool, result3 error) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceReturnsOnCall(i int, result1 db.Resource, result2 bool, result3 error) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 db.Resource
			result2 bool
			result3 error
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceByID(arg1 int) (db.Resource, bool, error) {
	fake.resourceByIDMutex.Lock()
	ret, specificReturn := fake.resourceByIDReturnsOnCall[len(fake.resourceByIDArgsForCall)]
	fake.resourceByIDArgsForCall = append(fake.resourceByIDArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ResourceByIDStub
	fakeReturns := fake.resourceByIDReturns
	fake.recordInvocation("ResourceByID", []interface{}{arg1})
	fake.resourceByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) ResourceByIDCallCount() int {
	fake.resourceByIDMutex.RLock()
	defer fake.resourceByIDMutex.RUnlock()
	return len(fake.resourceByIDArgsForCall)
}

func (fake *FakePipeline) ResourceByIDCalls(stub func(int) (db.Resource, bool, error)) {
	fake.resourceByIDMutex.Lock()
	defer fake.resourceByIDMutex.Unlock()
	fake.ResourceByIDStub = stub
}

func (fake *FakePipeline) ResourceByIDArgsForCall(i int) int {
	fake.resourceByIDMutex.RLock()
	defer fake.resourceByIDMutex.RUnlock()
	argsForCall := fake.resourceByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ResourceByIDReturns(result1 db.Resource, result2 bool, result3 error) {
	fake.resourceByIDMutex.Lock()
	defer fake.resourceByIDMutex.Unlock()
	fake.ResourceByIDStub = nil
	fake.resourceByIDReturns = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceByIDReturnsOnCall(i int, result1 db.Resource, result2 bool, result3 error) {
	fake.resourceByIDMutex.Lock()
	defer fake.resourceByIDMutex.Unlock()
	fake.ResourceByIDStub = nil
	if fake.resourceByIDReturnsOnCall == nil {
		fake.resourceByIDReturnsOnCall = make(map[int]struct {
			result1 db.Resource
			result2 bool
			result3 error
		})
	}
	fake.resourceByIDReturnsOnCall[i] = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceType(arg1 string) (db.ResourceType, bool, error) {
	fake.resourceTypeMutex.Lock()
	ret, specificReturn := fake.resourceTypeReturnsOnCall[len(fake.resourceTypeArgsForCall)]
	fake.resourceTypeArgsForCall = append(fake.resourceTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResourceTypeStub
	fakeReturns := fake.resourceTypeReturns
	fake.recordInvocation("ResourceType", []interface{}{arg1})
	fake.resourceTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) ResourceTypeCallCount() int {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	return len(fake.resourceTypeArgsForCall)
}

func (fake *FakePipeline) ResourceTypeCalls(stub func(string) (db.ResourceType, bool, error)) {
	fake.resourceTypeMutex.Lock()
	defer fake.resourceTypeMutex.Unlock()
	fake.ResourceTypeStub = stub
}

func (fake *FakePipeline) ResourceTypeArgsForCall(i int) string {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	argsForCall := fake.resourceTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ResourceTypeReturns(result1 db.ResourceType, result2 bool, result3 error) {
	fake.resourceTypeMutex.Lock()
	defer fake.resourceTypeMutex.Unlock()
	fake.ResourceTypeStub = nil
	fake.resourceTypeReturns = struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypeReturnsOnCall(i int, result1 db.ResourceType, result2 bool, result3 error) {
	fake.resourceTypeMutex.Lock()
	defer fake.resourceTypeMutex.Unlock()
	fake.ResourceTypeStub = nil
	if fake.resourceTypeReturnsOnCall == nil {
		fake.resourceTypeReturnsOnCall = make(map[int]struct {
			result1 db.ResourceType
			result2 bool
			result3 error
		})
	}
	fake.resourceTypeReturnsOnCall[i] = struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypes() (db.ResourceTypes, error) {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct {
	}{})
	stub := fake.ResourceTypesStub
	fakeReturns := fake.resourceTypesReturns
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakePipeline) ResourceTypesCalls(stub func() (db.ResourceTypes, error)) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = stub
}

func (fake *FakePipeline) ResourceTypesReturns(result1 db.ResourceTypes, result2 error) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 db.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceTypesReturnsOnCall(i int, result1 db.ResourceTypes, result2 error) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 db.ResourceTypes
			result2 error
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 db.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceVersion(arg1 int) (atc.ResourceVersion, bool, error) {
	fake.resourceVersionMutex.Lock()
	ret, specificReturn := fake.resourceVersionReturnsOnCall[len(fake.resourceVersionArgsForCall)]
	fake.resourceVersionArgsForCall = append(fake.resourceVersionArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ResourceVersionStub
	fakeReturns := fake.resourceVersionReturns
	fake.recordInvocation("ResourceVersion", []interface{}{arg1})
	fake.resourceVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) ResourceVersionCallCount() int {
	fake.resourceVersionMutex.RLock()
	defer fake.resourceVersionMutex.RUnlock()
	return len(fake.resourceVersionArgsForCall)
}

func (fake *FakePipeline) ResourceVersionCalls(stub func(int) (atc.ResourceVersion, bool, error)) {
	fake.resourceVersionMutex.Lock()
	defer fake.resourceVersionMutex.Unlock()
	fake.ResourceVersionStub = stub
}

func (fake *FakePipeline) ResourceVersionArgsForCall(i int) int {
	fake.resourceVersionMutex.RLock()
	defer fake.resourceVersionMutex.RUnlock()
	argsForCall := fake.resourceVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ResourceVersionReturns(result1 atc.ResourceVersion, result2 bool, result3 error) {
	fake.resourceVersionMutex.Lock()
	defer fake.resourceVersionMutex.Unlock()
	fake.ResourceVersionStub = nil
	fake.resourceVersionReturns = struct {
		result1 atc.ResourceVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceVersionReturnsOnCall(i int, result1 atc.ResourceVersion, result2 bool, result3 error) {
	fake.resourceVersionMutex.Lock()
	defer fake.resourceVersionMutex.Unlock()
	fake.ResourceVersionStub = nil
	if fake.resourceVersionReturnsOnCall == nil {
		fake.resourceVersionReturnsOnCall = make(map[int]struct {
			result1 atc.ResourceVersion
			result2 bool
			result3 error
		})
	}
	fake.resourceVersionReturnsOnCall[i] = struct {
		result1 atc.ResourceVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Resources() (db.Resources, error) {
	fake.resourcesMutex.Lock()
	ret, specificReturn := fake.resourcesReturnsOnCall[len(fake.resourcesArgsForCall)]
	fake.resourcesArgsForCall = append(fake.resourcesArgsForCall, struct {
	}{})
	stub := fake.ResourcesStub
	fakeReturns := fake.resourcesReturns
	fake.recordInvocation("Resources", []interface{}{})
	fake.resourcesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ResourcesCallCount() int {
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	return len(fake.resourcesArgsForCall)
}

func (fake *FakePipeline) ResourcesCalls(stub func() (db.Resources, error)) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = stub
}

func (fake *FakePipeline) ResourcesReturns(result1 db.Resources, result2 error) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = nil
	fake.resourcesReturns = struct {
		result1 db.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourcesReturnsOnCall(i int, result1 db.Resources, result2 error) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = nil
	if fake.resourcesReturnsOnCall == nil {
		fake.resourcesReturnsOnCall = make(map[int]struct {
			result1 db.Resources
			result2 error
		})
	}
	fake.resourcesReturnsOnCall[i] = struct {
		result1 db.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) SetParentIDs(arg1 int, arg2 int) error {
	fake.setParentIDsMutex.Lock()
	ret, specificReturn := fake.setParentIDsReturnsOnCall[len(fake.setParentIDsArgsForCall)]
	fake.setParentIDsArgsForCall = append(fake.setParentIDsArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.SetParentIDsStub
	fakeReturns := fake.setParentIDsReturns
	fake.recordInvocation("SetParentIDs", []interface{}{arg1, arg2})
	fake.setParentIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) SetParentIDsCallCount() int {
	fake.setParentIDsMutex.RLock()
	defer fake.setParentIDsMutex.RUnlock()
	return len(fake.setParentIDsArgsForCall)
}

func (fake *FakePipeline) SetParentIDsCalls(stub func(int, int) error) {
	fake.setParentIDsMutex.Lock()
	defer fake.setParentIDsMutex.Unlock()
	fake.SetParentIDsStub = stub
}

func (fake *FakePipeline) SetParentIDsArgsForCall(i int) (int, int) {
	fake.setParentIDsMutex.RLock()
	defer fake.setParentIDsMutex.RUnlock()
	argsForCall := fake.setParentIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) SetParentIDsReturns(result1 error) {
	fake.setParentIDsMutex.Lock()
	defer fake.setParentIDsMutex.Unlock()
	fake.SetParentIDsStub = nil
	fake.setParentIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SetParentIDsReturnsOnCall(i int, result1 error) {
	fake.setParentIDsMutex.Lock()
	defer fake.setParentIDsMutex.Unlock()
	fake.SetParentIDsStub = nil
	if fake.setParentIDsReturnsOnCall == nil {
		fake.setParentIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setParentIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	stub := fake.TeamIDStub
	fakeReturns := fake.teamIDReturns
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakePipeline) TeamIDCalls(stub func() int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = stub
}

func (fake *FakePipeline) TeamIDReturns(result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamIDReturnsOnCall(i int, result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	stub := fake.TeamNameStub
	fakeReturns := fake.teamNameReturns
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakePipeline) TeamNameCalls(stub func() string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = stub
}

func (fake *FakePipeline) TeamNameReturns(result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) TeamNameReturnsOnCall(i int, result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) Unpause() error {
	fake.unpauseMutex.Lock()
	ret, specificReturn := fake.unpauseReturnsOnCall[len(fake.unpauseArgsForCall)]
	fake.unpauseArgsForCall = append(fake.unpauseArgsForCall, struct {
	}{})
	stub := fake.UnpauseStub
	fakeReturns := fake.unpauseReturns
	fake.recordInvocation("Unpause", []interface{}{})
	fake.unpauseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) UnpauseCallCount() int {
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	return len(fake.unpauseArgsForCall)
}

func (fake *FakePipeline) UnpauseCalls(stub func() error) {
	fake.unpauseMutex.Lock()
	defer fake.unpauseMutex.Unlock()
	fake.UnpauseStub = stub
}

func (fake *FakePipeline) UnpauseReturns(result1 error) {
	fake.unpauseMutex.Lock()
	defer fake.unpauseMutex.Unlock()
	fake.UnpauseStub = nil
	fake.unpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) UnpauseReturnsOnCall(i int, result1 error) {
	fake.unpauseMutex.Lock()
	defer fake.unpauseMutex.Unlock()
	fake.UnpauseStub = nil
	if fake.unpauseReturnsOnCall == nil {
		fake.unpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) VarSources() atc.VarSourceConfigs {
	fake.varSourcesMutex.Lock()
	ret, specificReturn := fake.varSourcesReturnsOnCall[len(fake.varSourcesArgsForCall)]
	fake.varSourcesArgsForCall = append(fake.varSourcesArgsForCall, struct {
	}{})
	stub := fake.VarSourcesStub
	fakeReturns := fake.varSourcesReturns
	fake.recordInvocation("VarSources", []interface{}{})
	fake.varSourcesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePipeline) VarSourcesCallCount() int {
	fake.varSourcesMutex.RLock()
	defer fake.varSourcesMutex.RUnlock()
	return len(fake.varSourcesArgsForCall)
}

func (fake *FakePipeline) VarSourcesCalls(stub func() atc.VarSourceConfigs) {
	fake.varSourcesMutex.Lock()
	defer fake.varSourcesMutex.Unlock()
	fake.VarSourcesStub = stub
}

func (fake *FakePipeline) VarSourcesReturns(result1 atc.VarSourceConfigs) {
	fake.varSourcesMutex.Lock()
	defer fake.varSourcesMutex.Unlock()
	fake.VarSourcesStub = nil
	fake.varSourcesReturns = struct {
		result1 atc.VarSourceConfigs
	}{result1}
}

func (fake *FakePipeline) VarSourcesReturnsOnCall(i int, result1 atc.VarSourceConfigs) {
	fake.varSourcesMutex.Lock()
	defer fake.varSourcesMutex.Unlock()
	fake.VarSourcesStub = nil
	if fake.varSourcesReturnsOnCall == nil {
		fake.varSourcesReturnsOnCall = make(map[int]struct {
			result1 atc.VarSourceConfigs
		})
	}
	fake.varSourcesReturnsOnCall[i] = struct {
		result1 atc.VarSourceConfigs
	}{result1}
}

func (fake *FakePipeline) Variables(arg1 lager.Logger, arg2 creds.Secrets, arg3 creds.VarSourcePool) (vars.Variables, error) {
	fake.variablesMutex.Lock()
	ret, specificReturn := fake.variablesReturnsOnCall[len(fake.variablesArgsForCall)]
	fake.variablesArgsForCall = append(fake.variablesArgsForCall, struct {
		arg1 lager.Logger
		arg2 creds.Secrets
		arg3 creds.VarSourcePool
	}{arg1, arg2, arg3})
	stub := fake.VariablesStub
	fakeReturns := fake.variablesReturns
	fake.recordInvocation("Variables", []interface{}{arg1, arg2, arg3})
	fake.variablesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) VariablesCallCount() int {
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	return len(fake.variablesArgsForCall)
}

func (fake *FakePipeline) VariablesCalls(stub func(lager.Logger, creds.Secrets, creds.VarSourcePool) (vars.Variables, error)) {
	fake.variablesMutex.Lock()
	defer fake.variablesMutex.Unlock()
	fake.VariablesStub = stub
}

func (fake *FakePipeline) VariablesArgsForCall(i int) (lager.Logger, creds.Secrets, creds.VarSourcePool) {
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	argsForCall := fake.variablesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePipeline) VariablesReturns(result1 vars.Variables, result2 error) {
	fake.variablesMutex.Lock()
	defer fake.variablesMutex.Unlock()
	fake.VariablesStub = nil
	fake.variablesReturns = struct {
		result1 vars.Variables
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) VariablesReturnsOnCall(i int, result1 vars.Variables, result2 error) {
	fake.variablesMutex.Lock()
	defer fake.variablesMutex.Unlock()
	fake.VariablesStub = nil
	if fake.variablesReturnsOnCall == nil {
		fake.variablesReturnsOnCall = make(map[int]struct {
			result1 vars.Variables
			result2 error
		})
	}
	fake.variablesReturnsOnCall[i] = struct {
		result1 vars.Variables
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.archiveMutex.RLock()
	defer fake.archiveMutex.RUnlock()
	fake.archivedMutex.RLock()
	defer fake.archivedMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	fake.createStartedBuildMutex.RLock()
	defer fake.createStartedBuildMutex.RUnlock()
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.displayMutex.RLock()
	defer fake.displayMutex.RUnlock()
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	fake.groupsMutex.RLock()
	defer fake.groupsMutex.RUnlock()
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.instanceVarsMutex.RLock()
	defer fake.instanceVarsMutex.RUnlock()
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	fake.lastUpdatedMutex.RLock()
	defer fake.lastUpdatedMutex.RUnlock()
	fake.loadDebugVersionsDBMutex.RLock()
	defer fake.loadDebugVersionsDBMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.parentBuildIDMutex.RLock()
	defer fake.parentBuildIDMutex.RUnlock()
	fake.parentJobIDMutex.RLock()
	defer fake.parentJobIDMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	fake.pausedAtMutex.RLock()
	defer fake.pausedAtMutex.RUnlock()
	fake.pausedByMutex.RLock()
	defer fake.pausedByMutex.RUnlock()
	fake.prototypeMutex.RLock()
	defer fake.prototypeMutex.RUnlock()
	fake.prototypesMutex.RLock()
	defer fake.prototypesMutex.RUnlock()
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	fake.refMutex.RLock()
	defer fake.refMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.resourceByIDMutex.RLock()
	defer fake.resourceByIDMutex.RUnlock()
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.resourceVersionMutex.RLock()
	defer fake.resourceVersionMutex.RUnlock()
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	fake.setParentIDsMutex.RLock()
	defer fake.setParentIDsMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	fake.varSourcesMutex.RLock()
	defer fake.varSourcesMutex.RUnlock()
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePipeline) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Pipeline = new(FakePipeline)
