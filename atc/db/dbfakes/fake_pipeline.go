// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	sync "sync"
	time "time"

	lager "code.cloudfoundry.org/lager"
	atc "github.com/concourse/concourse/atc"
	db "github.com/concourse/concourse/atc/db"
	algorithm "github.com/concourse/concourse/atc/db/algorithm"
	lock "github.com/concourse/concourse/atc/db/lock"
)

type FakePipeline struct {
	AcquireResourceCheckingLockWithIntervalCheckStub        func(lager.Logger, string, db.ResourceConfig, time.Duration, bool) (lock.Lock, bool, error)
	acquireResourceCheckingLockWithIntervalCheckMutex       sync.RWMutex
	acquireResourceCheckingLockWithIntervalCheckArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 db.ResourceConfig
		arg4 time.Duration
		arg5 bool
	}
	acquireResourceCheckingLockWithIntervalCheckReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceCheckingLockWithIntervalCheckReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AcquireResourceTypeCheckingLockWithIntervalCheckStub        func(lager.Logger, string, db.ResourceConfig, time.Duration, bool) (lock.Lock, bool, error)
	acquireResourceTypeCheckingLockWithIntervalCheckMutex       sync.RWMutex
	acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 db.ResourceConfig
		arg4 time.Duration
		arg5 bool
	}
	acquireResourceTypeCheckingLockWithIntervalCheckReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AcquireSchedulingLockStub        func(lager.Logger, time.Duration) (lock.Lock, bool, error)
	acquireSchedulingLockMutex       sync.RWMutex
	acquireSchedulingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	acquireSchedulingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireSchedulingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	ArchiveStub        func() error
	archiveMutex       sync.RWMutex
	archiveArgsForCall []struct {
	}
	archiveReturns struct {
		result1 error
	}
	archiveReturnsOnCall map[int]struct {
		result1 error
	}
	ArchivedStub        func() bool
	archivedMutex       sync.RWMutex
	archivedArgsForCall []struct {
	}
	archivedReturns struct {
		result1 bool
	}
	archivedReturnsOnCall map[int]struct {
		result1 bool
	}
	BuildsStub        func(db.Page) ([]db.Build, db.Pagination, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		arg1 db.Page
	}
	buildsReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	CausalityStub        func(int) ([]db.Cause, error)
	causalityMutex       sync.RWMutex
	causalityArgsForCall []struct {
		arg1 int
	}
	causalityReturns struct {
		result1 []db.Cause
		result2 error
	}
	causalityReturnsOnCall map[int]struct {
		result1 []db.Cause
		result2 error
	}
	CheckPausedStub        func() (bool, error)
	checkPausedMutex       sync.RWMutex
	checkPausedArgsForCall []struct {
	}
	checkPausedReturns struct {
		result1 bool
		result2 error
	}
	checkPausedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ConfigVersionStub        func() db.ConfigVersion
	configVersionMutex       sync.RWMutex
	configVersionArgsForCall []struct {
	}
	configVersionReturns struct {
		result1 db.ConfigVersion
	}
	configVersionReturnsOnCall map[int]struct {
		result1 db.ConfigVersion
	}
	CreateOneOffBuildStub        func() (db.Build, error)
	createOneOffBuildMutex       sync.RWMutex
	createOneOffBuildArgsForCall []struct {
	}
	createOneOffBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createOneOffBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	DashboardStub        func() (db.Dashboard, error)
	dashboardMutex       sync.RWMutex
	dashboardArgsForCall []struct {
	}
	dashboardReturns struct {
		result1 db.Dashboard
		result2 error
	}
	dashboardReturnsOnCall map[int]struct {
		result1 db.Dashboard
		result2 error
	}
	DeleteBuildEventsByBuildIDsStub        func([]int) error
	deleteBuildEventsByBuildIDsMutex       sync.RWMutex
	deleteBuildEventsByBuildIDsArgsForCall []struct {
		arg1 []int
	}
	deleteBuildEventsByBuildIDsReturns struct {
		result1 error
	}
	deleteBuildEventsByBuildIDsReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	DisableVersionedResourceStub        func(int) error
	disableVersionedResourceMutex       sync.RWMutex
	disableVersionedResourceArgsForCall []struct {
		arg1 int
	}
	disableVersionedResourceReturns struct {
		result1 error
	}
	disableVersionedResourceReturnsOnCall map[int]struct {
		result1 error
	}
	EnableVersionedResourceStub        func(int) error
	enableVersionedResourceMutex       sync.RWMutex
	enableVersionedResourceArgsForCall []struct {
		arg1 int
	}
	enableVersionedResourceReturns struct {
		result1 error
	}
	enableVersionedResourceReturnsOnCall map[int]struct {
		result1 error
	}
	ExposeStub        func() error
	exposeMutex       sync.RWMutex
	exposeArgsForCall []struct {
	}
	exposeReturns struct {
		result1 error
	}
	exposeReturnsOnCall map[int]struct {
		result1 error
	}
	GetAllPendingBuildsStub        func() (map[string][]db.Build, error)
	getAllPendingBuildsMutex       sync.RWMutex
	getAllPendingBuildsArgsForCall []struct {
	}
	getAllPendingBuildsReturns struct {
		result1 map[string][]db.Build
		result2 error
	}
	getAllPendingBuildsReturnsOnCall map[int]struct {
		result1 map[string][]db.Build
		result2 error
	}
	GetBuildsWithVersionAsInputStub        func(int) ([]db.Build, error)
	getBuildsWithVersionAsInputMutex       sync.RWMutex
	getBuildsWithVersionAsInputArgsForCall []struct {
		arg1 int
	}
	getBuildsWithVersionAsInputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsInputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	GetBuildsWithVersionAsOutputStub        func(int) ([]db.Build, error)
	getBuildsWithVersionAsOutputMutex       sync.RWMutex
	getBuildsWithVersionAsOutputArgsForCall []struct {
		arg1 int
	}
	getBuildsWithVersionAsOutputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsOutputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	GetLatestVersionedResourceStub        func(string) (db.SavedVersionedResource, bool, error)
	getLatestVersionedResourceMutex       sync.RWMutex
	getLatestVersionedResourceArgsForCall []struct {
		arg1 string
	}
	getLatestVersionedResourceReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	getLatestVersionedResourceReturnsOnCall map[int]struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	GetResourceVersionsStub        func(string, db.Page) ([]db.SavedVersionedResource, db.Pagination, bool, error)
	getResourceVersionsMutex       sync.RWMutex
	getResourceVersionsArgsForCall []struct {
		arg1 string
		arg2 db.Page
	}
	getResourceVersionsReturns struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}
	getResourceVersionsReturnsOnCall map[int]struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}
	GetVersionedResourceByVersionStub        func(atc.Version, string) (db.SavedVersionedResource, bool, error)
	getVersionedResourceByVersionMutex       sync.RWMutex
	getVersionedResourceByVersionArgsForCall []struct {
		arg1 atc.Version
		arg2 string
	}
	getVersionedResourceByVersionReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	getVersionedResourceByVersionReturnsOnCall map[int]struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	GroupsStub        func() atc.GroupConfigs
	groupsMutex       sync.RWMutex
	groupsArgsForCall []struct {
	}
	groupsReturns struct {
		result1 atc.GroupConfigs
	}
	groupsReturnsOnCall map[int]struct {
		result1 atc.GroupConfigs
	}
	HideStub        func() error
	hideMutex       sync.RWMutex
	hideArgsForCall []struct {
	}
	hideReturns struct {
		result1 error
	}
	hideReturnsOnCall map[int]struct {
		result1 error
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	JobStub        func(string) (db.Job, bool, error)
	jobMutex       sync.RWMutex
	jobArgsForCall []struct {
		arg1 string
	}
	jobReturns struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	jobReturnsOnCall map[int]struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	JobsStub        func() (db.Jobs, error)
	jobsMutex       sync.RWMutex
	jobsArgsForCall []struct {
	}
	jobsReturns struct {
		result1 db.Jobs
		result2 error
	}
	jobsReturnsOnCall map[int]struct {
		result1 db.Jobs
		result2 error
	}
	LoadVersionsDBStub        func() (*algorithm.VersionsDB, error)
	loadVersionsDBMutex       sync.RWMutex
	loadVersionsDBArgsForCall []struct {
	}
	loadVersionsDBReturns struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	loadVersionsDBReturnsOnCall map[int]struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct {
	}
	pauseReturns struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	PausedStub        func() bool
	pausedMutex       sync.RWMutex
	pausedArgsForCall []struct {
	}
	pausedReturns struct {
		result1 bool
	}
	pausedReturnsOnCall map[int]struct {
		result1 bool
	}
	PublicStub        func() bool
	publicMutex       sync.RWMutex
	publicArgsForCall []struct {
	}
	publicReturns struct {
		result1 bool
	}
	publicReturnsOnCall map[int]struct {
		result1 bool
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
	}
	reloadReturns struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RenameStub        func(string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	ResourceStub        func(string) (db.Resource, bool, error)
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
		arg1 string
	}
	resourceReturns struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	resourceReturnsOnCall map[int]struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	ResourceTypeStub        func(string) (db.ResourceType, bool, error)
	resourceTypeMutex       sync.RWMutex
	resourceTypeArgsForCall []struct {
		arg1 string
	}
	resourceTypeReturns struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}
	resourceTypeReturnsOnCall map[int]struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}
	ResourceTypesStub        func() (db.ResourceTypes, error)
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct {
	}
	resourceTypesReturns struct {
		result1 db.ResourceTypes
		result2 error
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 db.ResourceTypes
		result2 error
	}
	ResourcesStub        func() (db.Resources, error)
	resourcesMutex       sync.RWMutex
	resourcesArgsForCall []struct {
	}
	resourcesReturns struct {
		result1 db.Resources
		result2 error
	}
	resourcesReturnsOnCall map[int]struct {
		result1 db.Resources
		result2 error
	}
	SaveResourceVersionsStub        func(atc.ResourceConfig, []atc.Version) error
	saveResourceVersionsMutex       sync.RWMutex
	saveResourceVersionsArgsForCall []struct {
		arg1 atc.ResourceConfig
		arg2 []atc.Version
	}
	saveResourceVersionsReturns struct {
		result1 error
	}
	saveResourceVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	ScopedNameStub        func(string) string
	scopedNameMutex       sync.RWMutex
	scopedNameArgsForCall []struct {
		arg1 string
	}
	scopedNameReturns struct {
		result1 string
	}
	scopedNameReturnsOnCall map[int]struct {
		result1 string
	}
	SetResourceCheckErrorStub        func(db.Resource, error) error
	setResourceCheckErrorMutex       sync.RWMutex
	setResourceCheckErrorArgsForCall []struct {
		arg1 db.Resource
		arg2 error
	}
	setResourceCheckErrorReturns struct {
		result1 error
	}
	setResourceCheckErrorReturnsOnCall map[int]struct {
		result1 error
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	UnarchiveStub        func() error
	unarchiveMutex       sync.RWMutex
	unarchiveArgsForCall []struct {
	}
	unarchiveReturns struct {
		result1 error
	}
	unarchiveReturnsOnCall map[int]struct {
		result1 error
	}
	UnpauseStub        func() error
	unpauseMutex       sync.RWMutex
	unpauseArgsForCall []struct {
	}
	unpauseReturns struct {
		result1 error
	}
	unpauseReturnsOnCall map[int]struct {
		result1 error
	}
	VersionedResourceStub        func(int) (db.SavedVersionedResource, bool, error)
	versionedResourceMutex       sync.RWMutex
	versionedResourceArgsForCall []struct {
		arg1 int
	}
	versionedResourceReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	versionedResourceReturnsOnCall map[int]struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheck(arg1 lager.Logger, arg2 string, arg3 db.ResourceConfig, arg4 time.Duration, arg5 bool) (lock.Lock, bool, error) {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.Lock()
	ret, specificReturn := fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall[len(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall)]
	fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall = append(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 db.ResourceConfig
		arg4 time.Duration
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("AcquireResourceCheckingLockWithIntervalCheck", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.Unlock()
	if fake.AcquireResourceCheckingLockWithIntervalCheckStub != nil {
		return fake.AcquireResourceCheckingLockWithIntervalCheckStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireResourceCheckingLockWithIntervalCheckReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckCallCount() int {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	return len(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall)
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckArgsForCall(i int) (lager.Logger, string, db.ResourceConfig, time.Duration, bool) {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	argsForCall := fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockWithIntervalCheckStub = nil
	fake.acquireResourceCheckingLockWithIntervalCheckReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockWithIntervalCheckStub = nil
	if fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall == nil {
		fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheck(arg1 lager.Logger, arg2 string, arg3 db.ResourceConfig, arg4 time.Duration, arg5 bool) (lock.Lock, bool, error) {
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.Lock()
	ret, specificReturn := fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall[len(fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall)]
	fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall = append(fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 db.ResourceConfig
		arg4 time.Duration
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("AcquireResourceTypeCheckingLockWithIntervalCheck", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.Unlock()
	if fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub != nil {
		return fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckCallCount() int {
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RUnlock()
	return len(fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall)
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckArgsForCall(i int) (lager.Logger, string, db.ResourceConfig, time.Duration, bool) {
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RUnlock()
	argsForCall := fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub = nil
	fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub = nil
	if fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall == nil {
		fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireSchedulingLock(arg1 lager.Logger, arg2 time.Duration) (lock.Lock, bool, error) {
	fake.acquireSchedulingLockMutex.Lock()
	ret, specificReturn := fake.acquireSchedulingLockReturnsOnCall[len(fake.acquireSchedulingLockArgsForCall)]
	fake.acquireSchedulingLockArgsForCall = append(fake.acquireSchedulingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("AcquireSchedulingLock", []interface{}{arg1, arg2})
	fake.acquireSchedulingLockMutex.Unlock()
	if fake.AcquireSchedulingLockStub != nil {
		return fake.AcquireSchedulingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireSchedulingLockReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) AcquireSchedulingLockCallCount() int {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return len(fake.acquireSchedulingLockArgsForCall)
}

func (fake *FakePipeline) AcquireSchedulingLockArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	argsForCall := fake.acquireSchedulingLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) AcquireSchedulingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireSchedulingLockStub = nil
	fake.acquireSchedulingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireSchedulingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireSchedulingLockStub = nil
	if fake.acquireSchedulingLockReturnsOnCall == nil {
		fake.acquireSchedulingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireSchedulingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Archive() error {
	fake.archiveMutex.Lock()
	ret, specificReturn := fake.archiveReturnsOnCall[len(fake.archiveArgsForCall)]
	fake.archiveArgsForCall = append(fake.archiveArgsForCall, struct {
	}{})
	fake.recordInvocation("Archive", []interface{}{})
	fake.archiveMutex.Unlock()
	if fake.ArchiveStub != nil {
		return fake.ArchiveStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.archiveReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) ArchiveCallCount() int {
	fake.archiveMutex.RLock()
	defer fake.archiveMutex.RUnlock()
	return len(fake.archiveArgsForCall)
}

func (fake *FakePipeline) ArchiveReturns(result1 error) {
	fake.ArchiveStub = nil
	fake.archiveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ArchiveReturnsOnCall(i int, result1 error) {
	fake.ArchiveStub = nil
	if fake.archiveReturnsOnCall == nil {
		fake.archiveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.archiveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Archived() bool {
	fake.archivedMutex.Lock()
	ret, specificReturn := fake.archivedReturnsOnCall[len(fake.archivedArgsForCall)]
	fake.archivedArgsForCall = append(fake.archivedArgsForCall, struct {
	}{})
	fake.recordInvocation("Archived", []interface{}{})
	fake.archivedMutex.Unlock()
	if fake.ArchivedStub != nil {
		return fake.ArchivedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.archivedReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) ArchivedCallCount() int {
	fake.archivedMutex.RLock()
	defer fake.archivedMutex.RUnlock()
	return len(fake.archivedArgsForCall)
}

func (fake *FakePipeline) ArchivedReturns(result1 bool) {
	fake.ArchivedStub = nil
	fake.archivedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) ArchivedReturnsOnCall(i int, result1 bool) {
	fake.ArchivedStub = nil
	if fake.archivedReturnsOnCall == nil {
		fake.archivedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.archivedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) Builds(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	fake.recordInvocation("Builds", []interface{}{arg1})
	fake.buildsMutex.Unlock()
	if fake.BuildsStub != nil {
		return fake.BuildsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakePipeline) BuildsArgsForCall(i int) db.Page {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	argsForCall := fake.buildsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) BuildsReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) BuildsReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Causality(arg1 int) ([]db.Cause, error) {
	fake.causalityMutex.Lock()
	ret, specificReturn := fake.causalityReturnsOnCall[len(fake.causalityArgsForCall)]
	fake.causalityArgsForCall = append(fake.causalityArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Causality", []interface{}{arg1})
	fake.causalityMutex.Unlock()
	if fake.CausalityStub != nil {
		return fake.CausalityStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.causalityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CausalityCallCount() int {
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	return len(fake.causalityArgsForCall)
}

func (fake *FakePipeline) CausalityArgsForCall(i int) int {
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	argsForCall := fake.causalityArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) CausalityReturns(result1 []db.Cause, result2 error) {
	fake.CausalityStub = nil
	fake.causalityReturns = struct {
		result1 []db.Cause
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CausalityReturnsOnCall(i int, result1 []db.Cause, result2 error) {
	fake.CausalityStub = nil
	if fake.causalityReturnsOnCall == nil {
		fake.causalityReturnsOnCall = make(map[int]struct {
			result1 []db.Cause
			result2 error
		})
	}
	fake.causalityReturnsOnCall[i] = struct {
		result1 []db.Cause
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CheckPaused() (bool, error) {
	fake.checkPausedMutex.Lock()
	ret, specificReturn := fake.checkPausedReturnsOnCall[len(fake.checkPausedArgsForCall)]
	fake.checkPausedArgsForCall = append(fake.checkPausedArgsForCall, struct {
	}{})
	fake.recordInvocation("CheckPaused", []interface{}{})
	fake.checkPausedMutex.Unlock()
	if fake.CheckPausedStub != nil {
		return fake.CheckPausedStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.checkPausedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CheckPausedCallCount() int {
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	return len(fake.checkPausedArgsForCall)
}

func (fake *FakePipeline) CheckPausedReturns(result1 bool, result2 error) {
	fake.CheckPausedStub = nil
	fake.checkPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CheckPausedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CheckPausedStub = nil
	if fake.checkPausedReturnsOnCall == nil {
		fake.checkPausedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkPausedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ConfigVersion() db.ConfigVersion {
	fake.configVersionMutex.Lock()
	ret, specificReturn := fake.configVersionReturnsOnCall[len(fake.configVersionArgsForCall)]
	fake.configVersionArgsForCall = append(fake.configVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("ConfigVersion", []interface{}{})
	fake.configVersionMutex.Unlock()
	if fake.ConfigVersionStub != nil {
		return fake.ConfigVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configVersionReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) ConfigVersionCallCount() int {
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	return len(fake.configVersionArgsForCall)
}

func (fake *FakePipeline) ConfigVersionReturns(result1 db.ConfigVersion) {
	fake.ConfigVersionStub = nil
	fake.configVersionReturns = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) ConfigVersionReturnsOnCall(i int, result1 db.ConfigVersion) {
	fake.ConfigVersionStub = nil
	if fake.configVersionReturnsOnCall == nil {
		fake.configVersionReturnsOnCall = make(map[int]struct {
			result1 db.ConfigVersion
		})
	}
	fake.configVersionReturnsOnCall[i] = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) CreateOneOffBuild() (db.Build, error) {
	fake.createOneOffBuildMutex.Lock()
	ret, specificReturn := fake.createOneOffBuildReturnsOnCall[len(fake.createOneOffBuildArgsForCall)]
	fake.createOneOffBuildArgsForCall = append(fake.createOneOffBuildArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateOneOffBuild", []interface{}{})
	fake.createOneOffBuildMutex.Unlock()
	if fake.CreateOneOffBuildStub != nil {
		return fake.CreateOneOffBuildStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createOneOffBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CreateOneOffBuildCallCount() int {
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	return len(fake.createOneOffBuildArgsForCall)
}

func (fake *FakePipeline) CreateOneOffBuildReturns(result1 db.Build, result2 error) {
	fake.CreateOneOffBuildStub = nil
	fake.createOneOffBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateOneOffBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.CreateOneOffBuildStub = nil
	if fake.createOneOffBuildReturnsOnCall == nil {
		fake.createOneOffBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createOneOffBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Dashboard() (db.Dashboard, error) {
	fake.dashboardMutex.Lock()
	ret, specificReturn := fake.dashboardReturnsOnCall[len(fake.dashboardArgsForCall)]
	fake.dashboardArgsForCall = append(fake.dashboardArgsForCall, struct {
	}{})
	fake.recordInvocation("Dashboard", []interface{}{})
	fake.dashboardMutex.Unlock()
	if fake.DashboardStub != nil {
		return fake.DashboardStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.dashboardReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) DashboardCallCount() int {
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	return len(fake.dashboardArgsForCall)
}

func (fake *FakePipeline) DashboardReturns(result1 db.Dashboard, result2 error) {
	fake.DashboardStub = nil
	fake.dashboardReturns = struct {
		result1 db.Dashboard
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) DashboardReturnsOnCall(i int, result1 db.Dashboard, result2 error) {
	fake.DashboardStub = nil
	if fake.dashboardReturnsOnCall == nil {
		fake.dashboardReturnsOnCall = make(map[int]struct {
			result1 db.Dashboard
			result2 error
		})
	}
	fake.dashboardReturnsOnCall[i] = struct {
		result1 db.Dashboard
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDs(arg1 []int) error {
	var arg1Copy []int
	if arg1 != nil {
		arg1Copy = make([]int, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	ret, specificReturn := fake.deleteBuildEventsByBuildIDsReturnsOnCall[len(fake.deleteBuildEventsByBuildIDsArgsForCall)]
	fake.deleteBuildEventsByBuildIDsArgsForCall = append(fake.deleteBuildEventsByBuildIDsArgsForCall, struct {
		arg1 []int
	}{arg1Copy})
	fake.recordInvocation("DeleteBuildEventsByBuildIDs", []interface{}{arg1Copy})
	fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	if fake.DeleteBuildEventsByBuildIDsStub != nil {
		return fake.DeleteBuildEventsByBuildIDsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteBuildEventsByBuildIDsReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsCallCount() int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	return len(fake.deleteBuildEventsByBuildIDsArgsForCall)
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsArgsForCall(i int) []int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	argsForCall := fake.deleteBuildEventsByBuildIDsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturns(result1 error) {
	fake.DeleteBuildEventsByBuildIDsStub = nil
	fake.deleteBuildEventsByBuildIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturnsOnCall(i int, result1 error) {
	fake.DeleteBuildEventsByBuildIDsStub = nil
	if fake.deleteBuildEventsByBuildIDsReturnsOnCall == nil {
		fake.deleteBuildEventsByBuildIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBuildEventsByBuildIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
	}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.destroyReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakePipeline) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DestroyReturnsOnCall(i int, result1 error) {
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DisableVersionedResource(arg1 int) error {
	fake.disableVersionedResourceMutex.Lock()
	ret, specificReturn := fake.disableVersionedResourceReturnsOnCall[len(fake.disableVersionedResourceArgsForCall)]
	fake.disableVersionedResourceArgsForCall = append(fake.disableVersionedResourceArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("DisableVersionedResource", []interface{}{arg1})
	fake.disableVersionedResourceMutex.Unlock()
	if fake.DisableVersionedResourceStub != nil {
		return fake.DisableVersionedResourceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.disableVersionedResourceReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) DisableVersionedResourceCallCount() int {
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	return len(fake.disableVersionedResourceArgsForCall)
}

func (fake *FakePipeline) DisableVersionedResourceArgsForCall(i int) int {
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	argsForCall := fake.disableVersionedResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) DisableVersionedResourceReturns(result1 error) {
	fake.DisableVersionedResourceStub = nil
	fake.disableVersionedResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DisableVersionedResourceReturnsOnCall(i int, result1 error) {
	fake.DisableVersionedResourceStub = nil
	if fake.disableVersionedResourceReturnsOnCall == nil {
		fake.disableVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disableVersionedResourceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) EnableVersionedResource(arg1 int) error {
	fake.enableVersionedResourceMutex.Lock()
	ret, specificReturn := fake.enableVersionedResourceReturnsOnCall[len(fake.enableVersionedResourceArgsForCall)]
	fake.enableVersionedResourceArgsForCall = append(fake.enableVersionedResourceArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("EnableVersionedResource", []interface{}{arg1})
	fake.enableVersionedResourceMutex.Unlock()
	if fake.EnableVersionedResourceStub != nil {
		return fake.EnableVersionedResourceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.enableVersionedResourceReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) EnableVersionedResourceCallCount() int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	return len(fake.enableVersionedResourceArgsForCall)
}

func (fake *FakePipeline) EnableVersionedResourceArgsForCall(i int) int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	argsForCall := fake.enableVersionedResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) EnableVersionedResourceReturns(result1 error) {
	fake.EnableVersionedResourceStub = nil
	fake.enableVersionedResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) EnableVersionedResourceReturnsOnCall(i int, result1 error) {
	fake.EnableVersionedResourceStub = nil
	if fake.enableVersionedResourceReturnsOnCall == nil {
		fake.enableVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableVersionedResourceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Expose() error {
	fake.exposeMutex.Lock()
	ret, specificReturn := fake.exposeReturnsOnCall[len(fake.exposeArgsForCall)]
	fake.exposeArgsForCall = append(fake.exposeArgsForCall, struct {
	}{})
	fake.recordInvocation("Expose", []interface{}{})
	fake.exposeMutex.Unlock()
	if fake.ExposeStub != nil {
		return fake.ExposeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.exposeReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) ExposeCallCount() int {
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	return len(fake.exposeArgsForCall)
}

func (fake *FakePipeline) ExposeReturns(result1 error) {
	fake.ExposeStub = nil
	fake.exposeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ExposeReturnsOnCall(i int, result1 error) {
	fake.ExposeStub = nil
	if fake.exposeReturnsOnCall == nil {
		fake.exposeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exposeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetAllPendingBuilds() (map[string][]db.Build, error) {
	fake.getAllPendingBuildsMutex.Lock()
	ret, specificReturn := fake.getAllPendingBuildsReturnsOnCall[len(fake.getAllPendingBuildsArgsForCall)]
	fake.getAllPendingBuildsArgsForCall = append(fake.getAllPendingBuildsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetAllPendingBuilds", []interface{}{})
	fake.getAllPendingBuildsMutex.Unlock()
	if fake.GetAllPendingBuildsStub != nil {
		return fake.GetAllPendingBuildsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAllPendingBuildsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) GetAllPendingBuildsCallCount() int {
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	return len(fake.getAllPendingBuildsArgsForCall)
}

func (fake *FakePipeline) GetAllPendingBuildsReturns(result1 map[string][]db.Build, result2 error) {
	fake.GetAllPendingBuildsStub = nil
	fake.getAllPendingBuildsReturns = struct {
		result1 map[string][]db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetAllPendingBuildsReturnsOnCall(i int, result1 map[string][]db.Build, result2 error) {
	fake.GetAllPendingBuildsStub = nil
	if fake.getAllPendingBuildsReturnsOnCall == nil {
		fake.getAllPendingBuildsReturnsOnCall = make(map[int]struct {
			result1 map[string][]db.Build
			result2 error
		})
	}
	fake.getAllPendingBuildsReturnsOnCall[i] = struct {
		result1 map[string][]db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInput(arg1 int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsInputReturnsOnCall[len(fake.getBuildsWithVersionAsInputArgsForCall)]
	fake.getBuildsWithVersionAsInputArgsForCall = append(fake.getBuildsWithVersionAsInputArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetBuildsWithVersionAsInput", []interface{}{arg1})
	fake.getBuildsWithVersionAsInputMutex.Unlock()
	if fake.GetBuildsWithVersionAsInputStub != nil {
		return fake.GetBuildsWithVersionAsInputStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBuildsWithVersionAsInputReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputCallCount() int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsInputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	argsForCall := fake.getBuildsWithVersionAsInputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturns(result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsInputStub = nil
	fake.getBuildsWithVersionAsInputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsInputStub = nil
	if fake.getBuildsWithVersionAsInputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsInputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsInputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutput(arg1 int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsOutputReturnsOnCall[len(fake.getBuildsWithVersionAsOutputArgsForCall)]
	fake.getBuildsWithVersionAsOutputArgsForCall = append(fake.getBuildsWithVersionAsOutputArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetBuildsWithVersionAsOutput", []interface{}{arg1})
	fake.getBuildsWithVersionAsOutputMutex.Unlock()
	if fake.GetBuildsWithVersionAsOutputStub != nil {
		return fake.GetBuildsWithVersionAsOutputStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBuildsWithVersionAsOutputReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputCallCount() int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsOutputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	argsForCall := fake.getBuildsWithVersionAsOutputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturns(result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsOutputStub = nil
	fake.getBuildsWithVersionAsOutputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsOutputStub = nil
	if fake.getBuildsWithVersionAsOutputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsOutputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsOutputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetLatestVersionedResource(arg1 string) (db.SavedVersionedResource, bool, error) {
	fake.getLatestVersionedResourceMutex.Lock()
	ret, specificReturn := fake.getLatestVersionedResourceReturnsOnCall[len(fake.getLatestVersionedResourceArgsForCall)]
	fake.getLatestVersionedResourceArgsForCall = append(fake.getLatestVersionedResourceArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetLatestVersionedResource", []interface{}{arg1})
	fake.getLatestVersionedResourceMutex.Unlock()
	if fake.GetLatestVersionedResourceStub != nil {
		return fake.GetLatestVersionedResourceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getLatestVersionedResourceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) GetLatestVersionedResourceCallCount() int {
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	return len(fake.getLatestVersionedResourceArgsForCall)
}

func (fake *FakePipeline) GetLatestVersionedResourceArgsForCall(i int) string {
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	argsForCall := fake.getLatestVersionedResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) GetLatestVersionedResourceReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetLatestVersionedResourceStub = nil
	fake.getLatestVersionedResourceReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetLatestVersionedResourceReturnsOnCall(i int, result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetLatestVersionedResourceStub = nil
	if fake.getLatestVersionedResourceReturnsOnCall == nil {
		fake.getLatestVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 db.SavedVersionedResource
			result2 bool
			result3 error
		})
	}
	fake.getLatestVersionedResourceReturnsOnCall[i] = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetResourceVersions(arg1 string, arg2 db.Page) ([]db.SavedVersionedResource, db.Pagination, bool, error) {
	fake.getResourceVersionsMutex.Lock()
	ret, specificReturn := fake.getResourceVersionsReturnsOnCall[len(fake.getResourceVersionsArgsForCall)]
	fake.getResourceVersionsArgsForCall = append(fake.getResourceVersionsArgsForCall, struct {
		arg1 string
		arg2 db.Page
	}{arg1, arg2})
	fake.recordInvocation("GetResourceVersions", []interface{}{arg1, arg2})
	fake.getResourceVersionsMutex.Unlock()
	if fake.GetResourceVersionsStub != nil {
		return fake.GetResourceVersionsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.getResourceVersionsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakePipeline) GetResourceVersionsCallCount() int {
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	return len(fake.getResourceVersionsArgsForCall)
}

func (fake *FakePipeline) GetResourceVersionsArgsForCall(i int) (string, db.Page) {
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	argsForCall := fake.getResourceVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) GetResourceVersionsReturns(result1 []db.SavedVersionedResource, result2 db.Pagination, result3 bool, result4 error) {
	fake.GetResourceVersionsStub = nil
	fake.getResourceVersionsReturns = struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePipeline) GetResourceVersionsReturnsOnCall(i int, result1 []db.SavedVersionedResource, result2 db.Pagination, result3 bool, result4 error) {
	fake.GetResourceVersionsStub = nil
	if fake.getResourceVersionsReturnsOnCall == nil {
		fake.getResourceVersionsReturnsOnCall = make(map[int]struct {
			result1 []db.SavedVersionedResource
			result2 db.Pagination
			result3 bool
			result4 error
		})
	}
	fake.getResourceVersionsReturnsOnCall[i] = struct {
		result1 []db.SavedVersionedResource
		result2 db.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePipeline) GetVersionedResourceByVersion(arg1 atc.Version, arg2 string) (db.SavedVersionedResource, bool, error) {
	fake.getVersionedResourceByVersionMutex.Lock()
	ret, specificReturn := fake.getVersionedResourceByVersionReturnsOnCall[len(fake.getVersionedResourceByVersionArgsForCall)]
	fake.getVersionedResourceByVersionArgsForCall = append(fake.getVersionedResourceByVersionArgsForCall, struct {
		arg1 atc.Version
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetVersionedResourceByVersion", []interface{}{arg1, arg2})
	fake.getVersionedResourceByVersionMutex.Unlock()
	if fake.GetVersionedResourceByVersionStub != nil {
		return fake.GetVersionedResourceByVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getVersionedResourceByVersionReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) GetVersionedResourceByVersionCallCount() int {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	return len(fake.getVersionedResourceByVersionArgsForCall)
}

func (fake *FakePipeline) GetVersionedResourceByVersionArgsForCall(i int) (atc.Version, string) {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	argsForCall := fake.getVersionedResourceByVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) GetVersionedResourceByVersionReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetVersionedResourceByVersionStub = nil
	fake.getVersionedResourceByVersionReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetVersionedResourceByVersionReturnsOnCall(i int, result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetVersionedResourceByVersionStub = nil
	if fake.getVersionedResourceByVersionReturnsOnCall == nil {
		fake.getVersionedResourceByVersionReturnsOnCall = make(map[int]struct {
			result1 db.SavedVersionedResource
			result2 bool
			result3 error
		})
	}
	fake.getVersionedResourceByVersionReturnsOnCall[i] = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Groups() atc.GroupConfigs {
	fake.groupsMutex.Lock()
	ret, specificReturn := fake.groupsReturnsOnCall[len(fake.groupsArgsForCall)]
	fake.groupsArgsForCall = append(fake.groupsArgsForCall, struct {
	}{})
	fake.recordInvocation("Groups", []interface{}{})
	fake.groupsMutex.Unlock()
	if fake.GroupsStub != nil {
		return fake.GroupsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.groupsReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) GroupsCallCount() int {
	fake.groupsMutex.RLock()
	defer fake.groupsMutex.RUnlock()
	return len(fake.groupsArgsForCall)
}

func (fake *FakePipeline) GroupsReturns(result1 atc.GroupConfigs) {
	fake.GroupsStub = nil
	fake.groupsReturns = struct {
		result1 atc.GroupConfigs
	}{result1}
}

func (fake *FakePipeline) GroupsReturnsOnCall(i int, result1 atc.GroupConfigs) {
	fake.GroupsStub = nil
	if fake.groupsReturnsOnCall == nil {
		fake.groupsReturnsOnCall = make(map[int]struct {
			result1 atc.GroupConfigs
		})
	}
	fake.groupsReturnsOnCall[i] = struct {
		result1 atc.GroupConfigs
	}{result1}
}

func (fake *FakePipeline) Hide() error {
	fake.hideMutex.Lock()
	ret, specificReturn := fake.hideReturnsOnCall[len(fake.hideArgsForCall)]
	fake.hideArgsForCall = append(fake.hideArgsForCall, struct {
	}{})
	fake.recordInvocation("Hide", []interface{}{})
	fake.hideMutex.Unlock()
	if fake.HideStub != nil {
		return fake.HideStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hideReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) HideCallCount() int {
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	return len(fake.hideArgsForCall)
}

func (fake *FakePipeline) HideReturns(result1 error) {
	fake.HideStub = nil
	fake.hideReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) HideReturnsOnCall(i int, result1 error) {
	fake.HideStub = nil
	if fake.hideReturnsOnCall == nil {
		fake.hideReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.hideReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakePipeline) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) Job(arg1 string) (db.Job, bool, error) {
	fake.jobMutex.Lock()
	ret, specificReturn := fake.jobReturnsOnCall[len(fake.jobArgsForCall)]
	fake.jobArgsForCall = append(fake.jobArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Job", []interface{}{arg1})
	fake.jobMutex.Unlock()
	if fake.JobStub != nil {
		return fake.JobStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.jobReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) JobCallCount() int {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return len(fake.jobArgsForCall)
}

func (fake *FakePipeline) JobArgsForCall(i int) string {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	argsForCall := fake.jobArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) JobReturns(result1 db.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	fake.jobReturns = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) JobReturnsOnCall(i int, result1 db.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	if fake.jobReturnsOnCall == nil {
		fake.jobReturnsOnCall = make(map[int]struct {
			result1 db.Job
			result2 bool
			result3 error
		})
	}
	fake.jobReturnsOnCall[i] = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Jobs() (db.Jobs, error) {
	fake.jobsMutex.Lock()
	ret, specificReturn := fake.jobsReturnsOnCall[len(fake.jobsArgsForCall)]
	fake.jobsArgsForCall = append(fake.jobsArgsForCall, struct {
	}{})
	fake.recordInvocation("Jobs", []interface{}{})
	fake.jobsMutex.Unlock()
	if fake.JobsStub != nil {
		return fake.JobsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.jobsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) JobsCallCount() int {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	return len(fake.jobsArgsForCall)
}

func (fake *FakePipeline) JobsReturns(result1 db.Jobs, result2 error) {
	fake.JobsStub = nil
	fake.jobsReturns = struct {
		result1 db.Jobs
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) JobsReturnsOnCall(i int, result1 db.Jobs, result2 error) {
	fake.JobsStub = nil
	if fake.jobsReturnsOnCall == nil {
		fake.jobsReturnsOnCall = make(map[int]struct {
			result1 db.Jobs
			result2 error
		})
	}
	fake.jobsReturnsOnCall[i] = struct {
		result1 db.Jobs
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) LoadVersionsDB() (*algorithm.VersionsDB, error) {
	fake.loadVersionsDBMutex.Lock()
	ret, specificReturn := fake.loadVersionsDBReturnsOnCall[len(fake.loadVersionsDBArgsForCall)]
	fake.loadVersionsDBArgsForCall = append(fake.loadVersionsDBArgsForCall, struct {
	}{})
	fake.recordInvocation("LoadVersionsDB", []interface{}{})
	fake.loadVersionsDBMutex.Unlock()
	if fake.LoadVersionsDBStub != nil {
		return fake.LoadVersionsDBStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.loadVersionsDBReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) LoadVersionsDBCallCount() int {
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	return len(fake.loadVersionsDBArgsForCall)
}

func (fake *FakePipeline) LoadVersionsDBReturns(result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	fake.loadVersionsDBReturns = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) LoadVersionsDBReturnsOnCall(i int, result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	if fake.loadVersionsDBReturnsOnCall == nil {
		fake.loadVersionsDBReturnsOnCall = make(map[int]struct {
			result1 *algorithm.VersionsDB
			result2 error
		})
	}
	fake.loadVersionsDBReturnsOnCall[i] = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakePipeline) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) Pause() error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct {
	}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pauseReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakePipeline) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) PauseReturnsOnCall(i int, result1 error) {
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Paused() bool {
	fake.pausedMutex.Lock()
	ret, specificReturn := fake.pausedReturnsOnCall[len(fake.pausedArgsForCall)]
	fake.pausedArgsForCall = append(fake.pausedArgsForCall, struct {
	}{})
	fake.recordInvocation("Paused", []interface{}{})
	fake.pausedMutex.Unlock()
	if fake.PausedStub != nil {
		return fake.PausedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pausedReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) PausedCallCount() int {
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	return len(fake.pausedArgsForCall)
}

func (fake *FakePipeline) PausedReturns(result1 bool) {
	fake.PausedStub = nil
	fake.pausedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PausedReturnsOnCall(i int, result1 bool) {
	fake.PausedStub = nil
	if fake.pausedReturnsOnCall == nil {
		fake.pausedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pausedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) Public() bool {
	fake.publicMutex.Lock()
	ret, specificReturn := fake.publicReturnsOnCall[len(fake.publicArgsForCall)]
	fake.publicArgsForCall = append(fake.publicArgsForCall, struct {
	}{})
	fake.recordInvocation("Public", []interface{}{})
	fake.publicMutex.Unlock()
	if fake.PublicStub != nil {
		return fake.PublicStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.publicReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) PublicCallCount() int {
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	return len(fake.publicArgsForCall)
}

func (fake *FakePipeline) PublicReturns(result1 bool) {
	fake.PublicStub = nil
	fake.publicReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PublicReturnsOnCall(i int, result1 bool) {
	fake.PublicStub = nil
	if fake.publicReturnsOnCall == nil {
		fake.publicReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.publicReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
	}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.reloadReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakePipeline) ReloadReturns(result1 bool, result2 error) {
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Rename(arg1 string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Rename", []interface{}{arg1})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renameReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakePipeline) RenameArgsForCall(i int) string {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	argsForCall := fake.renameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) RenameReturns(result1 error) {
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) RenameReturnsOnCall(i int, result1 error) {
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Resource(arg1 string) (db.Resource, bool, error) {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Resource", []interface{}{arg1})
	fake.resourceMutex.Unlock()
	if fake.ResourceStub != nil {
		return fake.ResourceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.resourceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakePipeline) ResourceArgsForCall(i int) string {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	argsForCall := fake.resourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ResourceReturns(result1 db.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceReturnsOnCall(i int, result1 db.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 db.Resource
			result2 bool
			result3 error
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceType(arg1 string) (db.ResourceType, bool, error) {
	fake.resourceTypeMutex.Lock()
	ret, specificReturn := fake.resourceTypeReturnsOnCall[len(fake.resourceTypeArgsForCall)]
	fake.resourceTypeArgsForCall = append(fake.resourceTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ResourceType", []interface{}{arg1})
	fake.resourceTypeMutex.Unlock()
	if fake.ResourceTypeStub != nil {
		return fake.ResourceTypeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.resourceTypeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) ResourceTypeCallCount() int {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	return len(fake.resourceTypeArgsForCall)
}

func (fake *FakePipeline) ResourceTypeArgsForCall(i int) string {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	argsForCall := fake.resourceTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ResourceTypeReturns(result1 db.ResourceType, result2 bool, result3 error) {
	fake.ResourceTypeStub = nil
	fake.resourceTypeReturns = struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypeReturnsOnCall(i int, result1 db.ResourceType, result2 bool, result3 error) {
	fake.ResourceTypeStub = nil
	if fake.resourceTypeReturnsOnCall == nil {
		fake.resourceTypeReturnsOnCall = make(map[int]struct {
			result1 db.ResourceType
			result2 bool
			result3 error
		})
	}
	fake.resourceTypeReturnsOnCall[i] = struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypes() (db.ResourceTypes, error) {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if fake.ResourceTypesStub != nil {
		return fake.ResourceTypesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.resourceTypesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakePipeline) ResourceTypesReturns(result1 db.ResourceTypes, result2 error) {
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 db.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceTypesReturnsOnCall(i int, result1 db.ResourceTypes, result2 error) {
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 db.ResourceTypes
			result2 error
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 db.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Resources() (db.Resources, error) {
	fake.resourcesMutex.Lock()
	ret, specificReturn := fake.resourcesReturnsOnCall[len(fake.resourcesArgsForCall)]
	fake.resourcesArgsForCall = append(fake.resourcesArgsForCall, struct {
	}{})
	fake.recordInvocation("Resources", []interface{}{})
	fake.resourcesMutex.Unlock()
	if fake.ResourcesStub != nil {
		return fake.ResourcesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.resourcesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ResourcesCallCount() int {
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	return len(fake.resourcesArgsForCall)
}

func (fake *FakePipeline) ResourcesReturns(result1 db.Resources, result2 error) {
	fake.ResourcesStub = nil
	fake.resourcesReturns = struct {
		result1 db.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourcesReturnsOnCall(i int, result1 db.Resources, result2 error) {
	fake.ResourcesStub = nil
	if fake.resourcesReturnsOnCall == nil {
		fake.resourcesReturnsOnCall = make(map[int]struct {
			result1 db.Resources
			result2 error
		})
	}
	fake.resourcesReturnsOnCall[i] = struct {
		result1 db.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) SaveResourceVersions(arg1 atc.ResourceConfig, arg2 []atc.Version) error {
	var arg2Copy []atc.Version
	if arg2 != nil {
		arg2Copy = make([]atc.Version, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.saveResourceVersionsMutex.Lock()
	ret, specificReturn := fake.saveResourceVersionsReturnsOnCall[len(fake.saveResourceVersionsArgsForCall)]
	fake.saveResourceVersionsArgsForCall = append(fake.saveResourceVersionsArgsForCall, struct {
		arg1 atc.ResourceConfig
		arg2 []atc.Version
	}{arg1, arg2Copy})
	fake.recordInvocation("SaveResourceVersions", []interface{}{arg1, arg2Copy})
	fake.saveResourceVersionsMutex.Unlock()
	if fake.SaveResourceVersionsStub != nil {
		return fake.SaveResourceVersionsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveResourceVersionsReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) SaveResourceVersionsCallCount() int {
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	return len(fake.saveResourceVersionsArgsForCall)
}

func (fake *FakePipeline) SaveResourceVersionsArgsForCall(i int) (atc.ResourceConfig, []atc.Version) {
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	argsForCall := fake.saveResourceVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) SaveResourceVersionsReturns(result1 error) {
	fake.SaveResourceVersionsStub = nil
	fake.saveResourceVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SaveResourceVersionsReturnsOnCall(i int, result1 error) {
	fake.SaveResourceVersionsStub = nil
	if fake.saveResourceVersionsReturnsOnCall == nil {
		fake.saveResourceVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveResourceVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ScopedName(arg1 string) string {
	fake.scopedNameMutex.Lock()
	ret, specificReturn := fake.scopedNameReturnsOnCall[len(fake.scopedNameArgsForCall)]
	fake.scopedNameArgsForCall = append(fake.scopedNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ScopedName", []interface{}{arg1})
	fake.scopedNameMutex.Unlock()
	if fake.ScopedNameStub != nil {
		return fake.ScopedNameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.scopedNameReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) ScopedNameCallCount() int {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	return len(fake.scopedNameArgsForCall)
}

func (fake *FakePipeline) ScopedNameArgsForCall(i int) string {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	argsForCall := fake.scopedNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ScopedNameReturns(result1 string) {
	fake.ScopedNameStub = nil
	fake.scopedNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) ScopedNameReturnsOnCall(i int, result1 string) {
	fake.ScopedNameStub = nil
	if fake.scopedNameReturnsOnCall == nil {
		fake.scopedNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.scopedNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) SetResourceCheckError(arg1 db.Resource, arg2 error) error {
	fake.setResourceCheckErrorMutex.Lock()
	ret, specificReturn := fake.setResourceCheckErrorReturnsOnCall[len(fake.setResourceCheckErrorArgsForCall)]
	fake.setResourceCheckErrorArgsForCall = append(fake.setResourceCheckErrorArgsForCall, struct {
		arg1 db.Resource
		arg2 error
	}{arg1, arg2})
	fake.recordInvocation("SetResourceCheckError", []interface{}{arg1, arg2})
	fake.setResourceCheckErrorMutex.Unlock()
	if fake.SetResourceCheckErrorStub != nil {
		return fake.SetResourceCheckErrorStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setResourceCheckErrorReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) SetResourceCheckErrorCallCount() int {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	return len(fake.setResourceCheckErrorArgsForCall)
}

func (fake *FakePipeline) SetResourceCheckErrorArgsForCall(i int) (db.Resource, error) {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	argsForCall := fake.setResourceCheckErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) SetResourceCheckErrorReturns(result1 error) {
	fake.SetResourceCheckErrorStub = nil
	fake.setResourceCheckErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SetResourceCheckErrorReturnsOnCall(i int, result1 error) {
	fake.SetResourceCheckErrorStub = nil
	if fake.setResourceCheckErrorReturnsOnCall == nil {
		fake.setResourceCheckErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setResourceCheckErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamIDReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakePipeline) TeamIDReturns(result1 int) {
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamIDReturnsOnCall(i int, result1 int) {
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if fake.TeamNameStub != nil {
		return fake.TeamNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamNameReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakePipeline) TeamNameReturns(result1 string) {
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) TeamNameReturnsOnCall(i int, result1 string) {
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) Unarchive() error {
	fake.unarchiveMutex.Lock()
	ret, specificReturn := fake.unarchiveReturnsOnCall[len(fake.unarchiveArgsForCall)]
	fake.unarchiveArgsForCall = append(fake.unarchiveArgsForCall, struct {
	}{})
	fake.recordInvocation("Unarchive", []interface{}{})
	fake.unarchiveMutex.Unlock()
	if fake.UnarchiveStub != nil {
		return fake.UnarchiveStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unarchiveReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) UnarchiveCallCount() int {
	fake.unarchiveMutex.RLock()
	defer fake.unarchiveMutex.RUnlock()
	return len(fake.unarchiveArgsForCall)
}

func (fake *FakePipeline) UnarchiveReturns(result1 error) {
	fake.UnarchiveStub = nil
	fake.unarchiveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) UnarchiveReturnsOnCall(i int, result1 error) {
	fake.UnarchiveStub = nil
	if fake.unarchiveReturnsOnCall == nil {
		fake.unarchiveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unarchiveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Unpause() error {
	fake.unpauseMutex.Lock()
	ret, specificReturn := fake.unpauseReturnsOnCall[len(fake.unpauseArgsForCall)]
	fake.unpauseArgsForCall = append(fake.unpauseArgsForCall, struct {
	}{})
	fake.recordInvocation("Unpause", []interface{}{})
	fake.unpauseMutex.Unlock()
	if fake.UnpauseStub != nil {
		return fake.UnpauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unpauseReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) UnpauseCallCount() int {
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	return len(fake.unpauseArgsForCall)
}

func (fake *FakePipeline) UnpauseReturns(result1 error) {
	fake.UnpauseStub = nil
	fake.unpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) UnpauseReturnsOnCall(i int, result1 error) {
	fake.UnpauseStub = nil
	if fake.unpauseReturnsOnCall == nil {
		fake.unpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) VersionedResource(arg1 int) (db.SavedVersionedResource, bool, error) {
	fake.versionedResourceMutex.Lock()
	ret, specificReturn := fake.versionedResourceReturnsOnCall[len(fake.versionedResourceArgsForCall)]
	fake.versionedResourceArgsForCall = append(fake.versionedResourceArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("VersionedResource", []interface{}{arg1})
	fake.versionedResourceMutex.Unlock()
	if fake.VersionedResourceStub != nil {
		return fake.VersionedResourceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.versionedResourceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) VersionedResourceCallCount() int {
	fake.versionedResourceMutex.RLock()
	defer fake.versionedResourceMutex.RUnlock()
	return len(fake.versionedResourceArgsForCall)
}

func (fake *FakePipeline) VersionedResourceArgsForCall(i int) int {
	fake.versionedResourceMutex.RLock()
	defer fake.versionedResourceMutex.RUnlock()
	argsForCall := fake.versionedResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) VersionedResourceReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.VersionedResourceStub = nil
	fake.versionedResourceReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) VersionedResourceReturnsOnCall(i int, result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.VersionedResourceStub = nil
	if fake.versionedResourceReturnsOnCall == nil {
		fake.versionedResourceReturnsOnCall = make(map[int]struct {
			result1 db.SavedVersionedResource
			result2 bool
			result3 error
		})
	}
	fake.versionedResourceReturnsOnCall[i] = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RUnlock()
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	fake.archiveMutex.RLock()
	defer fake.archiveMutex.RUnlock()
	fake.archivedMutex.RLock()
	defer fake.archivedMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	fake.groupsMutex.RLock()
	defer fake.groupsMutex.RUnlock()
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.unarchiveMutex.RLock()
	defer fake.unarchiveMutex.RUnlock()
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	fake.versionedResourceMutex.RLock()
	defer fake.versionedResourceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePipeline) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Pipeline = new(FakePipeline)
