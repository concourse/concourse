// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/db/lock"
	"go.opentelemetry.io/otel/api/propagators"
)

type FakeCheck struct {
	AcquireTrackingLockStub        func(lager.Logger) (lock.Lock, bool, error)
	acquireTrackingLockMutex       sync.RWMutex
	acquireTrackingLockArgsForCall []struct {
		arg1 lager.Logger
	}
	acquireTrackingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireTrackingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AllCheckablesStub        func() ([]db.Checkable, error)
	allCheckablesMutex       sync.RWMutex
	allCheckablesArgsForCall []struct {
	}
	allCheckablesReturns struct {
		result1 []db.Checkable
		result2 error
	}
	allCheckablesReturnsOnCall map[int]struct {
		result1 []db.Checkable
		result2 error
	}
	BaseResourceTypeIDStub        func() int
	baseResourceTypeIDMutex       sync.RWMutex
	baseResourceTypeIDArgsForCall []struct {
	}
	baseResourceTypeIDReturns struct {
		result1 int
	}
	baseResourceTypeIDReturnsOnCall map[int]struct {
		result1 int
	}
	CheckErrorStub        func() error
	checkErrorMutex       sync.RWMutex
	checkErrorArgsForCall []struct {
	}
	checkErrorReturns struct {
		result1 error
	}
	checkErrorReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTimeStub        func() time.Time
	createTimeMutex       sync.RWMutex
	createTimeArgsForCall []struct {
	}
	createTimeReturns struct {
		result1 time.Time
	}
	createTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	EndTimeStub        func() time.Time
	endTimeMutex       sync.RWMutex
	endTimeArgsForCall []struct {
	}
	endTimeReturns struct {
		result1 time.Time
	}
	endTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	FinishStub        func() error
	finishMutex       sync.RWMutex
	finishArgsForCall []struct {
	}
	finishReturns struct {
		result1 error
	}
	finishReturnsOnCall map[int]struct {
		result1 error
	}
	FinishWithErrorStub        func(error) error
	finishWithErrorMutex       sync.RWMutex
	finishWithErrorArgsForCall []struct {
		arg1 error
	}
	finishWithErrorReturns struct {
		result1 error
	}
	finishWithErrorReturnsOnCall map[int]struct {
		result1 error
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	ManuallyTriggeredStub        func() bool
	manuallyTriggeredMutex       sync.RWMutex
	manuallyTriggeredArgsForCall []struct {
	}
	manuallyTriggeredReturns struct {
		result1 bool
	}
	manuallyTriggeredReturnsOnCall map[int]struct {
		result1 bool
	}
	PipelineStub        func() (db.Pipeline, bool, error)
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct {
	}
	pipelineReturns struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	pipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	PipelineIDStub        func() int
	pipelineIDMutex       sync.RWMutex
	pipelineIDArgsForCall []struct {
	}
	pipelineIDReturns struct {
		result1 int
	}
	pipelineIDReturnsOnCall map[int]struct {
		result1 int
	}
	PipelineInstanceVarsStub        func() atc.InstanceVars
	pipelineInstanceVarsMutex       sync.RWMutex
	pipelineInstanceVarsArgsForCall []struct {
	}
	pipelineInstanceVarsReturns struct {
		result1 atc.InstanceVars
	}
	pipelineInstanceVarsReturnsOnCall map[int]struct {
		result1 atc.InstanceVars
	}
	PipelineNameStub        func() string
	pipelineNameMutex       sync.RWMutex
	pipelineNameArgsForCall []struct {
	}
	pipelineNameReturns struct {
		result1 string
	}
	pipelineNameReturnsOnCall map[int]struct {
		result1 string
	}
	PipelineRefStub        func() atc.PipelineRef
	pipelineRefMutex       sync.RWMutex
	pipelineRefArgsForCall []struct {
	}
	pipelineRefReturns struct {
		result1 atc.PipelineRef
	}
	pipelineRefReturnsOnCall map[int]struct {
		result1 atc.PipelineRef
	}
	PlanStub        func() atc.Plan
	planMutex       sync.RWMutex
	planArgsForCall []struct {
	}
	planReturns struct {
		result1 atc.Plan
	}
	planReturnsOnCall map[int]struct {
		result1 atc.Plan
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
	}
	reloadReturns struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ResourceConfigIDStub        func() int
	resourceConfigIDMutex       sync.RWMutex
	resourceConfigIDArgsForCall []struct {
	}
	resourceConfigIDReturns struct {
		result1 int
	}
	resourceConfigIDReturnsOnCall map[int]struct {
		result1 int
	}
	ResourceConfigScopeIDStub        func() int
	resourceConfigScopeIDMutex       sync.RWMutex
	resourceConfigScopeIDArgsForCall []struct {
	}
	resourceConfigScopeIDReturns struct {
		result1 int
	}
	resourceConfigScopeIDReturnsOnCall map[int]struct {
		result1 int
	}
	SaveVersionsStub        func(db.SpanContext, []atc.Version) error
	saveVersionsMutex       sync.RWMutex
	saveVersionsArgsForCall []struct {
		arg1 db.SpanContext
		arg2 []atc.Version
	}
	saveVersionsReturns struct {
		result1 error
	}
	saveVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	SchemaStub        func() string
	schemaMutex       sync.RWMutex
	schemaArgsForCall []struct {
	}
	schemaReturns struct {
		result1 string
	}
	schemaReturnsOnCall map[int]struct {
		result1 string
	}
	SpanContextStub        func() propagators.Supplier
	spanContextMutex       sync.RWMutex
	spanContextArgsForCall []struct {
	}
	spanContextReturns struct {
		result1 propagators.Supplier
	}
	spanContextReturnsOnCall map[int]struct {
		result1 propagators.Supplier
	}
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	StartTimeStub        func() time.Time
	startTimeMutex       sync.RWMutex
	startTimeArgsForCall []struct {
	}
	startTimeReturns struct {
		result1 time.Time
	}
	startTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	StatusStub        func() db.CheckStatus
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 db.CheckStatus
	}
	statusReturnsOnCall map[int]struct {
		result1 db.CheckStatus
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCheck) AcquireTrackingLock(arg1 lager.Logger) (lock.Lock, bool, error) {
	fake.acquireTrackingLockMutex.Lock()
	ret, specificReturn := fake.acquireTrackingLockReturnsOnCall[len(fake.acquireTrackingLockArgsForCall)]
	fake.acquireTrackingLockArgsForCall = append(fake.acquireTrackingLockArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("AcquireTrackingLock", []interface{}{arg1})
	fake.acquireTrackingLockMutex.Unlock()
	if fake.AcquireTrackingLockStub != nil {
		return fake.AcquireTrackingLockStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireTrackingLockReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCheck) AcquireTrackingLockCallCount() int {
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	return len(fake.acquireTrackingLockArgsForCall)
}

func (fake *FakeCheck) AcquireTrackingLockCalls(stub func(lager.Logger) (lock.Lock, bool, error)) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = stub
}

func (fake *FakeCheck) AcquireTrackingLockArgsForCall(i int) lager.Logger {
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	argsForCall := fake.acquireTrackingLockArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheck) AcquireTrackingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = nil
	fake.acquireTrackingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheck) AcquireTrackingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = nil
	if fake.acquireTrackingLockReturnsOnCall == nil {
		fake.acquireTrackingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireTrackingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheck) AllCheckables() ([]db.Checkable, error) {
	fake.allCheckablesMutex.Lock()
	ret, specificReturn := fake.allCheckablesReturnsOnCall[len(fake.allCheckablesArgsForCall)]
	fake.allCheckablesArgsForCall = append(fake.allCheckablesArgsForCall, struct {
	}{})
	fake.recordInvocation("AllCheckables", []interface{}{})
	fake.allCheckablesMutex.Unlock()
	if fake.AllCheckablesStub != nil {
		return fake.AllCheckablesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.allCheckablesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCheck) AllCheckablesCallCount() int {
	fake.allCheckablesMutex.RLock()
	defer fake.allCheckablesMutex.RUnlock()
	return len(fake.allCheckablesArgsForCall)
}

func (fake *FakeCheck) AllCheckablesCalls(stub func() ([]db.Checkable, error)) {
	fake.allCheckablesMutex.Lock()
	defer fake.allCheckablesMutex.Unlock()
	fake.AllCheckablesStub = stub
}

func (fake *FakeCheck) AllCheckablesReturns(result1 []db.Checkable, result2 error) {
	fake.allCheckablesMutex.Lock()
	defer fake.allCheckablesMutex.Unlock()
	fake.AllCheckablesStub = nil
	fake.allCheckablesReturns = struct {
		result1 []db.Checkable
		result2 error
	}{result1, result2}
}

func (fake *FakeCheck) AllCheckablesReturnsOnCall(i int, result1 []db.Checkable, result2 error) {
	fake.allCheckablesMutex.Lock()
	defer fake.allCheckablesMutex.Unlock()
	fake.AllCheckablesStub = nil
	if fake.allCheckablesReturnsOnCall == nil {
		fake.allCheckablesReturnsOnCall = make(map[int]struct {
			result1 []db.Checkable
			result2 error
		})
	}
	fake.allCheckablesReturnsOnCall[i] = struct {
		result1 []db.Checkable
		result2 error
	}{result1, result2}
}

func (fake *FakeCheck) BaseResourceTypeID() int {
	fake.baseResourceTypeIDMutex.Lock()
	ret, specificReturn := fake.baseResourceTypeIDReturnsOnCall[len(fake.baseResourceTypeIDArgsForCall)]
	fake.baseResourceTypeIDArgsForCall = append(fake.baseResourceTypeIDArgsForCall, struct {
	}{})
	fake.recordInvocation("BaseResourceTypeID", []interface{}{})
	fake.baseResourceTypeIDMutex.Unlock()
	if fake.BaseResourceTypeIDStub != nil {
		return fake.BaseResourceTypeIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.baseResourceTypeIDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) BaseResourceTypeIDCallCount() int {
	fake.baseResourceTypeIDMutex.RLock()
	defer fake.baseResourceTypeIDMutex.RUnlock()
	return len(fake.baseResourceTypeIDArgsForCall)
}

func (fake *FakeCheck) BaseResourceTypeIDCalls(stub func() int) {
	fake.baseResourceTypeIDMutex.Lock()
	defer fake.baseResourceTypeIDMutex.Unlock()
	fake.BaseResourceTypeIDStub = stub
}

func (fake *FakeCheck) BaseResourceTypeIDReturns(result1 int) {
	fake.baseResourceTypeIDMutex.Lock()
	defer fake.baseResourceTypeIDMutex.Unlock()
	fake.BaseResourceTypeIDStub = nil
	fake.baseResourceTypeIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) BaseResourceTypeIDReturnsOnCall(i int, result1 int) {
	fake.baseResourceTypeIDMutex.Lock()
	defer fake.baseResourceTypeIDMutex.Unlock()
	fake.BaseResourceTypeIDStub = nil
	if fake.baseResourceTypeIDReturnsOnCall == nil {
		fake.baseResourceTypeIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.baseResourceTypeIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) CheckError() error {
	fake.checkErrorMutex.Lock()
	ret, specificReturn := fake.checkErrorReturnsOnCall[len(fake.checkErrorArgsForCall)]
	fake.checkErrorArgsForCall = append(fake.checkErrorArgsForCall, struct {
	}{})
	fake.recordInvocation("CheckError", []interface{}{})
	fake.checkErrorMutex.Unlock()
	if fake.CheckErrorStub != nil {
		return fake.CheckErrorStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.checkErrorReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) CheckErrorCallCount() int {
	fake.checkErrorMutex.RLock()
	defer fake.checkErrorMutex.RUnlock()
	return len(fake.checkErrorArgsForCall)
}

func (fake *FakeCheck) CheckErrorCalls(stub func() error) {
	fake.checkErrorMutex.Lock()
	defer fake.checkErrorMutex.Unlock()
	fake.CheckErrorStub = stub
}

func (fake *FakeCheck) CheckErrorReturns(result1 error) {
	fake.checkErrorMutex.Lock()
	defer fake.checkErrorMutex.Unlock()
	fake.CheckErrorStub = nil
	fake.checkErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) CheckErrorReturnsOnCall(i int, result1 error) {
	fake.checkErrorMutex.Lock()
	defer fake.checkErrorMutex.Unlock()
	fake.CheckErrorStub = nil
	if fake.checkErrorReturnsOnCall == nil {
		fake.checkErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) CreateTime() time.Time {
	fake.createTimeMutex.Lock()
	ret, specificReturn := fake.createTimeReturnsOnCall[len(fake.createTimeArgsForCall)]
	fake.createTimeArgsForCall = append(fake.createTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateTime", []interface{}{})
	fake.createTimeMutex.Unlock()
	if fake.CreateTimeStub != nil {
		return fake.CreateTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createTimeReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) CreateTimeCallCount() int {
	fake.createTimeMutex.RLock()
	defer fake.createTimeMutex.RUnlock()
	return len(fake.createTimeArgsForCall)
}

func (fake *FakeCheck) CreateTimeCalls(stub func() time.Time) {
	fake.createTimeMutex.Lock()
	defer fake.createTimeMutex.Unlock()
	fake.CreateTimeStub = stub
}

func (fake *FakeCheck) CreateTimeReturns(result1 time.Time) {
	fake.createTimeMutex.Lock()
	defer fake.createTimeMutex.Unlock()
	fake.CreateTimeStub = nil
	fake.createTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) CreateTimeReturnsOnCall(i int, result1 time.Time) {
	fake.createTimeMutex.Lock()
	defer fake.createTimeMutex.Unlock()
	fake.CreateTimeStub = nil
	if fake.createTimeReturnsOnCall == nil {
		fake.createTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.createTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) EndTime() time.Time {
	fake.endTimeMutex.Lock()
	ret, specificReturn := fake.endTimeReturnsOnCall[len(fake.endTimeArgsForCall)]
	fake.endTimeArgsForCall = append(fake.endTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("EndTime", []interface{}{})
	fake.endTimeMutex.Unlock()
	if fake.EndTimeStub != nil {
		return fake.EndTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.endTimeReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) EndTimeCallCount() int {
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	return len(fake.endTimeArgsForCall)
}

func (fake *FakeCheck) EndTimeCalls(stub func() time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = stub
}

func (fake *FakeCheck) EndTimeReturns(result1 time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = nil
	fake.endTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) EndTimeReturnsOnCall(i int, result1 time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = nil
	if fake.endTimeReturnsOnCall == nil {
		fake.endTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.endTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) Finish() error {
	fake.finishMutex.Lock()
	ret, specificReturn := fake.finishReturnsOnCall[len(fake.finishArgsForCall)]
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct {
	}{})
	fake.recordInvocation("Finish", []interface{}{})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		return fake.FinishStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeCheck) FinishCalls(stub func() error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = stub
}

func (fake *FakeCheck) FinishReturns(result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	fake.finishReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FinishReturnsOnCall(i int, result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	if fake.finishReturnsOnCall == nil {
		fake.finishReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FinishWithError(arg1 error) error {
	fake.finishWithErrorMutex.Lock()
	ret, specificReturn := fake.finishWithErrorReturnsOnCall[len(fake.finishWithErrorArgsForCall)]
	fake.finishWithErrorArgsForCall = append(fake.finishWithErrorArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("FinishWithError", []interface{}{arg1})
	fake.finishWithErrorMutex.Unlock()
	if fake.FinishWithErrorStub != nil {
		return fake.FinishWithErrorStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishWithErrorReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) FinishWithErrorCallCount() int {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	return len(fake.finishWithErrorArgsForCall)
}

func (fake *FakeCheck) FinishWithErrorCalls(stub func(error) error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = stub
}

func (fake *FakeCheck) FinishWithErrorArgsForCall(i int) error {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	argsForCall := fake.finishWithErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCheck) FinishWithErrorReturns(result1 error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = nil
	fake.finishWithErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) FinishWithErrorReturnsOnCall(i int, result1 error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = nil
	if fake.finishWithErrorReturnsOnCall == nil {
		fake.finishWithErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishWithErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeCheck) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeCheck) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) ManuallyTriggered() bool {
	fake.manuallyTriggeredMutex.Lock()
	ret, specificReturn := fake.manuallyTriggeredReturnsOnCall[len(fake.manuallyTriggeredArgsForCall)]
	fake.manuallyTriggeredArgsForCall = append(fake.manuallyTriggeredArgsForCall, struct {
	}{})
	fake.recordInvocation("ManuallyTriggered", []interface{}{})
	fake.manuallyTriggeredMutex.Unlock()
	if fake.ManuallyTriggeredStub != nil {
		return fake.ManuallyTriggeredStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.manuallyTriggeredReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) ManuallyTriggeredCallCount() int {
	fake.manuallyTriggeredMutex.RLock()
	defer fake.manuallyTriggeredMutex.RUnlock()
	return len(fake.manuallyTriggeredArgsForCall)
}

func (fake *FakeCheck) ManuallyTriggeredCalls(stub func() bool) {
	fake.manuallyTriggeredMutex.Lock()
	defer fake.manuallyTriggeredMutex.Unlock()
	fake.ManuallyTriggeredStub = stub
}

func (fake *FakeCheck) ManuallyTriggeredReturns(result1 bool) {
	fake.manuallyTriggeredMutex.Lock()
	defer fake.manuallyTriggeredMutex.Unlock()
	fake.ManuallyTriggeredStub = nil
	fake.manuallyTriggeredReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCheck) ManuallyTriggeredReturnsOnCall(i int, result1 bool) {
	fake.manuallyTriggeredMutex.Lock()
	defer fake.manuallyTriggeredMutex.Unlock()
	fake.ManuallyTriggeredStub = nil
	if fake.manuallyTriggeredReturnsOnCall == nil {
		fake.manuallyTriggeredReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.manuallyTriggeredReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCheck) Pipeline() (db.Pipeline, bool, error) {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct {
	}{})
	fake.recordInvocation("Pipeline", []interface{}{})
	fake.pipelineMutex.Unlock()
	if fake.PipelineStub != nil {
		return fake.PipelineStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.pipelineReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCheck) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeCheck) PipelineCalls(stub func() (db.Pipeline, bool, error)) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = stub
}

func (fake *FakeCheck) PipelineReturns(result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheck) PipelineReturnsOnCall(i int, result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCheck) PipelineID() int {
	fake.pipelineIDMutex.Lock()
	ret, specificReturn := fake.pipelineIDReturnsOnCall[len(fake.pipelineIDArgsForCall)]
	fake.pipelineIDArgsForCall = append(fake.pipelineIDArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineID", []interface{}{})
	fake.pipelineIDMutex.Unlock()
	if fake.PipelineIDStub != nil {
		return fake.PipelineIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineIDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) PipelineIDCallCount() int {
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	return len(fake.pipelineIDArgsForCall)
}

func (fake *FakeCheck) PipelineIDCalls(stub func() int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = stub
}

func (fake *FakeCheck) PipelineIDReturns(result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	fake.pipelineIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) PipelineIDReturnsOnCall(i int, result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	if fake.pipelineIDReturnsOnCall == nil {
		fake.pipelineIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.pipelineIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) PipelineInstanceVars() atc.InstanceVars {
	fake.pipelineInstanceVarsMutex.Lock()
	ret, specificReturn := fake.pipelineInstanceVarsReturnsOnCall[len(fake.pipelineInstanceVarsArgsForCall)]
	fake.pipelineInstanceVarsArgsForCall = append(fake.pipelineInstanceVarsArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineInstanceVars", []interface{}{})
	fake.pipelineInstanceVarsMutex.Unlock()
	if fake.PipelineInstanceVarsStub != nil {
		return fake.PipelineInstanceVarsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineInstanceVarsReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) PipelineInstanceVarsCallCount() int {
	fake.pipelineInstanceVarsMutex.RLock()
	defer fake.pipelineInstanceVarsMutex.RUnlock()
	return len(fake.pipelineInstanceVarsArgsForCall)
}

func (fake *FakeCheck) PipelineInstanceVarsCalls(stub func() atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = stub
}

func (fake *FakeCheck) PipelineInstanceVarsReturns(result1 atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = nil
	fake.pipelineInstanceVarsReturns = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakeCheck) PipelineInstanceVarsReturnsOnCall(i int, result1 atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = nil
	if fake.pipelineInstanceVarsReturnsOnCall == nil {
		fake.pipelineInstanceVarsReturnsOnCall = make(map[int]struct {
			result1 atc.InstanceVars
		})
	}
	fake.pipelineInstanceVarsReturnsOnCall[i] = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakeCheck) PipelineName() string {
	fake.pipelineNameMutex.Lock()
	ret, specificReturn := fake.pipelineNameReturnsOnCall[len(fake.pipelineNameArgsForCall)]
	fake.pipelineNameArgsForCall = append(fake.pipelineNameArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineName", []interface{}{})
	fake.pipelineNameMutex.Unlock()
	if fake.PipelineNameStub != nil {
		return fake.PipelineNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineNameReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) PipelineNameCallCount() int {
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	return len(fake.pipelineNameArgsForCall)
}

func (fake *FakeCheck) PipelineNameCalls(stub func() string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = stub
}

func (fake *FakeCheck) PipelineNameReturns(result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	fake.pipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCheck) PipelineNameReturnsOnCall(i int, result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	if fake.pipelineNameReturnsOnCall == nil {
		fake.pipelineNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pipelineNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeCheck) PipelineRef() atc.PipelineRef {
	fake.pipelineRefMutex.Lock()
	ret, specificReturn := fake.pipelineRefReturnsOnCall[len(fake.pipelineRefArgsForCall)]
	fake.pipelineRefArgsForCall = append(fake.pipelineRefArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineRef", []interface{}{})
	fake.pipelineRefMutex.Unlock()
	if fake.PipelineRefStub != nil {
		return fake.PipelineRefStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineRefReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) PipelineRefCallCount() int {
	fake.pipelineRefMutex.RLock()
	defer fake.pipelineRefMutex.RUnlock()
	return len(fake.pipelineRefArgsForCall)
}

func (fake *FakeCheck) PipelineRefCalls(stub func() atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = stub
}

func (fake *FakeCheck) PipelineRefReturns(result1 atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = nil
	fake.pipelineRefReturns = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakeCheck) PipelineRefReturnsOnCall(i int, result1 atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = nil
	if fake.pipelineRefReturnsOnCall == nil {
		fake.pipelineRefReturnsOnCall = make(map[int]struct {
			result1 atc.PipelineRef
		})
	}
	fake.pipelineRefReturnsOnCall[i] = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakeCheck) Plan() atc.Plan {
	fake.planMutex.Lock()
	ret, specificReturn := fake.planReturnsOnCall[len(fake.planArgsForCall)]
	fake.planArgsForCall = append(fake.planArgsForCall, struct {
	}{})
	fake.recordInvocation("Plan", []interface{}{})
	fake.planMutex.Unlock()
	if fake.PlanStub != nil {
		return fake.PlanStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.planReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) PlanCallCount() int {
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	return len(fake.planArgsForCall)
}

func (fake *FakeCheck) PlanCalls(stub func() atc.Plan) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = stub
}

func (fake *FakeCheck) PlanReturns(result1 atc.Plan) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	fake.planReturns = struct {
		result1 atc.Plan
	}{result1}
}

func (fake *FakeCheck) PlanReturnsOnCall(i int, result1 atc.Plan) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	if fake.planReturnsOnCall == nil {
		fake.planReturnsOnCall = make(map[int]struct {
			result1 atc.Plan
		})
	}
	fake.planReturnsOnCall[i] = struct {
		result1 atc.Plan
	}{result1}
}

func (fake *FakeCheck) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
	}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.reloadReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCheck) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakeCheck) ReloadCalls(stub func() (bool, error)) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = stub
}

func (fake *FakeCheck) ReloadReturns(result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCheck) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeCheck) ResourceConfigID() int {
	fake.resourceConfigIDMutex.Lock()
	ret, specificReturn := fake.resourceConfigIDReturnsOnCall[len(fake.resourceConfigIDArgsForCall)]
	fake.resourceConfigIDArgsForCall = append(fake.resourceConfigIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceConfigID", []interface{}{})
	fake.resourceConfigIDMutex.Unlock()
	if fake.ResourceConfigIDStub != nil {
		return fake.ResourceConfigIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceConfigIDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) ResourceConfigIDCallCount() int {
	fake.resourceConfigIDMutex.RLock()
	defer fake.resourceConfigIDMutex.RUnlock()
	return len(fake.resourceConfigIDArgsForCall)
}

func (fake *FakeCheck) ResourceConfigIDCalls(stub func() int) {
	fake.resourceConfigIDMutex.Lock()
	defer fake.resourceConfigIDMutex.Unlock()
	fake.ResourceConfigIDStub = stub
}

func (fake *FakeCheck) ResourceConfigIDReturns(result1 int) {
	fake.resourceConfigIDMutex.Lock()
	defer fake.resourceConfigIDMutex.Unlock()
	fake.ResourceConfigIDStub = nil
	fake.resourceConfigIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) ResourceConfigIDReturnsOnCall(i int, result1 int) {
	fake.resourceConfigIDMutex.Lock()
	defer fake.resourceConfigIDMutex.Unlock()
	fake.ResourceConfigIDStub = nil
	if fake.resourceConfigIDReturnsOnCall == nil {
		fake.resourceConfigIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.resourceConfigIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) ResourceConfigScopeID() int {
	fake.resourceConfigScopeIDMutex.Lock()
	ret, specificReturn := fake.resourceConfigScopeIDReturnsOnCall[len(fake.resourceConfigScopeIDArgsForCall)]
	fake.resourceConfigScopeIDArgsForCall = append(fake.resourceConfigScopeIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceConfigScopeID", []interface{}{})
	fake.resourceConfigScopeIDMutex.Unlock()
	if fake.ResourceConfigScopeIDStub != nil {
		return fake.ResourceConfigScopeIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceConfigScopeIDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) ResourceConfigScopeIDCallCount() int {
	fake.resourceConfigScopeIDMutex.RLock()
	defer fake.resourceConfigScopeIDMutex.RUnlock()
	return len(fake.resourceConfigScopeIDArgsForCall)
}

func (fake *FakeCheck) ResourceConfigScopeIDCalls(stub func() int) {
	fake.resourceConfigScopeIDMutex.Lock()
	defer fake.resourceConfigScopeIDMutex.Unlock()
	fake.ResourceConfigScopeIDStub = stub
}

func (fake *FakeCheck) ResourceConfigScopeIDReturns(result1 int) {
	fake.resourceConfigScopeIDMutex.Lock()
	defer fake.resourceConfigScopeIDMutex.Unlock()
	fake.ResourceConfigScopeIDStub = nil
	fake.resourceConfigScopeIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) ResourceConfigScopeIDReturnsOnCall(i int, result1 int) {
	fake.resourceConfigScopeIDMutex.Lock()
	defer fake.resourceConfigScopeIDMutex.Unlock()
	fake.ResourceConfigScopeIDStub = nil
	if fake.resourceConfigScopeIDReturnsOnCall == nil {
		fake.resourceConfigScopeIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.resourceConfigScopeIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) SaveVersions(arg1 db.SpanContext, arg2 []atc.Version) error {
	var arg2Copy []atc.Version
	if arg2 != nil {
		arg2Copy = make([]atc.Version, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.saveVersionsMutex.Lock()
	ret, specificReturn := fake.saveVersionsReturnsOnCall[len(fake.saveVersionsArgsForCall)]
	fake.saveVersionsArgsForCall = append(fake.saveVersionsArgsForCall, struct {
		arg1 db.SpanContext
		arg2 []atc.Version
	}{arg1, arg2Copy})
	fake.recordInvocation("SaveVersions", []interface{}{arg1, arg2Copy})
	fake.saveVersionsMutex.Unlock()
	if fake.SaveVersionsStub != nil {
		return fake.SaveVersionsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveVersionsReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) SaveVersionsCallCount() int {
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	return len(fake.saveVersionsArgsForCall)
}

func (fake *FakeCheck) SaveVersionsCalls(stub func(db.SpanContext, []atc.Version) error) {
	fake.saveVersionsMutex.Lock()
	defer fake.saveVersionsMutex.Unlock()
	fake.SaveVersionsStub = stub
}

func (fake *FakeCheck) SaveVersionsArgsForCall(i int) (db.SpanContext, []atc.Version) {
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	argsForCall := fake.saveVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCheck) SaveVersionsReturns(result1 error) {
	fake.saveVersionsMutex.Lock()
	defer fake.saveVersionsMutex.Unlock()
	fake.SaveVersionsStub = nil
	fake.saveVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) SaveVersionsReturnsOnCall(i int, result1 error) {
	fake.saveVersionsMutex.Lock()
	defer fake.saveVersionsMutex.Unlock()
	fake.SaveVersionsStub = nil
	if fake.saveVersionsReturnsOnCall == nil {
		fake.saveVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) Schema() string {
	fake.schemaMutex.Lock()
	ret, specificReturn := fake.schemaReturnsOnCall[len(fake.schemaArgsForCall)]
	fake.schemaArgsForCall = append(fake.schemaArgsForCall, struct {
	}{})
	fake.recordInvocation("Schema", []interface{}{})
	fake.schemaMutex.Unlock()
	if fake.SchemaStub != nil {
		return fake.SchemaStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.schemaReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) SchemaCallCount() int {
	fake.schemaMutex.RLock()
	defer fake.schemaMutex.RUnlock()
	return len(fake.schemaArgsForCall)
}

func (fake *FakeCheck) SchemaCalls(stub func() string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = stub
}

func (fake *FakeCheck) SchemaReturns(result1 string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = nil
	fake.schemaReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCheck) SchemaReturnsOnCall(i int, result1 string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = nil
	if fake.schemaReturnsOnCall == nil {
		fake.schemaReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.schemaReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeCheck) SpanContext() propagators.Supplier {
	fake.spanContextMutex.Lock()
	ret, specificReturn := fake.spanContextReturnsOnCall[len(fake.spanContextArgsForCall)]
	fake.spanContextArgsForCall = append(fake.spanContextArgsForCall, struct {
	}{})
	fake.recordInvocation("SpanContext", []interface{}{})
	fake.spanContextMutex.Unlock()
	if fake.SpanContextStub != nil {
		return fake.SpanContextStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.spanContextReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) SpanContextCallCount() int {
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	return len(fake.spanContextArgsForCall)
}

func (fake *FakeCheck) SpanContextCalls(stub func() propagators.Supplier) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = stub
}

func (fake *FakeCheck) SpanContextReturns(result1 propagators.Supplier) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	fake.spanContextReturns = struct {
		result1 propagators.Supplier
	}{result1}
}

func (fake *FakeCheck) SpanContextReturnsOnCall(i int, result1 propagators.Supplier) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	if fake.spanContextReturnsOnCall == nil {
		fake.spanContextReturnsOnCall = make(map[int]struct {
			result1 propagators.Supplier
		})
	}
	fake.spanContextReturnsOnCall[i] = struct {
		result1 propagators.Supplier
	}{result1}
}

func (fake *FakeCheck) Start() error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
	}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeCheck) StartCalls(stub func() error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeCheck) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCheck) StartTime() time.Time {
	fake.startTimeMutex.Lock()
	ret, specificReturn := fake.startTimeReturnsOnCall[len(fake.startTimeArgsForCall)]
	fake.startTimeArgsForCall = append(fake.startTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("StartTime", []interface{}{})
	fake.startTimeMutex.Unlock()
	if fake.StartTimeStub != nil {
		return fake.StartTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startTimeReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) StartTimeCallCount() int {
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	return len(fake.startTimeArgsForCall)
}

func (fake *FakeCheck) StartTimeCalls(stub func() time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = stub
}

func (fake *FakeCheck) StartTimeReturns(result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	fake.startTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) StartTimeReturnsOnCall(i int, result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	if fake.startTimeReturnsOnCall == nil {
		fake.startTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.startTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeCheck) Status() db.CheckStatus {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if fake.StatusStub != nil {
		return fake.StatusStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.statusReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeCheck) StatusCalls(stub func() db.CheckStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeCheck) StatusReturns(result1 db.CheckStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 db.CheckStatus
	}{result1}
}

func (fake *FakeCheck) StatusReturnsOnCall(i int, result1 db.CheckStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 db.CheckStatus
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 db.CheckStatus
	}{result1}
}

func (fake *FakeCheck) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamIDReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakeCheck) TeamIDCalls(stub func() int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = stub
}

func (fake *FakeCheck) TeamIDReturns(result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) TeamIDReturnsOnCall(i int, result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeCheck) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if fake.TeamNameStub != nil {
		return fake.TeamNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamNameReturns
	return fakeReturns.result1
}

func (fake *FakeCheck) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakeCheck) TeamNameCalls(stub func() string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = stub
}

func (fake *FakeCheck) TeamNameReturns(result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCheck) TeamNameReturnsOnCall(i int, result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeCheck) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	fake.allCheckablesMutex.RLock()
	defer fake.allCheckablesMutex.RUnlock()
	fake.baseResourceTypeIDMutex.RLock()
	defer fake.baseResourceTypeIDMutex.RUnlock()
	fake.checkErrorMutex.RLock()
	defer fake.checkErrorMutex.RUnlock()
	fake.createTimeMutex.RLock()
	defer fake.createTimeMutex.RUnlock()
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.manuallyTriggeredMutex.RLock()
	defer fake.manuallyTriggeredMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	fake.pipelineInstanceVarsMutex.RLock()
	defer fake.pipelineInstanceVarsMutex.RUnlock()
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	fake.pipelineRefMutex.RLock()
	defer fake.pipelineRefMutex.RUnlock()
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.resourceConfigIDMutex.RLock()
	defer fake.resourceConfigIDMutex.RUnlock()
	fake.resourceConfigScopeIDMutex.RLock()
	defer fake.resourceConfigScopeIDMutex.RUnlock()
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	fake.schemaMutex.RLock()
	defer fake.schemaMutex.RUnlock()
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCheck) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Check = new(FakeCheck)
