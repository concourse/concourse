// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"encoding/json"
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/creds"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/db/lock"
	"github.com/concourse/concourse/atc/event"
	"github.com/concourse/concourse/tracing"
	"github.com/concourse/concourse/vars"
	"go.opentelemetry.io/otel/api/propagation"
)

type FakeBuild struct {
	AbortNotifierStub        func() (db.Notifier, error)
	abortNotifierMutex       sync.RWMutex
	abortNotifierArgsForCall []struct {
	}
	abortNotifierReturns struct {
		result1 db.Notifier
		result2 error
	}
	abortNotifierReturnsOnCall map[int]struct {
		result1 db.Notifier
		result2 error
	}
	AcquireTrackingLockStub        func(lager.Logger, time.Duration) (lock.Lock, bool, error)
	acquireTrackingLockMutex       sync.RWMutex
	acquireTrackingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	acquireTrackingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireTrackingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AdoptInputsAndPipesStub        func() ([]db.BuildInput, bool, error)
	adoptInputsAndPipesMutex       sync.RWMutex
	adoptInputsAndPipesArgsForCall []struct {
	}
	adoptInputsAndPipesReturns struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	adoptInputsAndPipesReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	AdoptRerunInputsAndPipesStub        func() ([]db.BuildInput, bool, error)
	adoptRerunInputsAndPipesMutex       sync.RWMutex
	adoptRerunInputsAndPipesArgsForCall []struct {
	}
	adoptRerunInputsAndPipesReturns struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	adoptRerunInputsAndPipesReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	ArtifactStub        func(int) (db.WorkerArtifact, error)
	artifactMutex       sync.RWMutex
	artifactArgsForCall []struct {
		arg1 int
	}
	artifactReturns struct {
		result1 db.WorkerArtifact
		result2 error
	}
	artifactReturnsOnCall map[int]struct {
		result1 db.WorkerArtifact
		result2 error
	}
	ArtifactsStub        func() ([]db.WorkerArtifact, error)
	artifactsMutex       sync.RWMutex
	artifactsArgsForCall []struct {
	}
	artifactsReturns struct {
		result1 []db.WorkerArtifact
		result2 error
	}
	artifactsReturnsOnCall map[int]struct {
		result1 []db.WorkerArtifact
		result2 error
	}
	DeleteStub        func() (bool, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
	}
	deleteReturns struct {
		result1 bool
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EndTimeStub        func() time.Time
	endTimeMutex       sync.RWMutex
	endTimeArgsForCall []struct {
	}
	endTimeReturns struct {
		result1 time.Time
	}
	endTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	EventsStub        func(uint) (db.EventSource, error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 uint
	}
	eventsReturns struct {
		result1 db.EventSource
		result2 error
	}
	eventsReturnsOnCall map[int]struct {
		result1 db.EventSource
		result2 error
	}
	FinishStub        func(db.BuildStatus) error
	finishMutex       sync.RWMutex
	finishArgsForCall []struct {
		arg1 db.BuildStatus
	}
	finishReturns struct {
		result1 error
	}
	finishReturnsOnCall map[int]struct {
		result1 error
	}
	HasPlanStub        func() bool
	hasPlanMutex       sync.RWMutex
	hasPlanArgsForCall []struct {
	}
	hasPlanReturns struct {
		result1 bool
	}
	hasPlanReturnsOnCall map[int]struct {
		result1 bool
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	InputsReadyStub        func() bool
	inputsReadyMutex       sync.RWMutex
	inputsReadyArgsForCall []struct {
	}
	inputsReadyReturns struct {
		result1 bool
	}
	inputsReadyReturnsOnCall map[int]struct {
		result1 bool
	}
	InterceptibleStub        func() (bool, error)
	interceptibleMutex       sync.RWMutex
	interceptibleArgsForCall []struct {
	}
	interceptibleReturns struct {
		result1 bool
		result2 error
	}
	interceptibleReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsAbortedStub        func() bool
	isAbortedMutex       sync.RWMutex
	isAbortedArgsForCall []struct {
	}
	isAbortedReturns struct {
		result1 bool
	}
	isAbortedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsCompletedStub        func() bool
	isCompletedMutex       sync.RWMutex
	isCompletedArgsForCall []struct {
	}
	isCompletedReturns struct {
		result1 bool
	}
	isCompletedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsDrainedStub        func() bool
	isDrainedMutex       sync.RWMutex
	isDrainedArgsForCall []struct {
	}
	isDrainedReturns struct {
		result1 bool
	}
	isDrainedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsManuallyTriggeredStub        func() bool
	isManuallyTriggeredMutex       sync.RWMutex
	isManuallyTriggeredArgsForCall []struct {
	}
	isManuallyTriggeredReturns struct {
		result1 bool
	}
	isManuallyTriggeredReturnsOnCall map[int]struct {
		result1 bool
	}
	IsNewerThanLastCheckOfStub        func(db.Resource) bool
	isNewerThanLastCheckOfMutex       sync.RWMutex
	isNewerThanLastCheckOfArgsForCall []struct {
		arg1 db.Resource
	}
	isNewerThanLastCheckOfReturns struct {
		result1 bool
	}
	isNewerThanLastCheckOfReturnsOnCall map[int]struct {
		result1 bool
	}
	IsRunningStub        func() bool
	isRunningMutex       sync.RWMutex
	isRunningArgsForCall []struct {
	}
	isRunningReturns struct {
		result1 bool
	}
	isRunningReturnsOnCall map[int]struct {
		result1 bool
	}
	IsScheduledStub        func() bool
	isScheduledMutex       sync.RWMutex
	isScheduledArgsForCall []struct {
	}
	isScheduledReturns struct {
		result1 bool
	}
	isScheduledReturnsOnCall map[int]struct {
		result1 bool
	}
	JobDisplayNameStub        func() string
	jobDisplayNameMutex       sync.RWMutex
	jobDisplayNameArgsForCall []struct {
	}
	jobDisplayNameReturns struct {
		result1 string
	}
	jobDisplayNameReturnsOnCall map[int]struct {
		result1 string
	}
	JobIDStub        func() int
	jobIDMutex       sync.RWMutex
	jobIDArgsForCall []struct {
	}
	jobIDReturns struct {
		result1 int
	}
	jobIDReturnsOnCall map[int]struct {
		result1 int
	}
	JobNameStub        func() string
	jobNameMutex       sync.RWMutex
	jobNameArgsForCall []struct {
	}
	jobNameReturns struct {
		result1 string
	}
	jobNameReturnsOnCall map[int]struct {
		result1 string
	}
	LagerDataStub        func() lager.Data
	lagerDataMutex       sync.RWMutex
	lagerDataArgsForCall []struct {
	}
	lagerDataReturns struct {
		result1 lager.Data
	}
	lagerDataReturnsOnCall map[int]struct {
		result1 lager.Data
	}
	MarkAsAbortedStub        func() error
	markAsAbortedMutex       sync.RWMutex
	markAsAbortedArgsForCall []struct {
	}
	markAsAbortedReturns struct {
		result1 error
	}
	markAsAbortedReturnsOnCall map[int]struct {
		result1 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	PipelineStub        func() (db.Pipeline, bool, error)
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct {
	}
	pipelineReturns struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	pipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	PipelineIDStub        func() int
	pipelineIDMutex       sync.RWMutex
	pipelineIDArgsForCall []struct {
	}
	pipelineIDReturns struct {
		result1 int
	}
	pipelineIDReturnsOnCall map[int]struct {
		result1 int
	}
	PipelineInstanceVarsStub        func() atc.InstanceVars
	pipelineInstanceVarsMutex       sync.RWMutex
	pipelineInstanceVarsArgsForCall []struct {
	}
	pipelineInstanceVarsReturns struct {
		result1 atc.InstanceVars
	}
	pipelineInstanceVarsReturnsOnCall map[int]struct {
		result1 atc.InstanceVars
	}
	PipelineNameStub        func() string
	pipelineNameMutex       sync.RWMutex
	pipelineNameArgsForCall []struct {
	}
	pipelineNameReturns struct {
		result1 string
	}
	pipelineNameReturnsOnCall map[int]struct {
		result1 string
	}
	PipelineRefStub        func() atc.PipelineRef
	pipelineRefMutex       sync.RWMutex
	pipelineRefArgsForCall []struct {
	}
	pipelineRefReturns struct {
		result1 atc.PipelineRef
	}
	pipelineRefReturnsOnCall map[int]struct {
		result1 atc.PipelineRef
	}
	PreparationStub        func() (db.BuildPreparation, bool, error)
	preparationMutex       sync.RWMutex
	preparationArgsForCall []struct {
	}
	preparationReturns struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}
	preparationReturnsOnCall map[int]struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}
	PrivatePlanStub        func() atc.Plan
	privatePlanMutex       sync.RWMutex
	privatePlanArgsForCall []struct {
	}
	privatePlanReturns struct {
		result1 atc.Plan
	}
	privatePlanReturnsOnCall map[int]struct {
		result1 atc.Plan
	}
	PublicPlanStub        func() *json.RawMessage
	publicPlanMutex       sync.RWMutex
	publicPlanArgsForCall []struct {
	}
	publicPlanReturns struct {
		result1 *json.RawMessage
	}
	publicPlanReturnsOnCall map[int]struct {
		result1 *json.RawMessage
	}
	ReapTimeStub        func() time.Time
	reapTimeMutex       sync.RWMutex
	reapTimeArgsForCall []struct {
	}
	reapTimeReturns struct {
		result1 time.Time
	}
	reapTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
	}
	reloadReturns struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RerunNumberStub        func() int
	rerunNumberMutex       sync.RWMutex
	rerunNumberArgsForCall []struct {
	}
	rerunNumberReturns struct {
		result1 int
	}
	rerunNumberReturnsOnCall map[int]struct {
		result1 int
	}
	RerunOfStub        func() int
	rerunOfMutex       sync.RWMutex
	rerunOfArgsForCall []struct {
	}
	rerunOfReturns struct {
		result1 int
	}
	rerunOfReturnsOnCall map[int]struct {
		result1 int
	}
	RerunOfNameStub        func() string
	rerunOfNameMutex       sync.RWMutex
	rerunOfNameArgsForCall []struct {
	}
	rerunOfNameReturns struct {
		result1 string
	}
	rerunOfNameReturnsOnCall map[int]struct {
		result1 string
	}
	ResourceIDStub        func() int
	resourceIDMutex       sync.RWMutex
	resourceIDArgsForCall []struct {
	}
	resourceIDReturns struct {
		result1 int
	}
	resourceIDReturnsOnCall map[int]struct {
		result1 int
	}
	ResourceNameStub        func() string
	resourceNameMutex       sync.RWMutex
	resourceNameArgsForCall []struct {
	}
	resourceNameReturns struct {
		result1 string
	}
	resourceNameReturnsOnCall map[int]struct {
		result1 string
	}
	ResourceTypeIDStub        func() int
	resourceTypeIDMutex       sync.RWMutex
	resourceTypeIDArgsForCall []struct {
	}
	resourceTypeIDReturns struct {
		result1 int
	}
	resourceTypeIDReturnsOnCall map[int]struct {
		result1 int
	}
	ResourceTypeNameStub        func() string
	resourceTypeNameMutex       sync.RWMutex
	resourceTypeNameArgsForCall []struct {
	}
	resourceTypeNameReturns struct {
		result1 string
	}
	resourceTypeNameReturnsOnCall map[int]struct {
		result1 string
	}
	ResourcesStub        func() ([]db.BuildInput, []db.BuildOutput, error)
	resourcesMutex       sync.RWMutex
	resourcesArgsForCall []struct {
	}
	resourcesReturns struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}
	resourcesReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}
	ResourcesCheckedStub        func() (bool, error)
	resourcesCheckedMutex       sync.RWMutex
	resourcesCheckedArgsForCall []struct {
	}
	resourcesCheckedReturns struct {
		result1 bool
		result2 error
	}
	resourcesCheckedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SaveEventStub        func(atc.Event) error
	saveEventMutex       sync.RWMutex
	saveEventArgsForCall []struct {
		arg1 atc.Event
	}
	saveEventReturns struct {
		result1 error
	}
	saveEventReturnsOnCall map[int]struct {
		result1 error
	}
	SaveImageResourceVersionStub        func(db.UsedResourceCache) error
	saveImageResourceVersionMutex       sync.RWMutex
	saveImageResourceVersionArgsForCall []struct {
		arg1 db.UsedResourceCache
	}
	saveImageResourceVersionReturns struct {
		result1 error
	}
	saveImageResourceVersionReturnsOnCall map[int]struct {
		result1 error
	}
	SaveOutputStub        func(string, atc.Source, atc.VersionedResourceTypes, atc.Version, db.ResourceConfigMetadataFields, string, string) error
	saveOutputMutex       sync.RWMutex
	saveOutputArgsForCall []struct {
		arg1 string
		arg2 atc.Source
		arg3 atc.VersionedResourceTypes
		arg4 atc.Version
		arg5 db.ResourceConfigMetadataFields
		arg6 string
		arg7 string
	}
	saveOutputReturns struct {
		result1 error
	}
	saveOutputReturnsOnCall map[int]struct {
		result1 error
	}
	SavePipelineStub        func(atc.PipelineRef, int, atc.Config, db.ConfigVersion, bool) (db.Pipeline, bool, error)
	savePipelineMutex       sync.RWMutex
	savePipelineArgsForCall []struct {
		arg1 atc.PipelineRef
		arg2 int
		arg3 atc.Config
		arg4 db.ConfigVersion
		arg5 bool
	}
	savePipelineReturns struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	savePipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	SchemaStub        func() string
	schemaMutex       sync.RWMutex
	schemaArgsForCall []struct {
	}
	schemaReturns struct {
		result1 string
	}
	schemaReturnsOnCall map[int]struct {
		result1 string
	}
	SetDrainedStub        func(bool) error
	setDrainedMutex       sync.RWMutex
	setDrainedArgsForCall []struct {
		arg1 bool
	}
	setDrainedReturns struct {
		result1 error
	}
	setDrainedReturnsOnCall map[int]struct {
		result1 error
	}
	SetInterceptibleStub        func(bool) error
	setInterceptibleMutex       sync.RWMutex
	setInterceptibleArgsForCall []struct {
		arg1 bool
	}
	setInterceptibleReturns struct {
		result1 error
	}
	setInterceptibleReturnsOnCall map[int]struct {
		result1 error
	}
	SpanContextStub        func() propagation.HTTPSupplier
	spanContextMutex       sync.RWMutex
	spanContextArgsForCall []struct {
	}
	spanContextReturns struct {
		result1 propagation.HTTPSupplier
	}
	spanContextReturnsOnCall map[int]struct {
		result1 propagation.HTTPSupplier
	}
	StartStub        func(atc.Plan) (bool, error)
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 atc.Plan
	}
	startReturns struct {
		result1 bool
		result2 error
	}
	startReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	StartTimeStub        func() time.Time
	startTimeMutex       sync.RWMutex
	startTimeArgsForCall []struct {
	}
	startTimeReturns struct {
		result1 time.Time
	}
	startTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	StatusStub        func() db.BuildStatus
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 db.BuildStatus
	}
	statusReturnsOnCall map[int]struct {
		result1 db.BuildStatus
	}
	SyslogTagStub        func(event.OriginID) string
	syslogTagMutex       sync.RWMutex
	syslogTagArgsForCall []struct {
		arg1 event.OriginID
	}
	syslogTagReturns struct {
		result1 string
	}
	syslogTagReturnsOnCall map[int]struct {
		result1 string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	TracingAttrsStub        func() tracing.Attrs
	tracingAttrsMutex       sync.RWMutex
	tracingAttrsArgsForCall []struct {
	}
	tracingAttrsReturns struct {
		result1 tracing.Attrs
	}
	tracingAttrsReturnsOnCall map[int]struct {
		result1 tracing.Attrs
	}
	VariablesStub        func(lager.Logger, creds.Secrets, creds.VarSourcePool) (vars.Variables, error)
	variablesMutex       sync.RWMutex
	variablesArgsForCall []struct {
		arg1 lager.Logger
		arg2 creds.Secrets
		arg3 creds.VarSourcePool
	}
	variablesReturns struct {
		result1 vars.Variables
		result2 error
	}
	variablesReturnsOnCall map[int]struct {
		result1 vars.Variables
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBuild) AbortNotifier() (db.Notifier, error) {
	fake.abortNotifierMutex.Lock()
	ret, specificReturn := fake.abortNotifierReturnsOnCall[len(fake.abortNotifierArgsForCall)]
	fake.abortNotifierArgsForCall = append(fake.abortNotifierArgsForCall, struct {
	}{})
	fake.recordInvocation("AbortNotifier", []interface{}{})
	fake.abortNotifierMutex.Unlock()
	if fake.AbortNotifierStub != nil {
		return fake.AbortNotifierStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.abortNotifierReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) AbortNotifierCallCount() int {
	fake.abortNotifierMutex.RLock()
	defer fake.abortNotifierMutex.RUnlock()
	return len(fake.abortNotifierArgsForCall)
}

func (fake *FakeBuild) AbortNotifierCalls(stub func() (db.Notifier, error)) {
	fake.abortNotifierMutex.Lock()
	defer fake.abortNotifierMutex.Unlock()
	fake.AbortNotifierStub = stub
}

func (fake *FakeBuild) AbortNotifierReturns(result1 db.Notifier, result2 error) {
	fake.abortNotifierMutex.Lock()
	defer fake.abortNotifierMutex.Unlock()
	fake.AbortNotifierStub = nil
	fake.abortNotifierReturns = struct {
		result1 db.Notifier
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) AbortNotifierReturnsOnCall(i int, result1 db.Notifier, result2 error) {
	fake.abortNotifierMutex.Lock()
	defer fake.abortNotifierMutex.Unlock()
	fake.AbortNotifierStub = nil
	if fake.abortNotifierReturnsOnCall == nil {
		fake.abortNotifierReturnsOnCall = make(map[int]struct {
			result1 db.Notifier
			result2 error
		})
	}
	fake.abortNotifierReturnsOnCall[i] = struct {
		result1 db.Notifier
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) AcquireTrackingLock(arg1 lager.Logger, arg2 time.Duration) (lock.Lock, bool, error) {
	fake.acquireTrackingLockMutex.Lock()
	ret, specificReturn := fake.acquireTrackingLockReturnsOnCall[len(fake.acquireTrackingLockArgsForCall)]
	fake.acquireTrackingLockArgsForCall = append(fake.acquireTrackingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("AcquireTrackingLock", []interface{}{arg1, arg2})
	fake.acquireTrackingLockMutex.Unlock()
	if fake.AcquireTrackingLockStub != nil {
		return fake.AcquireTrackingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireTrackingLockReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuild) AcquireTrackingLockCallCount() int {
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	return len(fake.acquireTrackingLockArgsForCall)
}

func (fake *FakeBuild) AcquireTrackingLockCalls(stub func(lager.Logger, time.Duration) (lock.Lock, bool, error)) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = stub
}

func (fake *FakeBuild) AcquireTrackingLockArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	argsForCall := fake.acquireTrackingLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuild) AcquireTrackingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = nil
	fake.acquireTrackingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) AcquireTrackingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireTrackingLockMutex.Lock()
	defer fake.acquireTrackingLockMutex.Unlock()
	fake.AcquireTrackingLockStub = nil
	if fake.acquireTrackingLockReturnsOnCall == nil {
		fake.acquireTrackingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireTrackingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) AdoptInputsAndPipes() ([]db.BuildInput, bool, error) {
	fake.adoptInputsAndPipesMutex.Lock()
	ret, specificReturn := fake.adoptInputsAndPipesReturnsOnCall[len(fake.adoptInputsAndPipesArgsForCall)]
	fake.adoptInputsAndPipesArgsForCall = append(fake.adoptInputsAndPipesArgsForCall, struct {
	}{})
	fake.recordInvocation("AdoptInputsAndPipes", []interface{}{})
	fake.adoptInputsAndPipesMutex.Unlock()
	if fake.AdoptInputsAndPipesStub != nil {
		return fake.AdoptInputsAndPipesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.adoptInputsAndPipesReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuild) AdoptInputsAndPipesCallCount() int {
	fake.adoptInputsAndPipesMutex.RLock()
	defer fake.adoptInputsAndPipesMutex.RUnlock()
	return len(fake.adoptInputsAndPipesArgsForCall)
}

func (fake *FakeBuild) AdoptInputsAndPipesCalls(stub func() ([]db.BuildInput, bool, error)) {
	fake.adoptInputsAndPipesMutex.Lock()
	defer fake.adoptInputsAndPipesMutex.Unlock()
	fake.AdoptInputsAndPipesStub = stub
}

func (fake *FakeBuild) AdoptInputsAndPipesReturns(result1 []db.BuildInput, result2 bool, result3 error) {
	fake.adoptInputsAndPipesMutex.Lock()
	defer fake.adoptInputsAndPipesMutex.Unlock()
	fake.AdoptInputsAndPipesStub = nil
	fake.adoptInputsAndPipesReturns = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) AdoptInputsAndPipesReturnsOnCall(i int, result1 []db.BuildInput, result2 bool, result3 error) {
	fake.adoptInputsAndPipesMutex.Lock()
	defer fake.adoptInputsAndPipesMutex.Unlock()
	fake.AdoptInputsAndPipesStub = nil
	if fake.adoptInputsAndPipesReturnsOnCall == nil {
		fake.adoptInputsAndPipesReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 bool
			result3 error
		})
	}
	fake.adoptInputsAndPipesReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) AdoptRerunInputsAndPipes() ([]db.BuildInput, bool, error) {
	fake.adoptRerunInputsAndPipesMutex.Lock()
	ret, specificReturn := fake.adoptRerunInputsAndPipesReturnsOnCall[len(fake.adoptRerunInputsAndPipesArgsForCall)]
	fake.adoptRerunInputsAndPipesArgsForCall = append(fake.adoptRerunInputsAndPipesArgsForCall, struct {
	}{})
	fake.recordInvocation("AdoptRerunInputsAndPipes", []interface{}{})
	fake.adoptRerunInputsAndPipesMutex.Unlock()
	if fake.AdoptRerunInputsAndPipesStub != nil {
		return fake.AdoptRerunInputsAndPipesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.adoptRerunInputsAndPipesReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuild) AdoptRerunInputsAndPipesCallCount() int {
	fake.adoptRerunInputsAndPipesMutex.RLock()
	defer fake.adoptRerunInputsAndPipesMutex.RUnlock()
	return len(fake.adoptRerunInputsAndPipesArgsForCall)
}

func (fake *FakeBuild) AdoptRerunInputsAndPipesCalls(stub func() ([]db.BuildInput, bool, error)) {
	fake.adoptRerunInputsAndPipesMutex.Lock()
	defer fake.adoptRerunInputsAndPipesMutex.Unlock()
	fake.AdoptRerunInputsAndPipesStub = stub
}

func (fake *FakeBuild) AdoptRerunInputsAndPipesReturns(result1 []db.BuildInput, result2 bool, result3 error) {
	fake.adoptRerunInputsAndPipesMutex.Lock()
	defer fake.adoptRerunInputsAndPipesMutex.Unlock()
	fake.AdoptRerunInputsAndPipesStub = nil
	fake.adoptRerunInputsAndPipesReturns = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) AdoptRerunInputsAndPipesReturnsOnCall(i int, result1 []db.BuildInput, result2 bool, result3 error) {
	fake.adoptRerunInputsAndPipesMutex.Lock()
	defer fake.adoptRerunInputsAndPipesMutex.Unlock()
	fake.AdoptRerunInputsAndPipesStub = nil
	if fake.adoptRerunInputsAndPipesReturnsOnCall == nil {
		fake.adoptRerunInputsAndPipesReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 bool
			result3 error
		})
	}
	fake.adoptRerunInputsAndPipesReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) Artifact(arg1 int) (db.WorkerArtifact, error) {
	fake.artifactMutex.Lock()
	ret, specificReturn := fake.artifactReturnsOnCall[len(fake.artifactArgsForCall)]
	fake.artifactArgsForCall = append(fake.artifactArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Artifact", []interface{}{arg1})
	fake.artifactMutex.Unlock()
	if fake.ArtifactStub != nil {
		return fake.ArtifactStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.artifactReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) ArtifactCallCount() int {
	fake.artifactMutex.RLock()
	defer fake.artifactMutex.RUnlock()
	return len(fake.artifactArgsForCall)
}

func (fake *FakeBuild) ArtifactCalls(stub func(int) (db.WorkerArtifact, error)) {
	fake.artifactMutex.Lock()
	defer fake.artifactMutex.Unlock()
	fake.ArtifactStub = stub
}

func (fake *FakeBuild) ArtifactArgsForCall(i int) int {
	fake.artifactMutex.RLock()
	defer fake.artifactMutex.RUnlock()
	argsForCall := fake.artifactArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) ArtifactReturns(result1 db.WorkerArtifact, result2 error) {
	fake.artifactMutex.Lock()
	defer fake.artifactMutex.Unlock()
	fake.ArtifactStub = nil
	fake.artifactReturns = struct {
		result1 db.WorkerArtifact
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) ArtifactReturnsOnCall(i int, result1 db.WorkerArtifact, result2 error) {
	fake.artifactMutex.Lock()
	defer fake.artifactMutex.Unlock()
	fake.ArtifactStub = nil
	if fake.artifactReturnsOnCall == nil {
		fake.artifactReturnsOnCall = make(map[int]struct {
			result1 db.WorkerArtifact
			result2 error
		})
	}
	fake.artifactReturnsOnCall[i] = struct {
		result1 db.WorkerArtifact
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) Artifacts() ([]db.WorkerArtifact, error) {
	fake.artifactsMutex.Lock()
	ret, specificReturn := fake.artifactsReturnsOnCall[len(fake.artifactsArgsForCall)]
	fake.artifactsArgsForCall = append(fake.artifactsArgsForCall, struct {
	}{})
	fake.recordInvocation("Artifacts", []interface{}{})
	fake.artifactsMutex.Unlock()
	if fake.ArtifactsStub != nil {
		return fake.ArtifactsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.artifactsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) ArtifactsCallCount() int {
	fake.artifactsMutex.RLock()
	defer fake.artifactsMutex.RUnlock()
	return len(fake.artifactsArgsForCall)
}

func (fake *FakeBuild) ArtifactsCalls(stub func() ([]db.WorkerArtifact, error)) {
	fake.artifactsMutex.Lock()
	defer fake.artifactsMutex.Unlock()
	fake.ArtifactsStub = stub
}

func (fake *FakeBuild) ArtifactsReturns(result1 []db.WorkerArtifact, result2 error) {
	fake.artifactsMutex.Lock()
	defer fake.artifactsMutex.Unlock()
	fake.ArtifactsStub = nil
	fake.artifactsReturns = struct {
		result1 []db.WorkerArtifact
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) ArtifactsReturnsOnCall(i int, result1 []db.WorkerArtifact, result2 error) {
	fake.artifactsMutex.Lock()
	defer fake.artifactsMutex.Unlock()
	fake.ArtifactsStub = nil
	if fake.artifactsReturnsOnCall == nil {
		fake.artifactsReturnsOnCall = make(map[int]struct {
			result1 []db.WorkerArtifact
			result2 error
		})
	}
	fake.artifactsReturnsOnCall[i] = struct {
		result1 []db.WorkerArtifact
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) Delete() (bool, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
	}{})
	fake.recordInvocation("Delete", []interface{}{})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeBuild) DeleteCalls(stub func() (bool, error)) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeBuild) DeleteReturns(result1 bool, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) DeleteReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) EndTime() time.Time {
	fake.endTimeMutex.Lock()
	ret, specificReturn := fake.endTimeReturnsOnCall[len(fake.endTimeArgsForCall)]
	fake.endTimeArgsForCall = append(fake.endTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("EndTime", []interface{}{})
	fake.endTimeMutex.Unlock()
	if fake.EndTimeStub != nil {
		return fake.EndTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.endTimeReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) EndTimeCallCount() int {
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	return len(fake.endTimeArgsForCall)
}

func (fake *FakeBuild) EndTimeCalls(stub func() time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = stub
}

func (fake *FakeBuild) EndTimeReturns(result1 time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = nil
	fake.endTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) EndTimeReturnsOnCall(i int, result1 time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = nil
	if fake.endTimeReturnsOnCall == nil {
		fake.endTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.endTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) Events(arg1 uint) (db.EventSource, error) {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 uint
	}{arg1})
	fake.recordInvocation("Events", []interface{}{arg1})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.eventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeBuild) EventsCalls(stub func(uint) (db.EventSource, error)) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = stub
}

func (fake *FakeBuild) EventsArgsForCall(i int) uint {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	argsForCall := fake.eventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) EventsReturns(result1 db.EventSource, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 db.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) EventsReturnsOnCall(i int, result1 db.EventSource, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 db.EventSource
			result2 error
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 db.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) Finish(arg1 db.BuildStatus) error {
	fake.finishMutex.Lock()
	ret, specificReturn := fake.finishReturnsOnCall[len(fake.finishArgsForCall)]
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct {
		arg1 db.BuildStatus
	}{arg1})
	fake.recordInvocation("Finish", []interface{}{arg1})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		return fake.FinishStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeBuild) FinishCalls(stub func(db.BuildStatus) error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = stub
}

func (fake *FakeBuild) FinishArgsForCall(i int) db.BuildStatus {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	argsForCall := fake.finishArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) FinishReturns(result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	fake.finishReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) FinishReturnsOnCall(i int, result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	if fake.finishReturnsOnCall == nil {
		fake.finishReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) HasPlan() bool {
	fake.hasPlanMutex.Lock()
	ret, specificReturn := fake.hasPlanReturnsOnCall[len(fake.hasPlanArgsForCall)]
	fake.hasPlanArgsForCall = append(fake.hasPlanArgsForCall, struct {
	}{})
	fake.recordInvocation("HasPlan", []interface{}{})
	fake.hasPlanMutex.Unlock()
	if fake.HasPlanStub != nil {
		return fake.HasPlanStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasPlanReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) HasPlanCallCount() int {
	fake.hasPlanMutex.RLock()
	defer fake.hasPlanMutex.RUnlock()
	return len(fake.hasPlanArgsForCall)
}

func (fake *FakeBuild) HasPlanCalls(stub func() bool) {
	fake.hasPlanMutex.Lock()
	defer fake.hasPlanMutex.Unlock()
	fake.HasPlanStub = stub
}

func (fake *FakeBuild) HasPlanReturns(result1 bool) {
	fake.hasPlanMutex.Lock()
	defer fake.hasPlanMutex.Unlock()
	fake.HasPlanStub = nil
	fake.hasPlanReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) HasPlanReturnsOnCall(i int, result1 bool) {
	fake.hasPlanMutex.Lock()
	defer fake.hasPlanMutex.Unlock()
	fake.HasPlanStub = nil
	if fake.hasPlanReturnsOnCall == nil {
		fake.hasPlanReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasPlanReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeBuild) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeBuild) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) InputsReady() bool {
	fake.inputsReadyMutex.Lock()
	ret, specificReturn := fake.inputsReadyReturnsOnCall[len(fake.inputsReadyArgsForCall)]
	fake.inputsReadyArgsForCall = append(fake.inputsReadyArgsForCall, struct {
	}{})
	fake.recordInvocation("InputsReady", []interface{}{})
	fake.inputsReadyMutex.Unlock()
	if fake.InputsReadyStub != nil {
		return fake.InputsReadyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.inputsReadyReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) InputsReadyCallCount() int {
	fake.inputsReadyMutex.RLock()
	defer fake.inputsReadyMutex.RUnlock()
	return len(fake.inputsReadyArgsForCall)
}

func (fake *FakeBuild) InputsReadyCalls(stub func() bool) {
	fake.inputsReadyMutex.Lock()
	defer fake.inputsReadyMutex.Unlock()
	fake.InputsReadyStub = stub
}

func (fake *FakeBuild) InputsReadyReturns(result1 bool) {
	fake.inputsReadyMutex.Lock()
	defer fake.inputsReadyMutex.Unlock()
	fake.InputsReadyStub = nil
	fake.inputsReadyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) InputsReadyReturnsOnCall(i int, result1 bool) {
	fake.inputsReadyMutex.Lock()
	defer fake.inputsReadyMutex.Unlock()
	fake.InputsReadyStub = nil
	if fake.inputsReadyReturnsOnCall == nil {
		fake.inputsReadyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.inputsReadyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) Interceptible() (bool, error) {
	fake.interceptibleMutex.Lock()
	ret, specificReturn := fake.interceptibleReturnsOnCall[len(fake.interceptibleArgsForCall)]
	fake.interceptibleArgsForCall = append(fake.interceptibleArgsForCall, struct {
	}{})
	fake.recordInvocation("Interceptible", []interface{}{})
	fake.interceptibleMutex.Unlock()
	if fake.InterceptibleStub != nil {
		return fake.InterceptibleStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.interceptibleReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) InterceptibleCallCount() int {
	fake.interceptibleMutex.RLock()
	defer fake.interceptibleMutex.RUnlock()
	return len(fake.interceptibleArgsForCall)
}

func (fake *FakeBuild) InterceptibleCalls(stub func() (bool, error)) {
	fake.interceptibleMutex.Lock()
	defer fake.interceptibleMutex.Unlock()
	fake.InterceptibleStub = stub
}

func (fake *FakeBuild) InterceptibleReturns(result1 bool, result2 error) {
	fake.interceptibleMutex.Lock()
	defer fake.interceptibleMutex.Unlock()
	fake.InterceptibleStub = nil
	fake.interceptibleReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) InterceptibleReturnsOnCall(i int, result1 bool, result2 error) {
	fake.interceptibleMutex.Lock()
	defer fake.interceptibleMutex.Unlock()
	fake.InterceptibleStub = nil
	if fake.interceptibleReturnsOnCall == nil {
		fake.interceptibleReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.interceptibleReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) IsAborted() bool {
	fake.isAbortedMutex.Lock()
	ret, specificReturn := fake.isAbortedReturnsOnCall[len(fake.isAbortedArgsForCall)]
	fake.isAbortedArgsForCall = append(fake.isAbortedArgsForCall, struct {
	}{})
	fake.recordInvocation("IsAborted", []interface{}{})
	fake.isAbortedMutex.Unlock()
	if fake.IsAbortedStub != nil {
		return fake.IsAbortedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isAbortedReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) IsAbortedCallCount() int {
	fake.isAbortedMutex.RLock()
	defer fake.isAbortedMutex.RUnlock()
	return len(fake.isAbortedArgsForCall)
}

func (fake *FakeBuild) IsAbortedCalls(stub func() bool) {
	fake.isAbortedMutex.Lock()
	defer fake.isAbortedMutex.Unlock()
	fake.IsAbortedStub = stub
}

func (fake *FakeBuild) IsAbortedReturns(result1 bool) {
	fake.isAbortedMutex.Lock()
	defer fake.isAbortedMutex.Unlock()
	fake.IsAbortedStub = nil
	fake.isAbortedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsAbortedReturnsOnCall(i int, result1 bool) {
	fake.isAbortedMutex.Lock()
	defer fake.isAbortedMutex.Unlock()
	fake.IsAbortedStub = nil
	if fake.isAbortedReturnsOnCall == nil {
		fake.isAbortedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isAbortedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsCompleted() bool {
	fake.isCompletedMutex.Lock()
	ret, specificReturn := fake.isCompletedReturnsOnCall[len(fake.isCompletedArgsForCall)]
	fake.isCompletedArgsForCall = append(fake.isCompletedArgsForCall, struct {
	}{})
	fake.recordInvocation("IsCompleted", []interface{}{})
	fake.isCompletedMutex.Unlock()
	if fake.IsCompletedStub != nil {
		return fake.IsCompletedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isCompletedReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) IsCompletedCallCount() int {
	fake.isCompletedMutex.RLock()
	defer fake.isCompletedMutex.RUnlock()
	return len(fake.isCompletedArgsForCall)
}

func (fake *FakeBuild) IsCompletedCalls(stub func() bool) {
	fake.isCompletedMutex.Lock()
	defer fake.isCompletedMutex.Unlock()
	fake.IsCompletedStub = stub
}

func (fake *FakeBuild) IsCompletedReturns(result1 bool) {
	fake.isCompletedMutex.Lock()
	defer fake.isCompletedMutex.Unlock()
	fake.IsCompletedStub = nil
	fake.isCompletedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsCompletedReturnsOnCall(i int, result1 bool) {
	fake.isCompletedMutex.Lock()
	defer fake.isCompletedMutex.Unlock()
	fake.IsCompletedStub = nil
	if fake.isCompletedReturnsOnCall == nil {
		fake.isCompletedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isCompletedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsDrained() bool {
	fake.isDrainedMutex.Lock()
	ret, specificReturn := fake.isDrainedReturnsOnCall[len(fake.isDrainedArgsForCall)]
	fake.isDrainedArgsForCall = append(fake.isDrainedArgsForCall, struct {
	}{})
	fake.recordInvocation("IsDrained", []interface{}{})
	fake.isDrainedMutex.Unlock()
	if fake.IsDrainedStub != nil {
		return fake.IsDrainedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isDrainedReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) IsDrainedCallCount() int {
	fake.isDrainedMutex.RLock()
	defer fake.isDrainedMutex.RUnlock()
	return len(fake.isDrainedArgsForCall)
}

func (fake *FakeBuild) IsDrainedCalls(stub func() bool) {
	fake.isDrainedMutex.Lock()
	defer fake.isDrainedMutex.Unlock()
	fake.IsDrainedStub = stub
}

func (fake *FakeBuild) IsDrainedReturns(result1 bool) {
	fake.isDrainedMutex.Lock()
	defer fake.isDrainedMutex.Unlock()
	fake.IsDrainedStub = nil
	fake.isDrainedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsDrainedReturnsOnCall(i int, result1 bool) {
	fake.isDrainedMutex.Lock()
	defer fake.isDrainedMutex.Unlock()
	fake.IsDrainedStub = nil
	if fake.isDrainedReturnsOnCall == nil {
		fake.isDrainedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDrainedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsManuallyTriggered() bool {
	fake.isManuallyTriggeredMutex.Lock()
	ret, specificReturn := fake.isManuallyTriggeredReturnsOnCall[len(fake.isManuallyTriggeredArgsForCall)]
	fake.isManuallyTriggeredArgsForCall = append(fake.isManuallyTriggeredArgsForCall, struct {
	}{})
	fake.recordInvocation("IsManuallyTriggered", []interface{}{})
	fake.isManuallyTriggeredMutex.Unlock()
	if fake.IsManuallyTriggeredStub != nil {
		return fake.IsManuallyTriggeredStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isManuallyTriggeredReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) IsManuallyTriggeredCallCount() int {
	fake.isManuallyTriggeredMutex.RLock()
	defer fake.isManuallyTriggeredMutex.RUnlock()
	return len(fake.isManuallyTriggeredArgsForCall)
}

func (fake *FakeBuild) IsManuallyTriggeredCalls(stub func() bool) {
	fake.isManuallyTriggeredMutex.Lock()
	defer fake.isManuallyTriggeredMutex.Unlock()
	fake.IsManuallyTriggeredStub = stub
}

func (fake *FakeBuild) IsManuallyTriggeredReturns(result1 bool) {
	fake.isManuallyTriggeredMutex.Lock()
	defer fake.isManuallyTriggeredMutex.Unlock()
	fake.IsManuallyTriggeredStub = nil
	fake.isManuallyTriggeredReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsManuallyTriggeredReturnsOnCall(i int, result1 bool) {
	fake.isManuallyTriggeredMutex.Lock()
	defer fake.isManuallyTriggeredMutex.Unlock()
	fake.IsManuallyTriggeredStub = nil
	if fake.isManuallyTriggeredReturnsOnCall == nil {
		fake.isManuallyTriggeredReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isManuallyTriggeredReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsNewerThanLastCheckOf(arg1 db.Resource) bool {
	fake.isNewerThanLastCheckOfMutex.Lock()
	ret, specificReturn := fake.isNewerThanLastCheckOfReturnsOnCall[len(fake.isNewerThanLastCheckOfArgsForCall)]
	fake.isNewerThanLastCheckOfArgsForCall = append(fake.isNewerThanLastCheckOfArgsForCall, struct {
		arg1 db.Resource
	}{arg1})
	fake.recordInvocation("IsNewerThanLastCheckOf", []interface{}{arg1})
	fake.isNewerThanLastCheckOfMutex.Unlock()
	if fake.IsNewerThanLastCheckOfStub != nil {
		return fake.IsNewerThanLastCheckOfStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isNewerThanLastCheckOfReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) IsNewerThanLastCheckOfCallCount() int {
	fake.isNewerThanLastCheckOfMutex.RLock()
	defer fake.isNewerThanLastCheckOfMutex.RUnlock()
	return len(fake.isNewerThanLastCheckOfArgsForCall)
}

func (fake *FakeBuild) IsNewerThanLastCheckOfCalls(stub func(db.Resource) bool) {
	fake.isNewerThanLastCheckOfMutex.Lock()
	defer fake.isNewerThanLastCheckOfMutex.Unlock()
	fake.IsNewerThanLastCheckOfStub = stub
}

func (fake *FakeBuild) IsNewerThanLastCheckOfArgsForCall(i int) db.Resource {
	fake.isNewerThanLastCheckOfMutex.RLock()
	defer fake.isNewerThanLastCheckOfMutex.RUnlock()
	argsForCall := fake.isNewerThanLastCheckOfArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) IsNewerThanLastCheckOfReturns(result1 bool) {
	fake.isNewerThanLastCheckOfMutex.Lock()
	defer fake.isNewerThanLastCheckOfMutex.Unlock()
	fake.IsNewerThanLastCheckOfStub = nil
	fake.isNewerThanLastCheckOfReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsNewerThanLastCheckOfReturnsOnCall(i int, result1 bool) {
	fake.isNewerThanLastCheckOfMutex.Lock()
	defer fake.isNewerThanLastCheckOfMutex.Unlock()
	fake.IsNewerThanLastCheckOfStub = nil
	if fake.isNewerThanLastCheckOfReturnsOnCall == nil {
		fake.isNewerThanLastCheckOfReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isNewerThanLastCheckOfReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsRunning() bool {
	fake.isRunningMutex.Lock()
	ret, specificReturn := fake.isRunningReturnsOnCall[len(fake.isRunningArgsForCall)]
	fake.isRunningArgsForCall = append(fake.isRunningArgsForCall, struct {
	}{})
	fake.recordInvocation("IsRunning", []interface{}{})
	fake.isRunningMutex.Unlock()
	if fake.IsRunningStub != nil {
		return fake.IsRunningStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isRunningReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) IsRunningCallCount() int {
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	return len(fake.isRunningArgsForCall)
}

func (fake *FakeBuild) IsRunningCalls(stub func() bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = stub
}

func (fake *FakeBuild) IsRunningReturns(result1 bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	fake.isRunningReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsRunningReturnsOnCall(i int, result1 bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	if fake.isRunningReturnsOnCall == nil {
		fake.isRunningReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRunningReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsScheduled() bool {
	fake.isScheduledMutex.Lock()
	ret, specificReturn := fake.isScheduledReturnsOnCall[len(fake.isScheduledArgsForCall)]
	fake.isScheduledArgsForCall = append(fake.isScheduledArgsForCall, struct {
	}{})
	fake.recordInvocation("IsScheduled", []interface{}{})
	fake.isScheduledMutex.Unlock()
	if fake.IsScheduledStub != nil {
		return fake.IsScheduledStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isScheduledReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) IsScheduledCallCount() int {
	fake.isScheduledMutex.RLock()
	defer fake.isScheduledMutex.RUnlock()
	return len(fake.isScheduledArgsForCall)
}

func (fake *FakeBuild) IsScheduledCalls(stub func() bool) {
	fake.isScheduledMutex.Lock()
	defer fake.isScheduledMutex.Unlock()
	fake.IsScheduledStub = stub
}

func (fake *FakeBuild) IsScheduledReturns(result1 bool) {
	fake.isScheduledMutex.Lock()
	defer fake.isScheduledMutex.Unlock()
	fake.IsScheduledStub = nil
	fake.isScheduledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) IsScheduledReturnsOnCall(i int, result1 bool) {
	fake.isScheduledMutex.Lock()
	defer fake.isScheduledMutex.Unlock()
	fake.IsScheduledStub = nil
	if fake.isScheduledReturnsOnCall == nil {
		fake.isScheduledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isScheduledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuild) JobDisplayName() string {
	fake.jobDisplayNameMutex.Lock()
	ret, specificReturn := fake.jobDisplayNameReturnsOnCall[len(fake.jobDisplayNameArgsForCall)]
	fake.jobDisplayNameArgsForCall = append(fake.jobDisplayNameArgsForCall, struct {
	}{})
	fake.recordInvocation("JobDisplayName", []interface{}{})
	fake.jobDisplayNameMutex.Unlock()
	if fake.JobDisplayNameStub != nil {
		return fake.JobDisplayNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.jobDisplayNameReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) JobDisplayNameCallCount() int {
	fake.jobDisplayNameMutex.RLock()
	defer fake.jobDisplayNameMutex.RUnlock()
	return len(fake.jobDisplayNameArgsForCall)
}

func (fake *FakeBuild) JobDisplayNameCalls(stub func() string) {
	fake.jobDisplayNameMutex.Lock()
	defer fake.jobDisplayNameMutex.Unlock()
	fake.JobDisplayNameStub = stub
}

func (fake *FakeBuild) JobDisplayNameReturns(result1 string) {
	fake.jobDisplayNameMutex.Lock()
	defer fake.jobDisplayNameMutex.Unlock()
	fake.JobDisplayNameStub = nil
	fake.jobDisplayNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) JobDisplayNameReturnsOnCall(i int, result1 string) {
	fake.jobDisplayNameMutex.Lock()
	defer fake.jobDisplayNameMutex.Unlock()
	fake.JobDisplayNameStub = nil
	if fake.jobDisplayNameReturnsOnCall == nil {
		fake.jobDisplayNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.jobDisplayNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) JobID() int {
	fake.jobIDMutex.Lock()
	ret, specificReturn := fake.jobIDReturnsOnCall[len(fake.jobIDArgsForCall)]
	fake.jobIDArgsForCall = append(fake.jobIDArgsForCall, struct {
	}{})
	fake.recordInvocation("JobID", []interface{}{})
	fake.jobIDMutex.Unlock()
	if fake.JobIDStub != nil {
		return fake.JobIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.jobIDReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) JobIDCallCount() int {
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	return len(fake.jobIDArgsForCall)
}

func (fake *FakeBuild) JobIDCalls(stub func() int) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = stub
}

func (fake *FakeBuild) JobIDReturns(result1 int) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = nil
	fake.jobIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) JobIDReturnsOnCall(i int, result1 int) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = nil
	if fake.jobIDReturnsOnCall == nil {
		fake.jobIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.jobIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) JobName() string {
	fake.jobNameMutex.Lock()
	ret, specificReturn := fake.jobNameReturnsOnCall[len(fake.jobNameArgsForCall)]
	fake.jobNameArgsForCall = append(fake.jobNameArgsForCall, struct {
	}{})
	fake.recordInvocation("JobName", []interface{}{})
	fake.jobNameMutex.Unlock()
	if fake.JobNameStub != nil {
		return fake.JobNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.jobNameReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) JobNameCallCount() int {
	fake.jobNameMutex.RLock()
	defer fake.jobNameMutex.RUnlock()
	return len(fake.jobNameArgsForCall)
}

func (fake *FakeBuild) JobNameCalls(stub func() string) {
	fake.jobNameMutex.Lock()
	defer fake.jobNameMutex.Unlock()
	fake.JobNameStub = stub
}

func (fake *FakeBuild) JobNameReturns(result1 string) {
	fake.jobNameMutex.Lock()
	defer fake.jobNameMutex.Unlock()
	fake.JobNameStub = nil
	fake.jobNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) JobNameReturnsOnCall(i int, result1 string) {
	fake.jobNameMutex.Lock()
	defer fake.jobNameMutex.Unlock()
	fake.JobNameStub = nil
	if fake.jobNameReturnsOnCall == nil {
		fake.jobNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.jobNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) LagerData() lager.Data {
	fake.lagerDataMutex.Lock()
	ret, specificReturn := fake.lagerDataReturnsOnCall[len(fake.lagerDataArgsForCall)]
	fake.lagerDataArgsForCall = append(fake.lagerDataArgsForCall, struct {
	}{})
	fake.recordInvocation("LagerData", []interface{}{})
	fake.lagerDataMutex.Unlock()
	if fake.LagerDataStub != nil {
		return fake.LagerDataStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.lagerDataReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) LagerDataCallCount() int {
	fake.lagerDataMutex.RLock()
	defer fake.lagerDataMutex.RUnlock()
	return len(fake.lagerDataArgsForCall)
}

func (fake *FakeBuild) LagerDataCalls(stub func() lager.Data) {
	fake.lagerDataMutex.Lock()
	defer fake.lagerDataMutex.Unlock()
	fake.LagerDataStub = stub
}

func (fake *FakeBuild) LagerDataReturns(result1 lager.Data) {
	fake.lagerDataMutex.Lock()
	defer fake.lagerDataMutex.Unlock()
	fake.LagerDataStub = nil
	fake.lagerDataReturns = struct {
		result1 lager.Data
	}{result1}
}

func (fake *FakeBuild) LagerDataReturnsOnCall(i int, result1 lager.Data) {
	fake.lagerDataMutex.Lock()
	defer fake.lagerDataMutex.Unlock()
	fake.LagerDataStub = nil
	if fake.lagerDataReturnsOnCall == nil {
		fake.lagerDataReturnsOnCall = make(map[int]struct {
			result1 lager.Data
		})
	}
	fake.lagerDataReturnsOnCall[i] = struct {
		result1 lager.Data
	}{result1}
}

func (fake *FakeBuild) MarkAsAborted() error {
	fake.markAsAbortedMutex.Lock()
	ret, specificReturn := fake.markAsAbortedReturnsOnCall[len(fake.markAsAbortedArgsForCall)]
	fake.markAsAbortedArgsForCall = append(fake.markAsAbortedArgsForCall, struct {
	}{})
	fake.recordInvocation("MarkAsAborted", []interface{}{})
	fake.markAsAbortedMutex.Unlock()
	if fake.MarkAsAbortedStub != nil {
		return fake.MarkAsAbortedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.markAsAbortedReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) MarkAsAbortedCallCount() int {
	fake.markAsAbortedMutex.RLock()
	defer fake.markAsAbortedMutex.RUnlock()
	return len(fake.markAsAbortedArgsForCall)
}

func (fake *FakeBuild) MarkAsAbortedCalls(stub func() error) {
	fake.markAsAbortedMutex.Lock()
	defer fake.markAsAbortedMutex.Unlock()
	fake.MarkAsAbortedStub = stub
}

func (fake *FakeBuild) MarkAsAbortedReturns(result1 error) {
	fake.markAsAbortedMutex.Lock()
	defer fake.markAsAbortedMutex.Unlock()
	fake.MarkAsAbortedStub = nil
	fake.markAsAbortedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) MarkAsAbortedReturnsOnCall(i int, result1 error) {
	fake.markAsAbortedMutex.Lock()
	defer fake.markAsAbortedMutex.Unlock()
	fake.MarkAsAbortedStub = nil
	if fake.markAsAbortedReturnsOnCall == nil {
		fake.markAsAbortedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.markAsAbortedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeBuild) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeBuild) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) Pipeline() (db.Pipeline, bool, error) {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct {
	}{})
	fake.recordInvocation("Pipeline", []interface{}{})
	fake.pipelineMutex.Unlock()
	if fake.PipelineStub != nil {
		return fake.PipelineStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.pipelineReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuild) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeBuild) PipelineCalls(stub func() (db.Pipeline, bool, error)) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = stub
}

func (fake *FakeBuild) PipelineReturns(result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) PipelineReturnsOnCall(i int, result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) PipelineID() int {
	fake.pipelineIDMutex.Lock()
	ret, specificReturn := fake.pipelineIDReturnsOnCall[len(fake.pipelineIDArgsForCall)]
	fake.pipelineIDArgsForCall = append(fake.pipelineIDArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineID", []interface{}{})
	fake.pipelineIDMutex.Unlock()
	if fake.PipelineIDStub != nil {
		return fake.PipelineIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineIDReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) PipelineIDCallCount() int {
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	return len(fake.pipelineIDArgsForCall)
}

func (fake *FakeBuild) PipelineIDCalls(stub func() int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = stub
}

func (fake *FakeBuild) PipelineIDReturns(result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	fake.pipelineIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) PipelineIDReturnsOnCall(i int, result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	if fake.pipelineIDReturnsOnCall == nil {
		fake.pipelineIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.pipelineIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) PipelineInstanceVars() atc.InstanceVars {
	fake.pipelineInstanceVarsMutex.Lock()
	ret, specificReturn := fake.pipelineInstanceVarsReturnsOnCall[len(fake.pipelineInstanceVarsArgsForCall)]
	fake.pipelineInstanceVarsArgsForCall = append(fake.pipelineInstanceVarsArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineInstanceVars", []interface{}{})
	fake.pipelineInstanceVarsMutex.Unlock()
	if fake.PipelineInstanceVarsStub != nil {
		return fake.PipelineInstanceVarsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineInstanceVarsReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) PipelineInstanceVarsCallCount() int {
	fake.pipelineInstanceVarsMutex.RLock()
	defer fake.pipelineInstanceVarsMutex.RUnlock()
	return len(fake.pipelineInstanceVarsArgsForCall)
}

func (fake *FakeBuild) PipelineInstanceVarsCalls(stub func() atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = stub
}

func (fake *FakeBuild) PipelineInstanceVarsReturns(result1 atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = nil
	fake.pipelineInstanceVarsReturns = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakeBuild) PipelineInstanceVarsReturnsOnCall(i int, result1 atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = nil
	if fake.pipelineInstanceVarsReturnsOnCall == nil {
		fake.pipelineInstanceVarsReturnsOnCall = make(map[int]struct {
			result1 atc.InstanceVars
		})
	}
	fake.pipelineInstanceVarsReturnsOnCall[i] = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakeBuild) PipelineName() string {
	fake.pipelineNameMutex.Lock()
	ret, specificReturn := fake.pipelineNameReturnsOnCall[len(fake.pipelineNameArgsForCall)]
	fake.pipelineNameArgsForCall = append(fake.pipelineNameArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineName", []interface{}{})
	fake.pipelineNameMutex.Unlock()
	if fake.PipelineNameStub != nil {
		return fake.PipelineNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineNameReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) PipelineNameCallCount() int {
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	return len(fake.pipelineNameArgsForCall)
}

func (fake *FakeBuild) PipelineNameCalls(stub func() string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = stub
}

func (fake *FakeBuild) PipelineNameReturns(result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	fake.pipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) PipelineNameReturnsOnCall(i int, result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	if fake.pipelineNameReturnsOnCall == nil {
		fake.pipelineNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pipelineNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) PipelineRef() atc.PipelineRef {
	fake.pipelineRefMutex.Lock()
	ret, specificReturn := fake.pipelineRefReturnsOnCall[len(fake.pipelineRefArgsForCall)]
	fake.pipelineRefArgsForCall = append(fake.pipelineRefArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineRef", []interface{}{})
	fake.pipelineRefMutex.Unlock()
	if fake.PipelineRefStub != nil {
		return fake.PipelineRefStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineRefReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) PipelineRefCallCount() int {
	fake.pipelineRefMutex.RLock()
	defer fake.pipelineRefMutex.RUnlock()
	return len(fake.pipelineRefArgsForCall)
}

func (fake *FakeBuild) PipelineRefCalls(stub func() atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = stub
}

func (fake *FakeBuild) PipelineRefReturns(result1 atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = nil
	fake.pipelineRefReturns = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakeBuild) PipelineRefReturnsOnCall(i int, result1 atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = nil
	if fake.pipelineRefReturnsOnCall == nil {
		fake.pipelineRefReturnsOnCall = make(map[int]struct {
			result1 atc.PipelineRef
		})
	}
	fake.pipelineRefReturnsOnCall[i] = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakeBuild) Preparation() (db.BuildPreparation, bool, error) {
	fake.preparationMutex.Lock()
	ret, specificReturn := fake.preparationReturnsOnCall[len(fake.preparationArgsForCall)]
	fake.preparationArgsForCall = append(fake.preparationArgsForCall, struct {
	}{})
	fake.recordInvocation("Preparation", []interface{}{})
	fake.preparationMutex.Unlock()
	if fake.PreparationStub != nil {
		return fake.PreparationStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.preparationReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuild) PreparationCallCount() int {
	fake.preparationMutex.RLock()
	defer fake.preparationMutex.RUnlock()
	return len(fake.preparationArgsForCall)
}

func (fake *FakeBuild) PreparationCalls(stub func() (db.BuildPreparation, bool, error)) {
	fake.preparationMutex.Lock()
	defer fake.preparationMutex.Unlock()
	fake.PreparationStub = stub
}

func (fake *FakeBuild) PreparationReturns(result1 db.BuildPreparation, result2 bool, result3 error) {
	fake.preparationMutex.Lock()
	defer fake.preparationMutex.Unlock()
	fake.PreparationStub = nil
	fake.preparationReturns = struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) PreparationReturnsOnCall(i int, result1 db.BuildPreparation, result2 bool, result3 error) {
	fake.preparationMutex.Lock()
	defer fake.preparationMutex.Unlock()
	fake.PreparationStub = nil
	if fake.preparationReturnsOnCall == nil {
		fake.preparationReturnsOnCall = make(map[int]struct {
			result1 db.BuildPreparation
			result2 bool
			result3 error
		})
	}
	fake.preparationReturnsOnCall[i] = struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) PrivatePlan() atc.Plan {
	fake.privatePlanMutex.Lock()
	ret, specificReturn := fake.privatePlanReturnsOnCall[len(fake.privatePlanArgsForCall)]
	fake.privatePlanArgsForCall = append(fake.privatePlanArgsForCall, struct {
	}{})
	fake.recordInvocation("PrivatePlan", []interface{}{})
	fake.privatePlanMutex.Unlock()
	if fake.PrivatePlanStub != nil {
		return fake.PrivatePlanStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.privatePlanReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) PrivatePlanCallCount() int {
	fake.privatePlanMutex.RLock()
	defer fake.privatePlanMutex.RUnlock()
	return len(fake.privatePlanArgsForCall)
}

func (fake *FakeBuild) PrivatePlanCalls(stub func() atc.Plan) {
	fake.privatePlanMutex.Lock()
	defer fake.privatePlanMutex.Unlock()
	fake.PrivatePlanStub = stub
}

func (fake *FakeBuild) PrivatePlanReturns(result1 atc.Plan) {
	fake.privatePlanMutex.Lock()
	defer fake.privatePlanMutex.Unlock()
	fake.PrivatePlanStub = nil
	fake.privatePlanReturns = struct {
		result1 atc.Plan
	}{result1}
}

func (fake *FakeBuild) PrivatePlanReturnsOnCall(i int, result1 atc.Plan) {
	fake.privatePlanMutex.Lock()
	defer fake.privatePlanMutex.Unlock()
	fake.PrivatePlanStub = nil
	if fake.privatePlanReturnsOnCall == nil {
		fake.privatePlanReturnsOnCall = make(map[int]struct {
			result1 atc.Plan
		})
	}
	fake.privatePlanReturnsOnCall[i] = struct {
		result1 atc.Plan
	}{result1}
}

func (fake *FakeBuild) PublicPlan() *json.RawMessage {
	fake.publicPlanMutex.Lock()
	ret, specificReturn := fake.publicPlanReturnsOnCall[len(fake.publicPlanArgsForCall)]
	fake.publicPlanArgsForCall = append(fake.publicPlanArgsForCall, struct {
	}{})
	fake.recordInvocation("PublicPlan", []interface{}{})
	fake.publicPlanMutex.Unlock()
	if fake.PublicPlanStub != nil {
		return fake.PublicPlanStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.publicPlanReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) PublicPlanCallCount() int {
	fake.publicPlanMutex.RLock()
	defer fake.publicPlanMutex.RUnlock()
	return len(fake.publicPlanArgsForCall)
}

func (fake *FakeBuild) PublicPlanCalls(stub func() *json.RawMessage) {
	fake.publicPlanMutex.Lock()
	defer fake.publicPlanMutex.Unlock()
	fake.PublicPlanStub = stub
}

func (fake *FakeBuild) PublicPlanReturns(result1 *json.RawMessage) {
	fake.publicPlanMutex.Lock()
	defer fake.publicPlanMutex.Unlock()
	fake.PublicPlanStub = nil
	fake.publicPlanReturns = struct {
		result1 *json.RawMessage
	}{result1}
}

func (fake *FakeBuild) PublicPlanReturnsOnCall(i int, result1 *json.RawMessage) {
	fake.publicPlanMutex.Lock()
	defer fake.publicPlanMutex.Unlock()
	fake.PublicPlanStub = nil
	if fake.publicPlanReturnsOnCall == nil {
		fake.publicPlanReturnsOnCall = make(map[int]struct {
			result1 *json.RawMessage
		})
	}
	fake.publicPlanReturnsOnCall[i] = struct {
		result1 *json.RawMessage
	}{result1}
}

func (fake *FakeBuild) ReapTime() time.Time {
	fake.reapTimeMutex.Lock()
	ret, specificReturn := fake.reapTimeReturnsOnCall[len(fake.reapTimeArgsForCall)]
	fake.reapTimeArgsForCall = append(fake.reapTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("ReapTime", []interface{}{})
	fake.reapTimeMutex.Unlock()
	if fake.ReapTimeStub != nil {
		return fake.ReapTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.reapTimeReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) ReapTimeCallCount() int {
	fake.reapTimeMutex.RLock()
	defer fake.reapTimeMutex.RUnlock()
	return len(fake.reapTimeArgsForCall)
}

func (fake *FakeBuild) ReapTimeCalls(stub func() time.Time) {
	fake.reapTimeMutex.Lock()
	defer fake.reapTimeMutex.Unlock()
	fake.ReapTimeStub = stub
}

func (fake *FakeBuild) ReapTimeReturns(result1 time.Time) {
	fake.reapTimeMutex.Lock()
	defer fake.reapTimeMutex.Unlock()
	fake.ReapTimeStub = nil
	fake.reapTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) ReapTimeReturnsOnCall(i int, result1 time.Time) {
	fake.reapTimeMutex.Lock()
	defer fake.reapTimeMutex.Unlock()
	fake.ReapTimeStub = nil
	if fake.reapTimeReturnsOnCall == nil {
		fake.reapTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.reapTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
	}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.reloadReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakeBuild) ReloadCalls(stub func() (bool, error)) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = stub
}

func (fake *FakeBuild) ReloadReturns(result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) RerunNumber() int {
	fake.rerunNumberMutex.Lock()
	ret, specificReturn := fake.rerunNumberReturnsOnCall[len(fake.rerunNumberArgsForCall)]
	fake.rerunNumberArgsForCall = append(fake.rerunNumberArgsForCall, struct {
	}{})
	fake.recordInvocation("RerunNumber", []interface{}{})
	fake.rerunNumberMutex.Unlock()
	if fake.RerunNumberStub != nil {
		return fake.RerunNumberStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.rerunNumberReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) RerunNumberCallCount() int {
	fake.rerunNumberMutex.RLock()
	defer fake.rerunNumberMutex.RUnlock()
	return len(fake.rerunNumberArgsForCall)
}

func (fake *FakeBuild) RerunNumberCalls(stub func() int) {
	fake.rerunNumberMutex.Lock()
	defer fake.rerunNumberMutex.Unlock()
	fake.RerunNumberStub = stub
}

func (fake *FakeBuild) RerunNumberReturns(result1 int) {
	fake.rerunNumberMutex.Lock()
	defer fake.rerunNumberMutex.Unlock()
	fake.RerunNumberStub = nil
	fake.rerunNumberReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) RerunNumberReturnsOnCall(i int, result1 int) {
	fake.rerunNumberMutex.Lock()
	defer fake.rerunNumberMutex.Unlock()
	fake.RerunNumberStub = nil
	if fake.rerunNumberReturnsOnCall == nil {
		fake.rerunNumberReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.rerunNumberReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) RerunOf() int {
	fake.rerunOfMutex.Lock()
	ret, specificReturn := fake.rerunOfReturnsOnCall[len(fake.rerunOfArgsForCall)]
	fake.rerunOfArgsForCall = append(fake.rerunOfArgsForCall, struct {
	}{})
	fake.recordInvocation("RerunOf", []interface{}{})
	fake.rerunOfMutex.Unlock()
	if fake.RerunOfStub != nil {
		return fake.RerunOfStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.rerunOfReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) RerunOfCallCount() int {
	fake.rerunOfMutex.RLock()
	defer fake.rerunOfMutex.RUnlock()
	return len(fake.rerunOfArgsForCall)
}

func (fake *FakeBuild) RerunOfCalls(stub func() int) {
	fake.rerunOfMutex.Lock()
	defer fake.rerunOfMutex.Unlock()
	fake.RerunOfStub = stub
}

func (fake *FakeBuild) RerunOfReturns(result1 int) {
	fake.rerunOfMutex.Lock()
	defer fake.rerunOfMutex.Unlock()
	fake.RerunOfStub = nil
	fake.rerunOfReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) RerunOfReturnsOnCall(i int, result1 int) {
	fake.rerunOfMutex.Lock()
	defer fake.rerunOfMutex.Unlock()
	fake.RerunOfStub = nil
	if fake.rerunOfReturnsOnCall == nil {
		fake.rerunOfReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.rerunOfReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) RerunOfName() string {
	fake.rerunOfNameMutex.Lock()
	ret, specificReturn := fake.rerunOfNameReturnsOnCall[len(fake.rerunOfNameArgsForCall)]
	fake.rerunOfNameArgsForCall = append(fake.rerunOfNameArgsForCall, struct {
	}{})
	fake.recordInvocation("RerunOfName", []interface{}{})
	fake.rerunOfNameMutex.Unlock()
	if fake.RerunOfNameStub != nil {
		return fake.RerunOfNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.rerunOfNameReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) RerunOfNameCallCount() int {
	fake.rerunOfNameMutex.RLock()
	defer fake.rerunOfNameMutex.RUnlock()
	return len(fake.rerunOfNameArgsForCall)
}

func (fake *FakeBuild) RerunOfNameCalls(stub func() string) {
	fake.rerunOfNameMutex.Lock()
	defer fake.rerunOfNameMutex.Unlock()
	fake.RerunOfNameStub = stub
}

func (fake *FakeBuild) RerunOfNameReturns(result1 string) {
	fake.rerunOfNameMutex.Lock()
	defer fake.rerunOfNameMutex.Unlock()
	fake.RerunOfNameStub = nil
	fake.rerunOfNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) RerunOfNameReturnsOnCall(i int, result1 string) {
	fake.rerunOfNameMutex.Lock()
	defer fake.rerunOfNameMutex.Unlock()
	fake.RerunOfNameStub = nil
	if fake.rerunOfNameReturnsOnCall == nil {
		fake.rerunOfNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.rerunOfNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) ResourceID() int {
	fake.resourceIDMutex.Lock()
	ret, specificReturn := fake.resourceIDReturnsOnCall[len(fake.resourceIDArgsForCall)]
	fake.resourceIDArgsForCall = append(fake.resourceIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceID", []interface{}{})
	fake.resourceIDMutex.Unlock()
	if fake.ResourceIDStub != nil {
		return fake.ResourceIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceIDReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) ResourceIDCallCount() int {
	fake.resourceIDMutex.RLock()
	defer fake.resourceIDMutex.RUnlock()
	return len(fake.resourceIDArgsForCall)
}

func (fake *FakeBuild) ResourceIDCalls(stub func() int) {
	fake.resourceIDMutex.Lock()
	defer fake.resourceIDMutex.Unlock()
	fake.ResourceIDStub = stub
}

func (fake *FakeBuild) ResourceIDReturns(result1 int) {
	fake.resourceIDMutex.Lock()
	defer fake.resourceIDMutex.Unlock()
	fake.ResourceIDStub = nil
	fake.resourceIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) ResourceIDReturnsOnCall(i int, result1 int) {
	fake.resourceIDMutex.Lock()
	defer fake.resourceIDMutex.Unlock()
	fake.ResourceIDStub = nil
	if fake.resourceIDReturnsOnCall == nil {
		fake.resourceIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.resourceIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) ResourceName() string {
	fake.resourceNameMutex.Lock()
	ret, specificReturn := fake.resourceNameReturnsOnCall[len(fake.resourceNameArgsForCall)]
	fake.resourceNameArgsForCall = append(fake.resourceNameArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceName", []interface{}{})
	fake.resourceNameMutex.Unlock()
	if fake.ResourceNameStub != nil {
		return fake.ResourceNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceNameReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) ResourceNameCallCount() int {
	fake.resourceNameMutex.RLock()
	defer fake.resourceNameMutex.RUnlock()
	return len(fake.resourceNameArgsForCall)
}

func (fake *FakeBuild) ResourceNameCalls(stub func() string) {
	fake.resourceNameMutex.Lock()
	defer fake.resourceNameMutex.Unlock()
	fake.ResourceNameStub = stub
}

func (fake *FakeBuild) ResourceNameReturns(result1 string) {
	fake.resourceNameMutex.Lock()
	defer fake.resourceNameMutex.Unlock()
	fake.ResourceNameStub = nil
	fake.resourceNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) ResourceNameReturnsOnCall(i int, result1 string) {
	fake.resourceNameMutex.Lock()
	defer fake.resourceNameMutex.Unlock()
	fake.ResourceNameStub = nil
	if fake.resourceNameReturnsOnCall == nil {
		fake.resourceNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.resourceNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) ResourceTypeID() int {
	fake.resourceTypeIDMutex.Lock()
	ret, specificReturn := fake.resourceTypeIDReturnsOnCall[len(fake.resourceTypeIDArgsForCall)]
	fake.resourceTypeIDArgsForCall = append(fake.resourceTypeIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceTypeID", []interface{}{})
	fake.resourceTypeIDMutex.Unlock()
	if fake.ResourceTypeIDStub != nil {
		return fake.ResourceTypeIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceTypeIDReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) ResourceTypeIDCallCount() int {
	fake.resourceTypeIDMutex.RLock()
	defer fake.resourceTypeIDMutex.RUnlock()
	return len(fake.resourceTypeIDArgsForCall)
}

func (fake *FakeBuild) ResourceTypeIDCalls(stub func() int) {
	fake.resourceTypeIDMutex.Lock()
	defer fake.resourceTypeIDMutex.Unlock()
	fake.ResourceTypeIDStub = stub
}

func (fake *FakeBuild) ResourceTypeIDReturns(result1 int) {
	fake.resourceTypeIDMutex.Lock()
	defer fake.resourceTypeIDMutex.Unlock()
	fake.ResourceTypeIDStub = nil
	fake.resourceTypeIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) ResourceTypeIDReturnsOnCall(i int, result1 int) {
	fake.resourceTypeIDMutex.Lock()
	defer fake.resourceTypeIDMutex.Unlock()
	fake.ResourceTypeIDStub = nil
	if fake.resourceTypeIDReturnsOnCall == nil {
		fake.resourceTypeIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.resourceTypeIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) ResourceTypeName() string {
	fake.resourceTypeNameMutex.Lock()
	ret, specificReturn := fake.resourceTypeNameReturnsOnCall[len(fake.resourceTypeNameArgsForCall)]
	fake.resourceTypeNameArgsForCall = append(fake.resourceTypeNameArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceTypeName", []interface{}{})
	fake.resourceTypeNameMutex.Unlock()
	if fake.ResourceTypeNameStub != nil {
		return fake.ResourceTypeNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceTypeNameReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) ResourceTypeNameCallCount() int {
	fake.resourceTypeNameMutex.RLock()
	defer fake.resourceTypeNameMutex.RUnlock()
	return len(fake.resourceTypeNameArgsForCall)
}

func (fake *FakeBuild) ResourceTypeNameCalls(stub func() string) {
	fake.resourceTypeNameMutex.Lock()
	defer fake.resourceTypeNameMutex.Unlock()
	fake.ResourceTypeNameStub = stub
}

func (fake *FakeBuild) ResourceTypeNameReturns(result1 string) {
	fake.resourceTypeNameMutex.Lock()
	defer fake.resourceTypeNameMutex.Unlock()
	fake.ResourceTypeNameStub = nil
	fake.resourceTypeNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) ResourceTypeNameReturnsOnCall(i int, result1 string) {
	fake.resourceTypeNameMutex.Lock()
	defer fake.resourceTypeNameMutex.Unlock()
	fake.ResourceTypeNameStub = nil
	if fake.resourceTypeNameReturnsOnCall == nil {
		fake.resourceTypeNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.resourceTypeNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) Resources() ([]db.BuildInput, []db.BuildOutput, error) {
	fake.resourcesMutex.Lock()
	ret, specificReturn := fake.resourcesReturnsOnCall[len(fake.resourcesArgsForCall)]
	fake.resourcesArgsForCall = append(fake.resourcesArgsForCall, struct {
	}{})
	fake.recordInvocation("Resources", []interface{}{})
	fake.resourcesMutex.Unlock()
	if fake.ResourcesStub != nil {
		return fake.ResourcesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.resourcesReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuild) ResourcesCallCount() int {
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	return len(fake.resourcesArgsForCall)
}

func (fake *FakeBuild) ResourcesCalls(stub func() ([]db.BuildInput, []db.BuildOutput, error)) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = stub
}

func (fake *FakeBuild) ResourcesReturns(result1 []db.BuildInput, result2 []db.BuildOutput, result3 error) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = nil
	fake.resourcesReturns = struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) ResourcesReturnsOnCall(i int, result1 []db.BuildInput, result2 []db.BuildOutput, result3 error) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = nil
	if fake.resourcesReturnsOnCall == nil {
		fake.resourcesReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 []db.BuildOutput
			result3 error
		})
	}
	fake.resourcesReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) ResourcesChecked() (bool, error) {
	fake.resourcesCheckedMutex.Lock()
	ret, specificReturn := fake.resourcesCheckedReturnsOnCall[len(fake.resourcesCheckedArgsForCall)]
	fake.resourcesCheckedArgsForCall = append(fake.resourcesCheckedArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourcesChecked", []interface{}{})
	fake.resourcesCheckedMutex.Unlock()
	if fake.ResourcesCheckedStub != nil {
		return fake.ResourcesCheckedStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.resourcesCheckedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) ResourcesCheckedCallCount() int {
	fake.resourcesCheckedMutex.RLock()
	defer fake.resourcesCheckedMutex.RUnlock()
	return len(fake.resourcesCheckedArgsForCall)
}

func (fake *FakeBuild) ResourcesCheckedCalls(stub func() (bool, error)) {
	fake.resourcesCheckedMutex.Lock()
	defer fake.resourcesCheckedMutex.Unlock()
	fake.ResourcesCheckedStub = stub
}

func (fake *FakeBuild) ResourcesCheckedReturns(result1 bool, result2 error) {
	fake.resourcesCheckedMutex.Lock()
	defer fake.resourcesCheckedMutex.Unlock()
	fake.ResourcesCheckedStub = nil
	fake.resourcesCheckedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) ResourcesCheckedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.resourcesCheckedMutex.Lock()
	defer fake.resourcesCheckedMutex.Unlock()
	fake.ResourcesCheckedStub = nil
	if fake.resourcesCheckedReturnsOnCall == nil {
		fake.resourcesCheckedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.resourcesCheckedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) SaveEvent(arg1 atc.Event) error {
	fake.saveEventMutex.Lock()
	ret, specificReturn := fake.saveEventReturnsOnCall[len(fake.saveEventArgsForCall)]
	fake.saveEventArgsForCall = append(fake.saveEventArgsForCall, struct {
		arg1 atc.Event
	}{arg1})
	fake.recordInvocation("SaveEvent", []interface{}{arg1})
	fake.saveEventMutex.Unlock()
	if fake.SaveEventStub != nil {
		return fake.SaveEventStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveEventReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) SaveEventCallCount() int {
	fake.saveEventMutex.RLock()
	defer fake.saveEventMutex.RUnlock()
	return len(fake.saveEventArgsForCall)
}

func (fake *FakeBuild) SaveEventCalls(stub func(atc.Event) error) {
	fake.saveEventMutex.Lock()
	defer fake.saveEventMutex.Unlock()
	fake.SaveEventStub = stub
}

func (fake *FakeBuild) SaveEventArgsForCall(i int) atc.Event {
	fake.saveEventMutex.RLock()
	defer fake.saveEventMutex.RUnlock()
	argsForCall := fake.saveEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) SaveEventReturns(result1 error) {
	fake.saveEventMutex.Lock()
	defer fake.saveEventMutex.Unlock()
	fake.SaveEventStub = nil
	fake.saveEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveEventReturnsOnCall(i int, result1 error) {
	fake.saveEventMutex.Lock()
	defer fake.saveEventMutex.Unlock()
	fake.SaveEventStub = nil
	if fake.saveEventReturnsOnCall == nil {
		fake.saveEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveImageResourceVersion(arg1 db.UsedResourceCache) error {
	fake.saveImageResourceVersionMutex.Lock()
	ret, specificReturn := fake.saveImageResourceVersionReturnsOnCall[len(fake.saveImageResourceVersionArgsForCall)]
	fake.saveImageResourceVersionArgsForCall = append(fake.saveImageResourceVersionArgsForCall, struct {
		arg1 db.UsedResourceCache
	}{arg1})
	fake.recordInvocation("SaveImageResourceVersion", []interface{}{arg1})
	fake.saveImageResourceVersionMutex.Unlock()
	if fake.SaveImageResourceVersionStub != nil {
		return fake.SaveImageResourceVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveImageResourceVersionReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) SaveImageResourceVersionCallCount() int {
	fake.saveImageResourceVersionMutex.RLock()
	defer fake.saveImageResourceVersionMutex.RUnlock()
	return len(fake.saveImageResourceVersionArgsForCall)
}

func (fake *FakeBuild) SaveImageResourceVersionCalls(stub func(db.UsedResourceCache) error) {
	fake.saveImageResourceVersionMutex.Lock()
	defer fake.saveImageResourceVersionMutex.Unlock()
	fake.SaveImageResourceVersionStub = stub
}

func (fake *FakeBuild) SaveImageResourceVersionArgsForCall(i int) db.UsedResourceCache {
	fake.saveImageResourceVersionMutex.RLock()
	defer fake.saveImageResourceVersionMutex.RUnlock()
	argsForCall := fake.saveImageResourceVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) SaveImageResourceVersionReturns(result1 error) {
	fake.saveImageResourceVersionMutex.Lock()
	defer fake.saveImageResourceVersionMutex.Unlock()
	fake.SaveImageResourceVersionStub = nil
	fake.saveImageResourceVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveImageResourceVersionReturnsOnCall(i int, result1 error) {
	fake.saveImageResourceVersionMutex.Lock()
	defer fake.saveImageResourceVersionMutex.Unlock()
	fake.SaveImageResourceVersionStub = nil
	if fake.saveImageResourceVersionReturnsOnCall == nil {
		fake.saveImageResourceVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveImageResourceVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveOutput(arg1 string, arg2 atc.Source, arg3 atc.VersionedResourceTypes, arg4 atc.Version, arg5 db.ResourceConfigMetadataFields, arg6 string, arg7 string) error {
	fake.saveOutputMutex.Lock()
	ret, specificReturn := fake.saveOutputReturnsOnCall[len(fake.saveOutputArgsForCall)]
	fake.saveOutputArgsForCall = append(fake.saveOutputArgsForCall, struct {
		arg1 string
		arg2 atc.Source
		arg3 atc.VersionedResourceTypes
		arg4 atc.Version
		arg5 db.ResourceConfigMetadataFields
		arg6 string
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("SaveOutput", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.saveOutputMutex.Unlock()
	if fake.SaveOutputStub != nil {
		return fake.SaveOutputStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveOutputReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) SaveOutputCallCount() int {
	fake.saveOutputMutex.RLock()
	defer fake.saveOutputMutex.RUnlock()
	return len(fake.saveOutputArgsForCall)
}

func (fake *FakeBuild) SaveOutputCalls(stub func(string, atc.Source, atc.VersionedResourceTypes, atc.Version, db.ResourceConfigMetadataFields, string, string) error) {
	fake.saveOutputMutex.Lock()
	defer fake.saveOutputMutex.Unlock()
	fake.SaveOutputStub = stub
}

func (fake *FakeBuild) SaveOutputArgsForCall(i int) (string, atc.Source, atc.VersionedResourceTypes, atc.Version, db.ResourceConfigMetadataFields, string, string) {
	fake.saveOutputMutex.RLock()
	defer fake.saveOutputMutex.RUnlock()
	argsForCall := fake.saveOutputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeBuild) SaveOutputReturns(result1 error) {
	fake.saveOutputMutex.Lock()
	defer fake.saveOutputMutex.Unlock()
	fake.SaveOutputStub = nil
	fake.saveOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SaveOutputReturnsOnCall(i int, result1 error) {
	fake.saveOutputMutex.Lock()
	defer fake.saveOutputMutex.Unlock()
	fake.SaveOutputStub = nil
	if fake.saveOutputReturnsOnCall == nil {
		fake.saveOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SavePipeline(arg1 atc.PipelineRef, arg2 int, arg3 atc.Config, arg4 db.ConfigVersion, arg5 bool) (db.Pipeline, bool, error) {
	fake.savePipelineMutex.Lock()
	ret, specificReturn := fake.savePipelineReturnsOnCall[len(fake.savePipelineArgsForCall)]
	fake.savePipelineArgsForCall = append(fake.savePipelineArgsForCall, struct {
		arg1 atc.PipelineRef
		arg2 int
		arg3 atc.Config
		arg4 db.ConfigVersion
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("SavePipeline", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.savePipelineMutex.Unlock()
	if fake.SavePipelineStub != nil {
		return fake.SavePipelineStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.savePipelineReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuild) SavePipelineCallCount() int {
	fake.savePipelineMutex.RLock()
	defer fake.savePipelineMutex.RUnlock()
	return len(fake.savePipelineArgsForCall)
}

func (fake *FakeBuild) SavePipelineCalls(stub func(atc.PipelineRef, int, atc.Config, db.ConfigVersion, bool) (db.Pipeline, bool, error)) {
	fake.savePipelineMutex.Lock()
	defer fake.savePipelineMutex.Unlock()
	fake.SavePipelineStub = stub
}

func (fake *FakeBuild) SavePipelineArgsForCall(i int) (atc.PipelineRef, int, atc.Config, db.ConfigVersion, bool) {
	fake.savePipelineMutex.RLock()
	defer fake.savePipelineMutex.RUnlock()
	argsForCall := fake.savePipelineArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeBuild) SavePipelineReturns(result1 db.Pipeline, result2 bool, result3 error) {
	fake.savePipelineMutex.Lock()
	defer fake.savePipelineMutex.Unlock()
	fake.SavePipelineStub = nil
	fake.savePipelineReturns = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) SavePipelineReturnsOnCall(i int, result1 db.Pipeline, result2 bool, result3 error) {
	fake.savePipelineMutex.Lock()
	defer fake.savePipelineMutex.Unlock()
	fake.SavePipelineStub = nil
	if fake.savePipelineReturnsOnCall == nil {
		fake.savePipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.savePipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuild) Schema() string {
	fake.schemaMutex.Lock()
	ret, specificReturn := fake.schemaReturnsOnCall[len(fake.schemaArgsForCall)]
	fake.schemaArgsForCall = append(fake.schemaArgsForCall, struct {
	}{})
	fake.recordInvocation("Schema", []interface{}{})
	fake.schemaMutex.Unlock()
	if fake.SchemaStub != nil {
		return fake.SchemaStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.schemaReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) SchemaCallCount() int {
	fake.schemaMutex.RLock()
	defer fake.schemaMutex.RUnlock()
	return len(fake.schemaArgsForCall)
}

func (fake *FakeBuild) SchemaCalls(stub func() string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = stub
}

func (fake *FakeBuild) SchemaReturns(result1 string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = nil
	fake.schemaReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) SchemaReturnsOnCall(i int, result1 string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = nil
	if fake.schemaReturnsOnCall == nil {
		fake.schemaReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.schemaReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) SetDrained(arg1 bool) error {
	fake.setDrainedMutex.Lock()
	ret, specificReturn := fake.setDrainedReturnsOnCall[len(fake.setDrainedArgsForCall)]
	fake.setDrainedArgsForCall = append(fake.setDrainedArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("SetDrained", []interface{}{arg1})
	fake.setDrainedMutex.Unlock()
	if fake.SetDrainedStub != nil {
		return fake.SetDrainedStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setDrainedReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) SetDrainedCallCount() int {
	fake.setDrainedMutex.RLock()
	defer fake.setDrainedMutex.RUnlock()
	return len(fake.setDrainedArgsForCall)
}

func (fake *FakeBuild) SetDrainedCalls(stub func(bool) error) {
	fake.setDrainedMutex.Lock()
	defer fake.setDrainedMutex.Unlock()
	fake.SetDrainedStub = stub
}

func (fake *FakeBuild) SetDrainedArgsForCall(i int) bool {
	fake.setDrainedMutex.RLock()
	defer fake.setDrainedMutex.RUnlock()
	argsForCall := fake.setDrainedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) SetDrainedReturns(result1 error) {
	fake.setDrainedMutex.Lock()
	defer fake.setDrainedMutex.Unlock()
	fake.SetDrainedStub = nil
	fake.setDrainedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SetDrainedReturnsOnCall(i int, result1 error) {
	fake.setDrainedMutex.Lock()
	defer fake.setDrainedMutex.Unlock()
	fake.SetDrainedStub = nil
	if fake.setDrainedReturnsOnCall == nil {
		fake.setDrainedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setDrainedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SetInterceptible(arg1 bool) error {
	fake.setInterceptibleMutex.Lock()
	ret, specificReturn := fake.setInterceptibleReturnsOnCall[len(fake.setInterceptibleArgsForCall)]
	fake.setInterceptibleArgsForCall = append(fake.setInterceptibleArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("SetInterceptible", []interface{}{arg1})
	fake.setInterceptibleMutex.Unlock()
	if fake.SetInterceptibleStub != nil {
		return fake.SetInterceptibleStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setInterceptibleReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) SetInterceptibleCallCount() int {
	fake.setInterceptibleMutex.RLock()
	defer fake.setInterceptibleMutex.RUnlock()
	return len(fake.setInterceptibleArgsForCall)
}

func (fake *FakeBuild) SetInterceptibleCalls(stub func(bool) error) {
	fake.setInterceptibleMutex.Lock()
	defer fake.setInterceptibleMutex.Unlock()
	fake.SetInterceptibleStub = stub
}

func (fake *FakeBuild) SetInterceptibleArgsForCall(i int) bool {
	fake.setInterceptibleMutex.RLock()
	defer fake.setInterceptibleMutex.RUnlock()
	argsForCall := fake.setInterceptibleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) SetInterceptibleReturns(result1 error) {
	fake.setInterceptibleMutex.Lock()
	defer fake.setInterceptibleMutex.Unlock()
	fake.SetInterceptibleStub = nil
	fake.setInterceptibleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SetInterceptibleReturnsOnCall(i int, result1 error) {
	fake.setInterceptibleMutex.Lock()
	defer fake.setInterceptibleMutex.Unlock()
	fake.SetInterceptibleStub = nil
	if fake.setInterceptibleReturnsOnCall == nil {
		fake.setInterceptibleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setInterceptibleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuild) SpanContext() propagation.HTTPSupplier {
	fake.spanContextMutex.Lock()
	ret, specificReturn := fake.spanContextReturnsOnCall[len(fake.spanContextArgsForCall)]
	fake.spanContextArgsForCall = append(fake.spanContextArgsForCall, struct {
	}{})
	fake.recordInvocation("SpanContext", []interface{}{})
	fake.spanContextMutex.Unlock()
	if fake.SpanContextStub != nil {
		return fake.SpanContextStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.spanContextReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) SpanContextCallCount() int {
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	return len(fake.spanContextArgsForCall)
}

func (fake *FakeBuild) SpanContextCalls(stub func() propagation.HTTPSupplier) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = stub
}

func (fake *FakeBuild) SpanContextReturns(result1 propagation.HTTPSupplier) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	fake.spanContextReturns = struct {
		result1 propagation.HTTPSupplier
	}{result1}
}

func (fake *FakeBuild) SpanContextReturnsOnCall(i int, result1 propagation.HTTPSupplier) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	if fake.spanContextReturnsOnCall == nil {
		fake.spanContextReturnsOnCall = make(map[int]struct {
			result1 propagation.HTTPSupplier
		})
	}
	fake.spanContextReturnsOnCall[i] = struct {
		result1 propagation.HTTPSupplier
	}{result1}
}

func (fake *FakeBuild) Start(arg1 atc.Plan) (bool, error) {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 atc.Plan
	}{arg1})
	fake.recordInvocation("Start", []interface{}{arg1})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.startReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeBuild) StartCalls(stub func(atc.Plan) (bool, error)) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeBuild) StartArgsForCall(i int) atc.Plan {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	argsForCall := fake.startArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) StartReturns(result1 bool, result2 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) StartReturnsOnCall(i int, result1 bool, result2 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) StartTime() time.Time {
	fake.startTimeMutex.Lock()
	ret, specificReturn := fake.startTimeReturnsOnCall[len(fake.startTimeArgsForCall)]
	fake.startTimeArgsForCall = append(fake.startTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("StartTime", []interface{}{})
	fake.startTimeMutex.Unlock()
	if fake.StartTimeStub != nil {
		return fake.StartTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startTimeReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) StartTimeCallCount() int {
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	return len(fake.startTimeArgsForCall)
}

func (fake *FakeBuild) StartTimeCalls(stub func() time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = stub
}

func (fake *FakeBuild) StartTimeReturns(result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	fake.startTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) StartTimeReturnsOnCall(i int, result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	if fake.startTimeReturnsOnCall == nil {
		fake.startTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.startTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuild) Status() db.BuildStatus {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if fake.StatusStub != nil {
		return fake.StatusStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.statusReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeBuild) StatusCalls(stub func() db.BuildStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeBuild) StatusReturns(result1 db.BuildStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 db.BuildStatus
	}{result1}
}

func (fake *FakeBuild) StatusReturnsOnCall(i int, result1 db.BuildStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 db.BuildStatus
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 db.BuildStatus
	}{result1}
}

func (fake *FakeBuild) SyslogTag(arg1 event.OriginID) string {
	fake.syslogTagMutex.Lock()
	ret, specificReturn := fake.syslogTagReturnsOnCall[len(fake.syslogTagArgsForCall)]
	fake.syslogTagArgsForCall = append(fake.syslogTagArgsForCall, struct {
		arg1 event.OriginID
	}{arg1})
	fake.recordInvocation("SyslogTag", []interface{}{arg1})
	fake.syslogTagMutex.Unlock()
	if fake.SyslogTagStub != nil {
		return fake.SyslogTagStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.syslogTagReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) SyslogTagCallCount() int {
	fake.syslogTagMutex.RLock()
	defer fake.syslogTagMutex.RUnlock()
	return len(fake.syslogTagArgsForCall)
}

func (fake *FakeBuild) SyslogTagCalls(stub func(event.OriginID) string) {
	fake.syslogTagMutex.Lock()
	defer fake.syslogTagMutex.Unlock()
	fake.SyslogTagStub = stub
}

func (fake *FakeBuild) SyslogTagArgsForCall(i int) event.OriginID {
	fake.syslogTagMutex.RLock()
	defer fake.syslogTagMutex.RUnlock()
	argsForCall := fake.syslogTagArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuild) SyslogTagReturns(result1 string) {
	fake.syslogTagMutex.Lock()
	defer fake.syslogTagMutex.Unlock()
	fake.SyslogTagStub = nil
	fake.syslogTagReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) SyslogTagReturnsOnCall(i int, result1 string) {
	fake.syslogTagMutex.Lock()
	defer fake.syslogTagMutex.Unlock()
	fake.SyslogTagStub = nil
	if fake.syslogTagReturnsOnCall == nil {
		fake.syslogTagReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.syslogTagReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamIDReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakeBuild) TeamIDCalls(stub func() int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = stub
}

func (fake *FakeBuild) TeamIDReturns(result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) TeamIDReturnsOnCall(i int, result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuild) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if fake.TeamNameStub != nil {
		return fake.TeamNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamNameReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakeBuild) TeamNameCalls(stub func() string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = stub
}

func (fake *FakeBuild) TeamNameReturns(result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) TeamNameReturnsOnCall(i int, result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuild) TracingAttrs() tracing.Attrs {
	fake.tracingAttrsMutex.Lock()
	ret, specificReturn := fake.tracingAttrsReturnsOnCall[len(fake.tracingAttrsArgsForCall)]
	fake.tracingAttrsArgsForCall = append(fake.tracingAttrsArgsForCall, struct {
	}{})
	fake.recordInvocation("TracingAttrs", []interface{}{})
	fake.tracingAttrsMutex.Unlock()
	if fake.TracingAttrsStub != nil {
		return fake.TracingAttrsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tracingAttrsReturns
	return fakeReturns.result1
}

func (fake *FakeBuild) TracingAttrsCallCount() int {
	fake.tracingAttrsMutex.RLock()
	defer fake.tracingAttrsMutex.RUnlock()
	return len(fake.tracingAttrsArgsForCall)
}

func (fake *FakeBuild) TracingAttrsCalls(stub func() tracing.Attrs) {
	fake.tracingAttrsMutex.Lock()
	defer fake.tracingAttrsMutex.Unlock()
	fake.TracingAttrsStub = stub
}

func (fake *FakeBuild) TracingAttrsReturns(result1 tracing.Attrs) {
	fake.tracingAttrsMutex.Lock()
	defer fake.tracingAttrsMutex.Unlock()
	fake.TracingAttrsStub = nil
	fake.tracingAttrsReturns = struct {
		result1 tracing.Attrs
	}{result1}
}

func (fake *FakeBuild) TracingAttrsReturnsOnCall(i int, result1 tracing.Attrs) {
	fake.tracingAttrsMutex.Lock()
	defer fake.tracingAttrsMutex.Unlock()
	fake.TracingAttrsStub = nil
	if fake.tracingAttrsReturnsOnCall == nil {
		fake.tracingAttrsReturnsOnCall = make(map[int]struct {
			result1 tracing.Attrs
		})
	}
	fake.tracingAttrsReturnsOnCall[i] = struct {
		result1 tracing.Attrs
	}{result1}
}

func (fake *FakeBuild) Variables(arg1 lager.Logger, arg2 creds.Secrets, arg3 creds.VarSourcePool) (vars.Variables, error) {
	fake.variablesMutex.Lock()
	ret, specificReturn := fake.variablesReturnsOnCall[len(fake.variablesArgsForCall)]
	fake.variablesArgsForCall = append(fake.variablesArgsForCall, struct {
		arg1 lager.Logger
		arg2 creds.Secrets
		arg3 creds.VarSourcePool
	}{arg1, arg2, arg3})
	fake.recordInvocation("Variables", []interface{}{arg1, arg2, arg3})
	fake.variablesMutex.Unlock()
	if fake.VariablesStub != nil {
		return fake.VariablesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.variablesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuild) VariablesCallCount() int {
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	return len(fake.variablesArgsForCall)
}

func (fake *FakeBuild) VariablesCalls(stub func(lager.Logger, creds.Secrets, creds.VarSourcePool) (vars.Variables, error)) {
	fake.variablesMutex.Lock()
	defer fake.variablesMutex.Unlock()
	fake.VariablesStub = stub
}

func (fake *FakeBuild) VariablesArgsForCall(i int) (lager.Logger, creds.Secrets, creds.VarSourcePool) {
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	argsForCall := fake.variablesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuild) VariablesReturns(result1 vars.Variables, result2 error) {
	fake.variablesMutex.Lock()
	defer fake.variablesMutex.Unlock()
	fake.VariablesStub = nil
	fake.variablesReturns = struct {
		result1 vars.Variables
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) VariablesReturnsOnCall(i int, result1 vars.Variables, result2 error) {
	fake.variablesMutex.Lock()
	defer fake.variablesMutex.Unlock()
	fake.VariablesStub = nil
	if fake.variablesReturnsOnCall == nil {
		fake.variablesReturnsOnCall = make(map[int]struct {
			result1 vars.Variables
			result2 error
		})
	}
	fake.variablesReturnsOnCall[i] = struct {
		result1 vars.Variables
		result2 error
	}{result1, result2}
}

func (fake *FakeBuild) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.abortNotifierMutex.RLock()
	defer fake.abortNotifierMutex.RUnlock()
	fake.acquireTrackingLockMutex.RLock()
	defer fake.acquireTrackingLockMutex.RUnlock()
	fake.adoptInputsAndPipesMutex.RLock()
	defer fake.adoptInputsAndPipesMutex.RUnlock()
	fake.adoptRerunInputsAndPipesMutex.RLock()
	defer fake.adoptRerunInputsAndPipesMutex.RUnlock()
	fake.artifactMutex.RLock()
	defer fake.artifactMutex.RUnlock()
	fake.artifactsMutex.RLock()
	defer fake.artifactsMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	fake.hasPlanMutex.RLock()
	defer fake.hasPlanMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.inputsReadyMutex.RLock()
	defer fake.inputsReadyMutex.RUnlock()
	fake.interceptibleMutex.RLock()
	defer fake.interceptibleMutex.RUnlock()
	fake.isAbortedMutex.RLock()
	defer fake.isAbortedMutex.RUnlock()
	fake.isCompletedMutex.RLock()
	defer fake.isCompletedMutex.RUnlock()
	fake.isDrainedMutex.RLock()
	defer fake.isDrainedMutex.RUnlock()
	fake.isManuallyTriggeredMutex.RLock()
	defer fake.isManuallyTriggeredMutex.RUnlock()
	fake.isNewerThanLastCheckOfMutex.RLock()
	defer fake.isNewerThanLastCheckOfMutex.RUnlock()
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	fake.isScheduledMutex.RLock()
	defer fake.isScheduledMutex.RUnlock()
	fake.jobDisplayNameMutex.RLock()
	defer fake.jobDisplayNameMutex.RUnlock()
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	fake.jobNameMutex.RLock()
	defer fake.jobNameMutex.RUnlock()
	fake.lagerDataMutex.RLock()
	defer fake.lagerDataMutex.RUnlock()
	fake.markAsAbortedMutex.RLock()
	defer fake.markAsAbortedMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	fake.pipelineInstanceVarsMutex.RLock()
	defer fake.pipelineInstanceVarsMutex.RUnlock()
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	fake.pipelineRefMutex.RLock()
	defer fake.pipelineRefMutex.RUnlock()
	fake.preparationMutex.RLock()
	defer fake.preparationMutex.RUnlock()
	fake.privatePlanMutex.RLock()
	defer fake.privatePlanMutex.RUnlock()
	fake.publicPlanMutex.RLock()
	defer fake.publicPlanMutex.RUnlock()
	fake.reapTimeMutex.RLock()
	defer fake.reapTimeMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.rerunNumberMutex.RLock()
	defer fake.rerunNumberMutex.RUnlock()
	fake.rerunOfMutex.RLock()
	defer fake.rerunOfMutex.RUnlock()
	fake.rerunOfNameMutex.RLock()
	defer fake.rerunOfNameMutex.RUnlock()
	fake.resourceIDMutex.RLock()
	defer fake.resourceIDMutex.RUnlock()
	fake.resourceNameMutex.RLock()
	defer fake.resourceNameMutex.RUnlock()
	fake.resourceTypeIDMutex.RLock()
	defer fake.resourceTypeIDMutex.RUnlock()
	fake.resourceTypeNameMutex.RLock()
	defer fake.resourceTypeNameMutex.RUnlock()
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	fake.resourcesCheckedMutex.RLock()
	defer fake.resourcesCheckedMutex.RUnlock()
	fake.saveEventMutex.RLock()
	defer fake.saveEventMutex.RUnlock()
	fake.saveImageResourceVersionMutex.RLock()
	defer fake.saveImageResourceVersionMutex.RUnlock()
	fake.saveOutputMutex.RLock()
	defer fake.saveOutputMutex.RUnlock()
	fake.savePipelineMutex.RLock()
	defer fake.savePipelineMutex.RUnlock()
	fake.schemaMutex.RLock()
	defer fake.schemaMutex.RUnlock()
	fake.setDrainedMutex.RLock()
	defer fake.setDrainedMutex.RUnlock()
	fake.setInterceptibleMutex.RLock()
	defer fake.setInterceptibleMutex.RUnlock()
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.syslogTagMutex.RLock()
	defer fake.syslogTagMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.tracingAttrsMutex.RLock()
	defer fake.tracingAttrsMutex.RUnlock()
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBuild) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Build = new(FakeBuild)
