// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"encoding/json"
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
)

type FakeBuildForAPI struct {
	AllAssociatedTeamNamesStub        func() []string
	allAssociatedTeamNamesMutex       sync.RWMutex
	allAssociatedTeamNamesArgsForCall []struct {
	}
	allAssociatedTeamNamesReturns struct {
		result1 []string
	}
	allAssociatedTeamNamesReturnsOnCall map[int]struct {
		result1 []string
	}
	ArtifactsStub        func() ([]db.WorkerArtifact, error)
	artifactsMutex       sync.RWMutex
	artifactsArgsForCall []struct {
	}
	artifactsReturns struct {
		result1 []db.WorkerArtifact
		result2 error
	}
	artifactsReturnsOnCall map[int]struct {
		result1 []db.WorkerArtifact
		result2 error
	}
	CommentStub        func() string
	commentMutex       sync.RWMutex
	commentArgsForCall []struct {
	}
	commentReturns struct {
		result1 string
	}
	commentReturnsOnCall map[int]struct {
		result1 string
	}
	CreatedByStub        func() *string
	createdByMutex       sync.RWMutex
	createdByArgsForCall []struct {
	}
	createdByReturns struct {
		result1 *string
	}
	createdByReturnsOnCall map[int]struct {
		result1 *string
	}
	EndTimeStub        func() time.Time
	endTimeMutex       sync.RWMutex
	endTimeArgsForCall []struct {
	}
	endTimeReturns struct {
		result1 time.Time
	}
	endTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	EventsStub        func(uint) (db.EventSource, error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 uint
	}
	eventsReturns struct {
		result1 db.EventSource
		result2 error
	}
	eventsReturnsOnCall map[int]struct {
		result1 db.EventSource
		result2 error
	}
	HasPlanStub        func() bool
	hasPlanMutex       sync.RWMutex
	hasPlanArgsForCall []struct {
	}
	hasPlanReturns struct {
		result1 bool
	}
	hasPlanReturnsOnCall map[int]struct {
		result1 bool
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	IsDrainedStub        func() bool
	isDrainedMutex       sync.RWMutex
	isDrainedArgsForCall []struct {
	}
	isDrainedReturns struct {
		result1 bool
	}
	isDrainedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsRunningStub        func() bool
	isRunningMutex       sync.RWMutex
	isRunningArgsForCall []struct {
	}
	isRunningReturns struct {
		result1 bool
	}
	isRunningReturnsOnCall map[int]struct {
		result1 bool
	}
	JobStub        func() (db.Job, bool, error)
	jobMutex       sync.RWMutex
	jobArgsForCall []struct {
	}
	jobReturns struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	jobReturnsOnCall map[int]struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	JobIDStub        func() int
	jobIDMutex       sync.RWMutex
	jobIDArgsForCall []struct {
	}
	jobIDReturns struct {
		result1 int
	}
	jobIDReturnsOnCall map[int]struct {
		result1 int
	}
	JobNameStub        func() string
	jobNameMutex       sync.RWMutex
	jobNameArgsForCall []struct {
	}
	jobNameReturns struct {
		result1 string
	}
	jobNameReturnsOnCall map[int]struct {
		result1 string
	}
	LagerDataStub        func() lager.Data
	lagerDataMutex       sync.RWMutex
	lagerDataArgsForCall []struct {
	}
	lagerDataReturns struct {
		result1 lager.Data
	}
	lagerDataReturnsOnCall map[int]struct {
		result1 lager.Data
	}
	MarkAsAbortedStub        func() error
	markAsAbortedMutex       sync.RWMutex
	markAsAbortedArgsForCall []struct {
	}
	markAsAbortedReturns struct {
		result1 error
	}
	markAsAbortedReturnsOnCall map[int]struct {
		result1 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	PipelineStub        func() (db.Pipeline, bool, error)
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct {
	}
	pipelineReturns struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	pipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	PipelineIDStub        func() int
	pipelineIDMutex       sync.RWMutex
	pipelineIDArgsForCall []struct {
	}
	pipelineIDReturns struct {
		result1 int
	}
	pipelineIDReturnsOnCall map[int]struct {
		result1 int
	}
	PipelineInstanceVarsStub        func() atc.InstanceVars
	pipelineInstanceVarsMutex       sync.RWMutex
	pipelineInstanceVarsArgsForCall []struct {
	}
	pipelineInstanceVarsReturns struct {
		result1 atc.InstanceVars
	}
	pipelineInstanceVarsReturnsOnCall map[int]struct {
		result1 atc.InstanceVars
	}
	PipelineNameStub        func() string
	pipelineNameMutex       sync.RWMutex
	pipelineNameArgsForCall []struct {
	}
	pipelineNameReturns struct {
		result1 string
	}
	pipelineNameReturnsOnCall map[int]struct {
		result1 string
	}
	PipelineRefStub        func() atc.PipelineRef
	pipelineRefMutex       sync.RWMutex
	pipelineRefArgsForCall []struct {
	}
	pipelineRefReturns struct {
		result1 atc.PipelineRef
	}
	pipelineRefReturnsOnCall map[int]struct {
		result1 atc.PipelineRef
	}
	PreparationStub        func() (db.BuildPreparation, bool, error)
	preparationMutex       sync.RWMutex
	preparationArgsForCall []struct {
	}
	preparationReturns struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}
	preparationReturnsOnCall map[int]struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}
	PublicPlanStub        func() *json.RawMessage
	publicPlanMutex       sync.RWMutex
	publicPlanArgsForCall []struct {
	}
	publicPlanReturns struct {
		result1 *json.RawMessage
	}
	publicPlanReturnsOnCall map[int]struct {
		result1 *json.RawMessage
	}
	ReapTimeStub        func() time.Time
	reapTimeMutex       sync.RWMutex
	reapTimeArgsForCall []struct {
	}
	reapTimeReturns struct {
		result1 time.Time
	}
	reapTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	RerunNumberStub        func() int
	rerunNumberMutex       sync.RWMutex
	rerunNumberArgsForCall []struct {
	}
	rerunNumberReturns struct {
		result1 int
	}
	rerunNumberReturnsOnCall map[int]struct {
		result1 int
	}
	RerunOfStub        func() int
	rerunOfMutex       sync.RWMutex
	rerunOfArgsForCall []struct {
	}
	rerunOfReturns struct {
		result1 int
	}
	rerunOfReturnsOnCall map[int]struct {
		result1 int
	}
	RerunOfNameStub        func() string
	rerunOfNameMutex       sync.RWMutex
	rerunOfNameArgsForCall []struct {
	}
	rerunOfNameReturns struct {
		result1 string
	}
	rerunOfNameReturnsOnCall map[int]struct {
		result1 string
	}
	ResourceIDStub        func() int
	resourceIDMutex       sync.RWMutex
	resourceIDArgsForCall []struct {
	}
	resourceIDReturns struct {
		result1 int
	}
	resourceIDReturnsOnCall map[int]struct {
		result1 int
	}
	ResourceNameStub        func() string
	resourceNameMutex       sync.RWMutex
	resourceNameArgsForCall []struct {
	}
	resourceNameReturns struct {
		result1 string
	}
	resourceNameReturnsOnCall map[int]struct {
		result1 string
	}
	ResourcesStub        func() ([]db.BuildInput, []db.BuildOutput, error)
	resourcesMutex       sync.RWMutex
	resourcesArgsForCall []struct {
	}
	resourcesReturns struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}
	resourcesReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}
	SchemaStub        func() string
	schemaMutex       sync.RWMutex
	schemaArgsForCall []struct {
	}
	schemaReturns struct {
		result1 string
	}
	schemaReturnsOnCall map[int]struct {
		result1 string
	}
	SetCommentStub        func(string) error
	setCommentMutex       sync.RWMutex
	setCommentArgsForCall []struct {
		arg1 string
	}
	setCommentReturns struct {
		result1 error
	}
	setCommentReturnsOnCall map[int]struct {
		result1 error
	}
	StartTimeStub        func() time.Time
	startTimeMutex       sync.RWMutex
	startTimeArgsForCall []struct {
	}
	startTimeReturns struct {
		result1 time.Time
	}
	startTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	StatusStub        func() db.BuildStatus
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 db.BuildStatus
	}
	statusReturnsOnCall map[int]struct {
		result1 db.BuildStatus
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBuildForAPI) AllAssociatedTeamNames() []string {
	fake.allAssociatedTeamNamesMutex.Lock()
	ret, specificReturn := fake.allAssociatedTeamNamesReturnsOnCall[len(fake.allAssociatedTeamNamesArgsForCall)]
	fake.allAssociatedTeamNamesArgsForCall = append(fake.allAssociatedTeamNamesArgsForCall, struct {
	}{})
	stub := fake.AllAssociatedTeamNamesStub
	fakeReturns := fake.allAssociatedTeamNamesReturns
	fake.recordInvocation("AllAssociatedTeamNames", []interface{}{})
	fake.allAssociatedTeamNamesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) AllAssociatedTeamNamesCallCount() int {
	fake.allAssociatedTeamNamesMutex.RLock()
	defer fake.allAssociatedTeamNamesMutex.RUnlock()
	return len(fake.allAssociatedTeamNamesArgsForCall)
}

func (fake *FakeBuildForAPI) AllAssociatedTeamNamesCalls(stub func() []string) {
	fake.allAssociatedTeamNamesMutex.Lock()
	defer fake.allAssociatedTeamNamesMutex.Unlock()
	fake.AllAssociatedTeamNamesStub = stub
}

func (fake *FakeBuildForAPI) AllAssociatedTeamNamesReturns(result1 []string) {
	fake.allAssociatedTeamNamesMutex.Lock()
	defer fake.allAssociatedTeamNamesMutex.Unlock()
	fake.AllAssociatedTeamNamesStub = nil
	fake.allAssociatedTeamNamesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeBuildForAPI) AllAssociatedTeamNamesReturnsOnCall(i int, result1 []string) {
	fake.allAssociatedTeamNamesMutex.Lock()
	defer fake.allAssociatedTeamNamesMutex.Unlock()
	fake.AllAssociatedTeamNamesStub = nil
	if fake.allAssociatedTeamNamesReturnsOnCall == nil {
		fake.allAssociatedTeamNamesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.allAssociatedTeamNamesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeBuildForAPI) Artifacts() ([]db.WorkerArtifact, error) {
	fake.artifactsMutex.Lock()
	ret, specificReturn := fake.artifactsReturnsOnCall[len(fake.artifactsArgsForCall)]
	fake.artifactsArgsForCall = append(fake.artifactsArgsForCall, struct {
	}{})
	stub := fake.ArtifactsStub
	fakeReturns := fake.artifactsReturns
	fake.recordInvocation("Artifacts", []interface{}{})
	fake.artifactsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuildForAPI) ArtifactsCallCount() int {
	fake.artifactsMutex.RLock()
	defer fake.artifactsMutex.RUnlock()
	return len(fake.artifactsArgsForCall)
}

func (fake *FakeBuildForAPI) ArtifactsCalls(stub func() ([]db.WorkerArtifact, error)) {
	fake.artifactsMutex.Lock()
	defer fake.artifactsMutex.Unlock()
	fake.ArtifactsStub = stub
}

func (fake *FakeBuildForAPI) ArtifactsReturns(result1 []db.WorkerArtifact, result2 error) {
	fake.artifactsMutex.Lock()
	defer fake.artifactsMutex.Unlock()
	fake.ArtifactsStub = nil
	fake.artifactsReturns = struct {
		result1 []db.WorkerArtifact
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildForAPI) ArtifactsReturnsOnCall(i int, result1 []db.WorkerArtifact, result2 error) {
	fake.artifactsMutex.Lock()
	defer fake.artifactsMutex.Unlock()
	fake.ArtifactsStub = nil
	if fake.artifactsReturnsOnCall == nil {
		fake.artifactsReturnsOnCall = make(map[int]struct {
			result1 []db.WorkerArtifact
			result2 error
		})
	}
	fake.artifactsReturnsOnCall[i] = struct {
		result1 []db.WorkerArtifact
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildForAPI) Comment() string {
	fake.commentMutex.Lock()
	ret, specificReturn := fake.commentReturnsOnCall[len(fake.commentArgsForCall)]
	fake.commentArgsForCall = append(fake.commentArgsForCall, struct {
	}{})
	stub := fake.CommentStub
	fakeReturns := fake.commentReturns
	fake.recordInvocation("Comment", []interface{}{})
	fake.commentMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) CommentCallCount() int {
	fake.commentMutex.RLock()
	defer fake.commentMutex.RUnlock()
	return len(fake.commentArgsForCall)
}

func (fake *FakeBuildForAPI) CommentCalls(stub func() string) {
	fake.commentMutex.Lock()
	defer fake.commentMutex.Unlock()
	fake.CommentStub = stub
}

func (fake *FakeBuildForAPI) CommentReturns(result1 string) {
	fake.commentMutex.Lock()
	defer fake.commentMutex.Unlock()
	fake.CommentStub = nil
	fake.commentReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) CommentReturnsOnCall(i int, result1 string) {
	fake.commentMutex.Lock()
	defer fake.commentMutex.Unlock()
	fake.CommentStub = nil
	if fake.commentReturnsOnCall == nil {
		fake.commentReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.commentReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) CreatedBy() *string {
	fake.createdByMutex.Lock()
	ret, specificReturn := fake.createdByReturnsOnCall[len(fake.createdByArgsForCall)]
	fake.createdByArgsForCall = append(fake.createdByArgsForCall, struct {
	}{})
	stub := fake.CreatedByStub
	fakeReturns := fake.createdByReturns
	fake.recordInvocation("CreatedBy", []interface{}{})
	fake.createdByMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) CreatedByCallCount() int {
	fake.createdByMutex.RLock()
	defer fake.createdByMutex.RUnlock()
	return len(fake.createdByArgsForCall)
}

func (fake *FakeBuildForAPI) CreatedByCalls(stub func() *string) {
	fake.createdByMutex.Lock()
	defer fake.createdByMutex.Unlock()
	fake.CreatedByStub = stub
}

func (fake *FakeBuildForAPI) CreatedByReturns(result1 *string) {
	fake.createdByMutex.Lock()
	defer fake.createdByMutex.Unlock()
	fake.CreatedByStub = nil
	fake.createdByReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeBuildForAPI) CreatedByReturnsOnCall(i int, result1 *string) {
	fake.createdByMutex.Lock()
	defer fake.createdByMutex.Unlock()
	fake.CreatedByStub = nil
	if fake.createdByReturnsOnCall == nil {
		fake.createdByReturnsOnCall = make(map[int]struct {
			result1 *string
		})
	}
	fake.createdByReturnsOnCall[i] = struct {
		result1 *string
	}{result1}
}

func (fake *FakeBuildForAPI) EndTime() time.Time {
	fake.endTimeMutex.Lock()
	ret, specificReturn := fake.endTimeReturnsOnCall[len(fake.endTimeArgsForCall)]
	fake.endTimeArgsForCall = append(fake.endTimeArgsForCall, struct {
	}{})
	stub := fake.EndTimeStub
	fakeReturns := fake.endTimeReturns
	fake.recordInvocation("EndTime", []interface{}{})
	fake.endTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) EndTimeCallCount() int {
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	return len(fake.endTimeArgsForCall)
}

func (fake *FakeBuildForAPI) EndTimeCalls(stub func() time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = stub
}

func (fake *FakeBuildForAPI) EndTimeReturns(result1 time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = nil
	fake.endTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuildForAPI) EndTimeReturnsOnCall(i int, result1 time.Time) {
	fake.endTimeMutex.Lock()
	defer fake.endTimeMutex.Unlock()
	fake.EndTimeStub = nil
	if fake.endTimeReturnsOnCall == nil {
		fake.endTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.endTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuildForAPI) Events(arg1 uint) (db.EventSource, error) {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 uint
	}{arg1})
	stub := fake.EventsStub
	fakeReturns := fake.eventsReturns
	fake.recordInvocation("Events", []interface{}{arg1})
	fake.eventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuildForAPI) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeBuildForAPI) EventsCalls(stub func(uint) (db.EventSource, error)) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = stub
}

func (fake *FakeBuildForAPI) EventsArgsForCall(i int) uint {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	argsForCall := fake.eventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuildForAPI) EventsReturns(result1 db.EventSource, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 db.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildForAPI) EventsReturnsOnCall(i int, result1 db.EventSource, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 db.EventSource
			result2 error
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 db.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildForAPI) HasPlan() bool {
	fake.hasPlanMutex.Lock()
	ret, specificReturn := fake.hasPlanReturnsOnCall[len(fake.hasPlanArgsForCall)]
	fake.hasPlanArgsForCall = append(fake.hasPlanArgsForCall, struct {
	}{})
	stub := fake.HasPlanStub
	fakeReturns := fake.hasPlanReturns
	fake.recordInvocation("HasPlan", []interface{}{})
	fake.hasPlanMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) HasPlanCallCount() int {
	fake.hasPlanMutex.RLock()
	defer fake.hasPlanMutex.RUnlock()
	return len(fake.hasPlanArgsForCall)
}

func (fake *FakeBuildForAPI) HasPlanCalls(stub func() bool) {
	fake.hasPlanMutex.Lock()
	defer fake.hasPlanMutex.Unlock()
	fake.HasPlanStub = stub
}

func (fake *FakeBuildForAPI) HasPlanReturns(result1 bool) {
	fake.hasPlanMutex.Lock()
	defer fake.hasPlanMutex.Unlock()
	fake.HasPlanStub = nil
	fake.hasPlanReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuildForAPI) HasPlanReturnsOnCall(i int, result1 bool) {
	fake.hasPlanMutex.Lock()
	defer fake.hasPlanMutex.Unlock()
	fake.HasPlanStub = nil
	if fake.hasPlanReturnsOnCall == nil {
		fake.hasPlanReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasPlanReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuildForAPI) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeBuildForAPI) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeBuildForAPI) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) IsDrained() bool {
	fake.isDrainedMutex.Lock()
	ret, specificReturn := fake.isDrainedReturnsOnCall[len(fake.isDrainedArgsForCall)]
	fake.isDrainedArgsForCall = append(fake.isDrainedArgsForCall, struct {
	}{})
	stub := fake.IsDrainedStub
	fakeReturns := fake.isDrainedReturns
	fake.recordInvocation("IsDrained", []interface{}{})
	fake.isDrainedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) IsDrainedCallCount() int {
	fake.isDrainedMutex.RLock()
	defer fake.isDrainedMutex.RUnlock()
	return len(fake.isDrainedArgsForCall)
}

func (fake *FakeBuildForAPI) IsDrainedCalls(stub func() bool) {
	fake.isDrainedMutex.Lock()
	defer fake.isDrainedMutex.Unlock()
	fake.IsDrainedStub = stub
}

func (fake *FakeBuildForAPI) IsDrainedReturns(result1 bool) {
	fake.isDrainedMutex.Lock()
	defer fake.isDrainedMutex.Unlock()
	fake.IsDrainedStub = nil
	fake.isDrainedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuildForAPI) IsDrainedReturnsOnCall(i int, result1 bool) {
	fake.isDrainedMutex.Lock()
	defer fake.isDrainedMutex.Unlock()
	fake.IsDrainedStub = nil
	if fake.isDrainedReturnsOnCall == nil {
		fake.isDrainedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDrainedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuildForAPI) IsRunning() bool {
	fake.isRunningMutex.Lock()
	ret, specificReturn := fake.isRunningReturnsOnCall[len(fake.isRunningArgsForCall)]
	fake.isRunningArgsForCall = append(fake.isRunningArgsForCall, struct {
	}{})
	stub := fake.IsRunningStub
	fakeReturns := fake.isRunningReturns
	fake.recordInvocation("IsRunning", []interface{}{})
	fake.isRunningMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) IsRunningCallCount() int {
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	return len(fake.isRunningArgsForCall)
}

func (fake *FakeBuildForAPI) IsRunningCalls(stub func() bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = stub
}

func (fake *FakeBuildForAPI) IsRunningReturns(result1 bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	fake.isRunningReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuildForAPI) IsRunningReturnsOnCall(i int, result1 bool) {
	fake.isRunningMutex.Lock()
	defer fake.isRunningMutex.Unlock()
	fake.IsRunningStub = nil
	if fake.isRunningReturnsOnCall == nil {
		fake.isRunningReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRunningReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBuildForAPI) Job() (db.Job, bool, error) {
	fake.jobMutex.Lock()
	ret, specificReturn := fake.jobReturnsOnCall[len(fake.jobArgsForCall)]
	fake.jobArgsForCall = append(fake.jobArgsForCall, struct {
	}{})
	stub := fake.JobStub
	fakeReturns := fake.jobReturns
	fake.recordInvocation("Job", []interface{}{})
	fake.jobMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuildForAPI) JobCallCount() int {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return len(fake.jobArgsForCall)
}

func (fake *FakeBuildForAPI) JobCalls(stub func() (db.Job, bool, error)) {
	fake.jobMutex.Lock()
	defer fake.jobMutex.Unlock()
	fake.JobStub = stub
}

func (fake *FakeBuildForAPI) JobReturns(result1 db.Job, result2 bool, result3 error) {
	fake.jobMutex.Lock()
	defer fake.jobMutex.Unlock()
	fake.JobStub = nil
	fake.jobReturns = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildForAPI) JobReturnsOnCall(i int, result1 db.Job, result2 bool, result3 error) {
	fake.jobMutex.Lock()
	defer fake.jobMutex.Unlock()
	fake.JobStub = nil
	if fake.jobReturnsOnCall == nil {
		fake.jobReturnsOnCall = make(map[int]struct {
			result1 db.Job
			result2 bool
			result3 error
		})
	}
	fake.jobReturnsOnCall[i] = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildForAPI) JobID() int {
	fake.jobIDMutex.Lock()
	ret, specificReturn := fake.jobIDReturnsOnCall[len(fake.jobIDArgsForCall)]
	fake.jobIDArgsForCall = append(fake.jobIDArgsForCall, struct {
	}{})
	stub := fake.JobIDStub
	fakeReturns := fake.jobIDReturns
	fake.recordInvocation("JobID", []interface{}{})
	fake.jobIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) JobIDCallCount() int {
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	return len(fake.jobIDArgsForCall)
}

func (fake *FakeBuildForAPI) JobIDCalls(stub func() int) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = stub
}

func (fake *FakeBuildForAPI) JobIDReturns(result1 int) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = nil
	fake.jobIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) JobIDReturnsOnCall(i int, result1 int) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = nil
	if fake.jobIDReturnsOnCall == nil {
		fake.jobIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.jobIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) JobName() string {
	fake.jobNameMutex.Lock()
	ret, specificReturn := fake.jobNameReturnsOnCall[len(fake.jobNameArgsForCall)]
	fake.jobNameArgsForCall = append(fake.jobNameArgsForCall, struct {
	}{})
	stub := fake.JobNameStub
	fakeReturns := fake.jobNameReturns
	fake.recordInvocation("JobName", []interface{}{})
	fake.jobNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) JobNameCallCount() int {
	fake.jobNameMutex.RLock()
	defer fake.jobNameMutex.RUnlock()
	return len(fake.jobNameArgsForCall)
}

func (fake *FakeBuildForAPI) JobNameCalls(stub func() string) {
	fake.jobNameMutex.Lock()
	defer fake.jobNameMutex.Unlock()
	fake.JobNameStub = stub
}

func (fake *FakeBuildForAPI) JobNameReturns(result1 string) {
	fake.jobNameMutex.Lock()
	defer fake.jobNameMutex.Unlock()
	fake.JobNameStub = nil
	fake.jobNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) JobNameReturnsOnCall(i int, result1 string) {
	fake.jobNameMutex.Lock()
	defer fake.jobNameMutex.Unlock()
	fake.JobNameStub = nil
	if fake.jobNameReturnsOnCall == nil {
		fake.jobNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.jobNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) LagerData() lager.Data {
	fake.lagerDataMutex.Lock()
	ret, specificReturn := fake.lagerDataReturnsOnCall[len(fake.lagerDataArgsForCall)]
	fake.lagerDataArgsForCall = append(fake.lagerDataArgsForCall, struct {
	}{})
	stub := fake.LagerDataStub
	fakeReturns := fake.lagerDataReturns
	fake.recordInvocation("LagerData", []interface{}{})
	fake.lagerDataMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) LagerDataCallCount() int {
	fake.lagerDataMutex.RLock()
	defer fake.lagerDataMutex.RUnlock()
	return len(fake.lagerDataArgsForCall)
}

func (fake *FakeBuildForAPI) LagerDataCalls(stub func() lager.Data) {
	fake.lagerDataMutex.Lock()
	defer fake.lagerDataMutex.Unlock()
	fake.LagerDataStub = stub
}

func (fake *FakeBuildForAPI) LagerDataReturns(result1 lager.Data) {
	fake.lagerDataMutex.Lock()
	defer fake.lagerDataMutex.Unlock()
	fake.LagerDataStub = nil
	fake.lagerDataReturns = struct {
		result1 lager.Data
	}{result1}
}

func (fake *FakeBuildForAPI) LagerDataReturnsOnCall(i int, result1 lager.Data) {
	fake.lagerDataMutex.Lock()
	defer fake.lagerDataMutex.Unlock()
	fake.LagerDataStub = nil
	if fake.lagerDataReturnsOnCall == nil {
		fake.lagerDataReturnsOnCall = make(map[int]struct {
			result1 lager.Data
		})
	}
	fake.lagerDataReturnsOnCall[i] = struct {
		result1 lager.Data
	}{result1}
}

func (fake *FakeBuildForAPI) MarkAsAborted() error {
	fake.markAsAbortedMutex.Lock()
	ret, specificReturn := fake.markAsAbortedReturnsOnCall[len(fake.markAsAbortedArgsForCall)]
	fake.markAsAbortedArgsForCall = append(fake.markAsAbortedArgsForCall, struct {
	}{})
	stub := fake.MarkAsAbortedStub
	fakeReturns := fake.markAsAbortedReturns
	fake.recordInvocation("MarkAsAborted", []interface{}{})
	fake.markAsAbortedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) MarkAsAbortedCallCount() int {
	fake.markAsAbortedMutex.RLock()
	defer fake.markAsAbortedMutex.RUnlock()
	return len(fake.markAsAbortedArgsForCall)
}

func (fake *FakeBuildForAPI) MarkAsAbortedCalls(stub func() error) {
	fake.markAsAbortedMutex.Lock()
	defer fake.markAsAbortedMutex.Unlock()
	fake.MarkAsAbortedStub = stub
}

func (fake *FakeBuildForAPI) MarkAsAbortedReturns(result1 error) {
	fake.markAsAbortedMutex.Lock()
	defer fake.markAsAbortedMutex.Unlock()
	fake.MarkAsAbortedStub = nil
	fake.markAsAbortedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildForAPI) MarkAsAbortedReturnsOnCall(i int, result1 error) {
	fake.markAsAbortedMutex.Lock()
	defer fake.markAsAbortedMutex.Unlock()
	fake.MarkAsAbortedStub = nil
	if fake.markAsAbortedReturnsOnCall == nil {
		fake.markAsAbortedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.markAsAbortedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildForAPI) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeBuildForAPI) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeBuildForAPI) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) Pipeline() (db.Pipeline, bool, error) {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct {
	}{})
	stub := fake.PipelineStub
	fakeReturns := fake.pipelineReturns
	fake.recordInvocation("Pipeline", []interface{}{})
	fake.pipelineMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuildForAPI) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeBuildForAPI) PipelineCalls(stub func() (db.Pipeline, bool, error)) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = stub
}

func (fake *FakeBuildForAPI) PipelineReturns(result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildForAPI) PipelineReturnsOnCall(i int, result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildForAPI) PipelineID() int {
	fake.pipelineIDMutex.Lock()
	ret, specificReturn := fake.pipelineIDReturnsOnCall[len(fake.pipelineIDArgsForCall)]
	fake.pipelineIDArgsForCall = append(fake.pipelineIDArgsForCall, struct {
	}{})
	stub := fake.PipelineIDStub
	fakeReturns := fake.pipelineIDReturns
	fake.recordInvocation("PipelineID", []interface{}{})
	fake.pipelineIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) PipelineIDCallCount() int {
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	return len(fake.pipelineIDArgsForCall)
}

func (fake *FakeBuildForAPI) PipelineIDCalls(stub func() int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = stub
}

func (fake *FakeBuildForAPI) PipelineIDReturns(result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	fake.pipelineIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) PipelineIDReturnsOnCall(i int, result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	if fake.pipelineIDReturnsOnCall == nil {
		fake.pipelineIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.pipelineIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) PipelineInstanceVars() atc.InstanceVars {
	fake.pipelineInstanceVarsMutex.Lock()
	ret, specificReturn := fake.pipelineInstanceVarsReturnsOnCall[len(fake.pipelineInstanceVarsArgsForCall)]
	fake.pipelineInstanceVarsArgsForCall = append(fake.pipelineInstanceVarsArgsForCall, struct {
	}{})
	stub := fake.PipelineInstanceVarsStub
	fakeReturns := fake.pipelineInstanceVarsReturns
	fake.recordInvocation("PipelineInstanceVars", []interface{}{})
	fake.pipelineInstanceVarsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) PipelineInstanceVarsCallCount() int {
	fake.pipelineInstanceVarsMutex.RLock()
	defer fake.pipelineInstanceVarsMutex.RUnlock()
	return len(fake.pipelineInstanceVarsArgsForCall)
}

func (fake *FakeBuildForAPI) PipelineInstanceVarsCalls(stub func() atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = stub
}

func (fake *FakeBuildForAPI) PipelineInstanceVarsReturns(result1 atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = nil
	fake.pipelineInstanceVarsReturns = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakeBuildForAPI) PipelineInstanceVarsReturnsOnCall(i int, result1 atc.InstanceVars) {
	fake.pipelineInstanceVarsMutex.Lock()
	defer fake.pipelineInstanceVarsMutex.Unlock()
	fake.PipelineInstanceVarsStub = nil
	if fake.pipelineInstanceVarsReturnsOnCall == nil {
		fake.pipelineInstanceVarsReturnsOnCall = make(map[int]struct {
			result1 atc.InstanceVars
		})
	}
	fake.pipelineInstanceVarsReturnsOnCall[i] = struct {
		result1 atc.InstanceVars
	}{result1}
}

func (fake *FakeBuildForAPI) PipelineName() string {
	fake.pipelineNameMutex.Lock()
	ret, specificReturn := fake.pipelineNameReturnsOnCall[len(fake.pipelineNameArgsForCall)]
	fake.pipelineNameArgsForCall = append(fake.pipelineNameArgsForCall, struct {
	}{})
	stub := fake.PipelineNameStub
	fakeReturns := fake.pipelineNameReturns
	fake.recordInvocation("PipelineName", []interface{}{})
	fake.pipelineNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) PipelineNameCallCount() int {
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	return len(fake.pipelineNameArgsForCall)
}

func (fake *FakeBuildForAPI) PipelineNameCalls(stub func() string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = stub
}

func (fake *FakeBuildForAPI) PipelineNameReturns(result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	fake.pipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) PipelineNameReturnsOnCall(i int, result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	if fake.pipelineNameReturnsOnCall == nil {
		fake.pipelineNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pipelineNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) PipelineRef() atc.PipelineRef {
	fake.pipelineRefMutex.Lock()
	ret, specificReturn := fake.pipelineRefReturnsOnCall[len(fake.pipelineRefArgsForCall)]
	fake.pipelineRefArgsForCall = append(fake.pipelineRefArgsForCall, struct {
	}{})
	stub := fake.PipelineRefStub
	fakeReturns := fake.pipelineRefReturns
	fake.recordInvocation("PipelineRef", []interface{}{})
	fake.pipelineRefMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) PipelineRefCallCount() int {
	fake.pipelineRefMutex.RLock()
	defer fake.pipelineRefMutex.RUnlock()
	return len(fake.pipelineRefArgsForCall)
}

func (fake *FakeBuildForAPI) PipelineRefCalls(stub func() atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = stub
}

func (fake *FakeBuildForAPI) PipelineRefReturns(result1 atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = nil
	fake.pipelineRefReturns = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakeBuildForAPI) PipelineRefReturnsOnCall(i int, result1 atc.PipelineRef) {
	fake.pipelineRefMutex.Lock()
	defer fake.pipelineRefMutex.Unlock()
	fake.PipelineRefStub = nil
	if fake.pipelineRefReturnsOnCall == nil {
		fake.pipelineRefReturnsOnCall = make(map[int]struct {
			result1 atc.PipelineRef
		})
	}
	fake.pipelineRefReturnsOnCall[i] = struct {
		result1 atc.PipelineRef
	}{result1}
}

func (fake *FakeBuildForAPI) Preparation() (db.BuildPreparation, bool, error) {
	fake.preparationMutex.Lock()
	ret, specificReturn := fake.preparationReturnsOnCall[len(fake.preparationArgsForCall)]
	fake.preparationArgsForCall = append(fake.preparationArgsForCall, struct {
	}{})
	stub := fake.PreparationStub
	fakeReturns := fake.preparationReturns
	fake.recordInvocation("Preparation", []interface{}{})
	fake.preparationMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuildForAPI) PreparationCallCount() int {
	fake.preparationMutex.RLock()
	defer fake.preparationMutex.RUnlock()
	return len(fake.preparationArgsForCall)
}

func (fake *FakeBuildForAPI) PreparationCalls(stub func() (db.BuildPreparation, bool, error)) {
	fake.preparationMutex.Lock()
	defer fake.preparationMutex.Unlock()
	fake.PreparationStub = stub
}

func (fake *FakeBuildForAPI) PreparationReturns(result1 db.BuildPreparation, result2 bool, result3 error) {
	fake.preparationMutex.Lock()
	defer fake.preparationMutex.Unlock()
	fake.PreparationStub = nil
	fake.preparationReturns = struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildForAPI) PreparationReturnsOnCall(i int, result1 db.BuildPreparation, result2 bool, result3 error) {
	fake.preparationMutex.Lock()
	defer fake.preparationMutex.Unlock()
	fake.PreparationStub = nil
	if fake.preparationReturnsOnCall == nil {
		fake.preparationReturnsOnCall = make(map[int]struct {
			result1 db.BuildPreparation
			result2 bool
			result3 error
		})
	}
	fake.preparationReturnsOnCall[i] = struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildForAPI) PublicPlan() *json.RawMessage {
	fake.publicPlanMutex.Lock()
	ret, specificReturn := fake.publicPlanReturnsOnCall[len(fake.publicPlanArgsForCall)]
	fake.publicPlanArgsForCall = append(fake.publicPlanArgsForCall, struct {
	}{})
	stub := fake.PublicPlanStub
	fakeReturns := fake.publicPlanReturns
	fake.recordInvocation("PublicPlan", []interface{}{})
	fake.publicPlanMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) PublicPlanCallCount() int {
	fake.publicPlanMutex.RLock()
	defer fake.publicPlanMutex.RUnlock()
	return len(fake.publicPlanArgsForCall)
}

func (fake *FakeBuildForAPI) PublicPlanCalls(stub func() *json.RawMessage) {
	fake.publicPlanMutex.Lock()
	defer fake.publicPlanMutex.Unlock()
	fake.PublicPlanStub = stub
}

func (fake *FakeBuildForAPI) PublicPlanReturns(result1 *json.RawMessage) {
	fake.publicPlanMutex.Lock()
	defer fake.publicPlanMutex.Unlock()
	fake.PublicPlanStub = nil
	fake.publicPlanReturns = struct {
		result1 *json.RawMessage
	}{result1}
}

func (fake *FakeBuildForAPI) PublicPlanReturnsOnCall(i int, result1 *json.RawMessage) {
	fake.publicPlanMutex.Lock()
	defer fake.publicPlanMutex.Unlock()
	fake.PublicPlanStub = nil
	if fake.publicPlanReturnsOnCall == nil {
		fake.publicPlanReturnsOnCall = make(map[int]struct {
			result1 *json.RawMessage
		})
	}
	fake.publicPlanReturnsOnCall[i] = struct {
		result1 *json.RawMessage
	}{result1}
}

func (fake *FakeBuildForAPI) ReapTime() time.Time {
	fake.reapTimeMutex.Lock()
	ret, specificReturn := fake.reapTimeReturnsOnCall[len(fake.reapTimeArgsForCall)]
	fake.reapTimeArgsForCall = append(fake.reapTimeArgsForCall, struct {
	}{})
	stub := fake.ReapTimeStub
	fakeReturns := fake.reapTimeReturns
	fake.recordInvocation("ReapTime", []interface{}{})
	fake.reapTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) ReapTimeCallCount() int {
	fake.reapTimeMutex.RLock()
	defer fake.reapTimeMutex.RUnlock()
	return len(fake.reapTimeArgsForCall)
}

func (fake *FakeBuildForAPI) ReapTimeCalls(stub func() time.Time) {
	fake.reapTimeMutex.Lock()
	defer fake.reapTimeMutex.Unlock()
	fake.ReapTimeStub = stub
}

func (fake *FakeBuildForAPI) ReapTimeReturns(result1 time.Time) {
	fake.reapTimeMutex.Lock()
	defer fake.reapTimeMutex.Unlock()
	fake.ReapTimeStub = nil
	fake.reapTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuildForAPI) ReapTimeReturnsOnCall(i int, result1 time.Time) {
	fake.reapTimeMutex.Lock()
	defer fake.reapTimeMutex.Unlock()
	fake.ReapTimeStub = nil
	if fake.reapTimeReturnsOnCall == nil {
		fake.reapTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.reapTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuildForAPI) RerunNumber() int {
	fake.rerunNumberMutex.Lock()
	ret, specificReturn := fake.rerunNumberReturnsOnCall[len(fake.rerunNumberArgsForCall)]
	fake.rerunNumberArgsForCall = append(fake.rerunNumberArgsForCall, struct {
	}{})
	stub := fake.RerunNumberStub
	fakeReturns := fake.rerunNumberReturns
	fake.recordInvocation("RerunNumber", []interface{}{})
	fake.rerunNumberMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) RerunNumberCallCount() int {
	fake.rerunNumberMutex.RLock()
	defer fake.rerunNumberMutex.RUnlock()
	return len(fake.rerunNumberArgsForCall)
}

func (fake *FakeBuildForAPI) RerunNumberCalls(stub func() int) {
	fake.rerunNumberMutex.Lock()
	defer fake.rerunNumberMutex.Unlock()
	fake.RerunNumberStub = stub
}

func (fake *FakeBuildForAPI) RerunNumberReturns(result1 int) {
	fake.rerunNumberMutex.Lock()
	defer fake.rerunNumberMutex.Unlock()
	fake.RerunNumberStub = nil
	fake.rerunNumberReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) RerunNumberReturnsOnCall(i int, result1 int) {
	fake.rerunNumberMutex.Lock()
	defer fake.rerunNumberMutex.Unlock()
	fake.RerunNumberStub = nil
	if fake.rerunNumberReturnsOnCall == nil {
		fake.rerunNumberReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.rerunNumberReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) RerunOf() int {
	fake.rerunOfMutex.Lock()
	ret, specificReturn := fake.rerunOfReturnsOnCall[len(fake.rerunOfArgsForCall)]
	fake.rerunOfArgsForCall = append(fake.rerunOfArgsForCall, struct {
	}{})
	stub := fake.RerunOfStub
	fakeReturns := fake.rerunOfReturns
	fake.recordInvocation("RerunOf", []interface{}{})
	fake.rerunOfMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) RerunOfCallCount() int {
	fake.rerunOfMutex.RLock()
	defer fake.rerunOfMutex.RUnlock()
	return len(fake.rerunOfArgsForCall)
}

func (fake *FakeBuildForAPI) RerunOfCalls(stub func() int) {
	fake.rerunOfMutex.Lock()
	defer fake.rerunOfMutex.Unlock()
	fake.RerunOfStub = stub
}

func (fake *FakeBuildForAPI) RerunOfReturns(result1 int) {
	fake.rerunOfMutex.Lock()
	defer fake.rerunOfMutex.Unlock()
	fake.RerunOfStub = nil
	fake.rerunOfReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) RerunOfReturnsOnCall(i int, result1 int) {
	fake.rerunOfMutex.Lock()
	defer fake.rerunOfMutex.Unlock()
	fake.RerunOfStub = nil
	if fake.rerunOfReturnsOnCall == nil {
		fake.rerunOfReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.rerunOfReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) RerunOfName() string {
	fake.rerunOfNameMutex.Lock()
	ret, specificReturn := fake.rerunOfNameReturnsOnCall[len(fake.rerunOfNameArgsForCall)]
	fake.rerunOfNameArgsForCall = append(fake.rerunOfNameArgsForCall, struct {
	}{})
	stub := fake.RerunOfNameStub
	fakeReturns := fake.rerunOfNameReturns
	fake.recordInvocation("RerunOfName", []interface{}{})
	fake.rerunOfNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) RerunOfNameCallCount() int {
	fake.rerunOfNameMutex.RLock()
	defer fake.rerunOfNameMutex.RUnlock()
	return len(fake.rerunOfNameArgsForCall)
}

func (fake *FakeBuildForAPI) RerunOfNameCalls(stub func() string) {
	fake.rerunOfNameMutex.Lock()
	defer fake.rerunOfNameMutex.Unlock()
	fake.RerunOfNameStub = stub
}

func (fake *FakeBuildForAPI) RerunOfNameReturns(result1 string) {
	fake.rerunOfNameMutex.Lock()
	defer fake.rerunOfNameMutex.Unlock()
	fake.RerunOfNameStub = nil
	fake.rerunOfNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) RerunOfNameReturnsOnCall(i int, result1 string) {
	fake.rerunOfNameMutex.Lock()
	defer fake.rerunOfNameMutex.Unlock()
	fake.RerunOfNameStub = nil
	if fake.rerunOfNameReturnsOnCall == nil {
		fake.rerunOfNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.rerunOfNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) ResourceID() int {
	fake.resourceIDMutex.Lock()
	ret, specificReturn := fake.resourceIDReturnsOnCall[len(fake.resourceIDArgsForCall)]
	fake.resourceIDArgsForCall = append(fake.resourceIDArgsForCall, struct {
	}{})
	stub := fake.ResourceIDStub
	fakeReturns := fake.resourceIDReturns
	fake.recordInvocation("ResourceID", []interface{}{})
	fake.resourceIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) ResourceIDCallCount() int {
	fake.resourceIDMutex.RLock()
	defer fake.resourceIDMutex.RUnlock()
	return len(fake.resourceIDArgsForCall)
}

func (fake *FakeBuildForAPI) ResourceIDCalls(stub func() int) {
	fake.resourceIDMutex.Lock()
	defer fake.resourceIDMutex.Unlock()
	fake.ResourceIDStub = stub
}

func (fake *FakeBuildForAPI) ResourceIDReturns(result1 int) {
	fake.resourceIDMutex.Lock()
	defer fake.resourceIDMutex.Unlock()
	fake.ResourceIDStub = nil
	fake.resourceIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) ResourceIDReturnsOnCall(i int, result1 int) {
	fake.resourceIDMutex.Lock()
	defer fake.resourceIDMutex.Unlock()
	fake.ResourceIDStub = nil
	if fake.resourceIDReturnsOnCall == nil {
		fake.resourceIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.resourceIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) ResourceName() string {
	fake.resourceNameMutex.Lock()
	ret, specificReturn := fake.resourceNameReturnsOnCall[len(fake.resourceNameArgsForCall)]
	fake.resourceNameArgsForCall = append(fake.resourceNameArgsForCall, struct {
	}{})
	stub := fake.ResourceNameStub
	fakeReturns := fake.resourceNameReturns
	fake.recordInvocation("ResourceName", []interface{}{})
	fake.resourceNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) ResourceNameCallCount() int {
	fake.resourceNameMutex.RLock()
	defer fake.resourceNameMutex.RUnlock()
	return len(fake.resourceNameArgsForCall)
}

func (fake *FakeBuildForAPI) ResourceNameCalls(stub func() string) {
	fake.resourceNameMutex.Lock()
	defer fake.resourceNameMutex.Unlock()
	fake.ResourceNameStub = stub
}

func (fake *FakeBuildForAPI) ResourceNameReturns(result1 string) {
	fake.resourceNameMutex.Lock()
	defer fake.resourceNameMutex.Unlock()
	fake.ResourceNameStub = nil
	fake.resourceNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) ResourceNameReturnsOnCall(i int, result1 string) {
	fake.resourceNameMutex.Lock()
	defer fake.resourceNameMutex.Unlock()
	fake.ResourceNameStub = nil
	if fake.resourceNameReturnsOnCall == nil {
		fake.resourceNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.resourceNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) Resources() ([]db.BuildInput, []db.BuildOutput, error) {
	fake.resourcesMutex.Lock()
	ret, specificReturn := fake.resourcesReturnsOnCall[len(fake.resourcesArgsForCall)]
	fake.resourcesArgsForCall = append(fake.resourcesArgsForCall, struct {
	}{})
	stub := fake.ResourcesStub
	fakeReturns := fake.resourcesReturns
	fake.recordInvocation("Resources", []interface{}{})
	fake.resourcesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuildForAPI) ResourcesCallCount() int {
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	return len(fake.resourcesArgsForCall)
}

func (fake *FakeBuildForAPI) ResourcesCalls(stub func() ([]db.BuildInput, []db.BuildOutput, error)) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = stub
}

func (fake *FakeBuildForAPI) ResourcesReturns(result1 []db.BuildInput, result2 []db.BuildOutput, result3 error) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = nil
	fake.resourcesReturns = struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildForAPI) ResourcesReturnsOnCall(i int, result1 []db.BuildInput, result2 []db.BuildOutput, result3 error) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = nil
	if fake.resourcesReturnsOnCall == nil {
		fake.resourcesReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 []db.BuildOutput
			result3 error
		})
	}
	fake.resourcesReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 []db.BuildOutput
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildForAPI) Schema() string {
	fake.schemaMutex.Lock()
	ret, specificReturn := fake.schemaReturnsOnCall[len(fake.schemaArgsForCall)]
	fake.schemaArgsForCall = append(fake.schemaArgsForCall, struct {
	}{})
	stub := fake.SchemaStub
	fakeReturns := fake.schemaReturns
	fake.recordInvocation("Schema", []interface{}{})
	fake.schemaMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) SchemaCallCount() int {
	fake.schemaMutex.RLock()
	defer fake.schemaMutex.RUnlock()
	return len(fake.schemaArgsForCall)
}

func (fake *FakeBuildForAPI) SchemaCalls(stub func() string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = stub
}

func (fake *FakeBuildForAPI) SchemaReturns(result1 string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = nil
	fake.schemaReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) SchemaReturnsOnCall(i int, result1 string) {
	fake.schemaMutex.Lock()
	defer fake.schemaMutex.Unlock()
	fake.SchemaStub = nil
	if fake.schemaReturnsOnCall == nil {
		fake.schemaReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.schemaReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) SetComment(arg1 string) error {
	fake.setCommentMutex.Lock()
	ret, specificReturn := fake.setCommentReturnsOnCall[len(fake.setCommentArgsForCall)]
	fake.setCommentArgsForCall = append(fake.setCommentArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetCommentStub
	fakeReturns := fake.setCommentReturns
	fake.recordInvocation("SetComment", []interface{}{arg1})
	fake.setCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) SetCommentCallCount() int {
	fake.setCommentMutex.RLock()
	defer fake.setCommentMutex.RUnlock()
	return len(fake.setCommentArgsForCall)
}

func (fake *FakeBuildForAPI) SetCommentCalls(stub func(string) error) {
	fake.setCommentMutex.Lock()
	defer fake.setCommentMutex.Unlock()
	fake.SetCommentStub = stub
}

func (fake *FakeBuildForAPI) SetCommentArgsForCall(i int) string {
	fake.setCommentMutex.RLock()
	defer fake.setCommentMutex.RUnlock()
	argsForCall := fake.setCommentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuildForAPI) SetCommentReturns(result1 error) {
	fake.setCommentMutex.Lock()
	defer fake.setCommentMutex.Unlock()
	fake.SetCommentStub = nil
	fake.setCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildForAPI) SetCommentReturnsOnCall(i int, result1 error) {
	fake.setCommentMutex.Lock()
	defer fake.setCommentMutex.Unlock()
	fake.SetCommentStub = nil
	if fake.setCommentReturnsOnCall == nil {
		fake.setCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildForAPI) StartTime() time.Time {
	fake.startTimeMutex.Lock()
	ret, specificReturn := fake.startTimeReturnsOnCall[len(fake.startTimeArgsForCall)]
	fake.startTimeArgsForCall = append(fake.startTimeArgsForCall, struct {
	}{})
	stub := fake.StartTimeStub
	fakeReturns := fake.startTimeReturns
	fake.recordInvocation("StartTime", []interface{}{})
	fake.startTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) StartTimeCallCount() int {
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	return len(fake.startTimeArgsForCall)
}

func (fake *FakeBuildForAPI) StartTimeCalls(stub func() time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = stub
}

func (fake *FakeBuildForAPI) StartTimeReturns(result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	fake.startTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuildForAPI) StartTimeReturnsOnCall(i int, result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	if fake.startTimeReturnsOnCall == nil {
		fake.startTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.startTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeBuildForAPI) Status() db.BuildStatus {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	stub := fake.StatusStub
	fakeReturns := fake.statusReturns
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeBuildForAPI) StatusCalls(stub func() db.BuildStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeBuildForAPI) StatusReturns(result1 db.BuildStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 db.BuildStatus
	}{result1}
}

func (fake *FakeBuildForAPI) StatusReturnsOnCall(i int, result1 db.BuildStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 db.BuildStatus
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 db.BuildStatus
	}{result1}
}

func (fake *FakeBuildForAPI) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	stub := fake.TeamIDStub
	fakeReturns := fake.teamIDReturns
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakeBuildForAPI) TeamIDCalls(stub func() int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = stub
}

func (fake *FakeBuildForAPI) TeamIDReturns(result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) TeamIDReturnsOnCall(i int, result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBuildForAPI) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	stub := fake.TeamNameStub
	fakeReturns := fake.teamNameReturns
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildForAPI) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakeBuildForAPI) TeamNameCalls(stub func() string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = stub
}

func (fake *FakeBuildForAPI) TeamNameReturns(result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) TeamNameReturnsOnCall(i int, result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuildForAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allAssociatedTeamNamesMutex.RLock()
	defer fake.allAssociatedTeamNamesMutex.RUnlock()
	fake.artifactsMutex.RLock()
	defer fake.artifactsMutex.RUnlock()
	fake.commentMutex.RLock()
	defer fake.commentMutex.RUnlock()
	fake.createdByMutex.RLock()
	defer fake.createdByMutex.RUnlock()
	fake.endTimeMutex.RLock()
	defer fake.endTimeMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.hasPlanMutex.RLock()
	defer fake.hasPlanMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.isDrainedMutex.RLock()
	defer fake.isDrainedMutex.RUnlock()
	fake.isRunningMutex.RLock()
	defer fake.isRunningMutex.RUnlock()
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	fake.jobNameMutex.RLock()
	defer fake.jobNameMutex.RUnlock()
	fake.lagerDataMutex.RLock()
	defer fake.lagerDataMutex.RUnlock()
	fake.markAsAbortedMutex.RLock()
	defer fake.markAsAbortedMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	fake.pipelineInstanceVarsMutex.RLock()
	defer fake.pipelineInstanceVarsMutex.RUnlock()
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	fake.pipelineRefMutex.RLock()
	defer fake.pipelineRefMutex.RUnlock()
	fake.preparationMutex.RLock()
	defer fake.preparationMutex.RUnlock()
	fake.publicPlanMutex.RLock()
	defer fake.publicPlanMutex.RUnlock()
	fake.reapTimeMutex.RLock()
	defer fake.reapTimeMutex.RUnlock()
	fake.rerunNumberMutex.RLock()
	defer fake.rerunNumberMutex.RUnlock()
	fake.rerunOfMutex.RLock()
	defer fake.rerunOfMutex.RUnlock()
	fake.rerunOfNameMutex.RLock()
	defer fake.rerunOfNameMutex.RUnlock()
	fake.resourceIDMutex.RLock()
	defer fake.resourceIDMutex.RUnlock()
	fake.resourceNameMutex.RLock()
	defer fake.resourceNameMutex.RUnlock()
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	fake.schemaMutex.RLock()
	defer fake.schemaMutex.RUnlock()
	fake.setCommentMutex.RLock()
	defer fake.setCommentMutex.RUnlock()
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBuildForAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.BuildForAPI = new(FakeBuildForAPI)
