// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"github.com/concourse/concourse/atc/db"
)

type FakeVolumeRepository struct {
	CreateBaseResourceTypeVolumeStub        func(*db.UsedWorkerBaseResourceType) (db.CreatingVolume, error)
	createBaseResourceTypeVolumeMutex       sync.RWMutex
	createBaseResourceTypeVolumeArgsForCall []struct {
		arg1 *db.UsedWorkerBaseResourceType
	}
	createBaseResourceTypeVolumeReturns struct {
		result1 db.CreatingVolume
		result2 error
	}
	createBaseResourceTypeVolumeReturnsOnCall map[int]struct {
		result1 db.CreatingVolume
		result2 error
	}
	CreateContainerVolumeStub        func(int, string, db.CreatingContainer, string) (db.CreatingVolume, error)
	createContainerVolumeMutex       sync.RWMutex
	createContainerVolumeArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 db.CreatingContainer
		arg4 string
	}
	createContainerVolumeReturns struct {
		result1 db.CreatingVolume
		result2 error
	}
	createContainerVolumeReturnsOnCall map[int]struct {
		result1 db.CreatingVolume
		result2 error
	}
	CreateResourceCertsVolumeStub        func(string, *db.UsedWorkerResourceCerts) (db.CreatingVolume, error)
	createResourceCertsVolumeMutex       sync.RWMutex
	createResourceCertsVolumeArgsForCall []struct {
		arg1 string
		arg2 *db.UsedWorkerResourceCerts
	}
	createResourceCertsVolumeReturns struct {
		result1 db.CreatingVolume
		result2 error
	}
	createResourceCertsVolumeReturnsOnCall map[int]struct {
		result1 db.CreatingVolume
		result2 error
	}
	CreateTaskCacheVolumeStub        func(int, *db.UsedWorkerTaskCache) (db.CreatingVolume, error)
	createTaskCacheVolumeMutex       sync.RWMutex
	createTaskCacheVolumeArgsForCall []struct {
		arg1 int
		arg2 *db.UsedWorkerTaskCache
	}
	createTaskCacheVolumeReturns struct {
		result1 db.CreatingVolume
		result2 error
	}
	createTaskCacheVolumeReturnsOnCall map[int]struct {
		result1 db.CreatingVolume
		result2 error
	}
	CreateVolumeStub        func(int, string, db.VolumeType) (db.CreatingVolume, error)
	createVolumeMutex       sync.RWMutex
	createVolumeArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 db.VolumeType
	}
	createVolumeReturns struct {
		result1 db.CreatingVolume
		result2 error
	}
	createVolumeReturnsOnCall map[int]struct {
		result1 db.CreatingVolume
		result2 error
	}
	CreateVolumeWithHandleStub        func(string, int, string, db.VolumeType) (db.CreatingVolume, error)
	createVolumeWithHandleMutex       sync.RWMutex
	createVolumeWithHandleArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 db.VolumeType
	}
	createVolumeWithHandleReturns struct {
		result1 db.CreatingVolume
		result2 error
	}
	createVolumeWithHandleReturnsOnCall map[int]struct {
		result1 db.CreatingVolume
		result2 error
	}
	DestroyFailedVolumesStub        func() (int, error)
	destroyFailedVolumesMutex       sync.RWMutex
	destroyFailedVolumesArgsForCall []struct {
	}
	destroyFailedVolumesReturns struct {
		result1 int
		result2 error
	}
	destroyFailedVolumesReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	DestroyUnknownVolumesStub        func(string, []string) (int, error)
	destroyUnknownVolumesMutex       sync.RWMutex
	destroyUnknownVolumesArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	destroyUnknownVolumesReturns struct {
		result1 int
		result2 error
	}
	destroyUnknownVolumesReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	FindBaseResourceTypeVolumeStub        func(*db.UsedWorkerBaseResourceType) (db.CreatingVolume, db.CreatedVolume, error)
	findBaseResourceTypeVolumeMutex       sync.RWMutex
	findBaseResourceTypeVolumeArgsForCall []struct {
		arg1 *db.UsedWorkerBaseResourceType
	}
	findBaseResourceTypeVolumeReturns struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}
	findBaseResourceTypeVolumeReturnsOnCall map[int]struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}
	FindContainerVolumeStub        func(int, string, db.CreatingContainer, string) (db.CreatingVolume, db.CreatedVolume, error)
	findContainerVolumeMutex       sync.RWMutex
	findContainerVolumeArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 db.CreatingContainer
		arg4 string
	}
	findContainerVolumeReturns struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}
	findContainerVolumeReturnsOnCall map[int]struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}
	FindResourceCacheVolumeStub        func(string, db.ResourceCache, time.Time) (db.CreatedVolume, bool, error)
	findResourceCacheVolumeMutex       sync.RWMutex
	findResourceCacheVolumeArgsForCall []struct {
		arg1 string
		arg2 db.ResourceCache
		arg3 time.Time
	}
	findResourceCacheVolumeReturns struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}
	findResourceCacheVolumeReturnsOnCall map[int]struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}
	FindResourceCertsVolumeStub        func(string, *db.UsedWorkerResourceCerts) (db.CreatingVolume, db.CreatedVolume, error)
	findResourceCertsVolumeMutex       sync.RWMutex
	findResourceCertsVolumeArgsForCall []struct {
		arg1 string
		arg2 *db.UsedWorkerResourceCerts
	}
	findResourceCertsVolumeReturns struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}
	findResourceCertsVolumeReturnsOnCall map[int]struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}
	FindTaskCacheVolumeStub        func(int, string, db.UsedTaskCache) (db.CreatedVolume, bool, error)
	findTaskCacheVolumeMutex       sync.RWMutex
	findTaskCacheVolumeArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 db.UsedTaskCache
	}
	findTaskCacheVolumeReturns struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}
	findTaskCacheVolumeReturnsOnCall map[int]struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}
	FindVolumeStub        func(string) (db.CreatedVolume, bool, error)
	findVolumeMutex       sync.RWMutex
	findVolumeArgsForCall []struct {
		arg1 string
	}
	findVolumeReturns struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}
	findVolumeReturnsOnCall map[int]struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}
	FindVolumesForContainerStub        func(db.CreatedContainer) ([]db.CreatedVolume, error)
	findVolumesForContainerMutex       sync.RWMutex
	findVolumesForContainerArgsForCall []struct {
		arg1 db.CreatedContainer
	}
	findVolumesForContainerReturns struct {
		result1 []db.CreatedVolume
		result2 error
	}
	findVolumesForContainerReturnsOnCall map[int]struct {
		result1 []db.CreatedVolume
		result2 error
	}
	FindWorkersForResourceCacheStub        func(db.ResourceCache) ([]string, error)
	findWorkersForResourceCacheMutex       sync.RWMutex
	findWorkersForResourceCacheArgsForCall []struct {
		arg1 db.ResourceCache
	}
	findWorkersForResourceCacheReturns struct {
		result1 []string
		result2 error
	}
	findWorkersForResourceCacheReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	FindWorkersForTaskCacheStub        func(db.UsedTaskCache) ([]string, error)
	findWorkersForTaskCacheMutex       sync.RWMutex
	findWorkersForTaskCacheArgsForCall []struct {
		arg1 db.UsedTaskCache
	}
	findWorkersForTaskCacheReturns struct {
		result1 []string
		result2 error
	}
	findWorkersForTaskCacheReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetDestroyingVolumesStub        func(string) ([]string, error)
	getDestroyingVolumesMutex       sync.RWMutex
	getDestroyingVolumesArgsForCall []struct {
		arg1 string
	}
	getDestroyingVolumesReturns struct {
		result1 []string
		result2 error
	}
	getDestroyingVolumesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetOrphanedVolumesStub        func() ([]db.CreatedVolume, error)
	getOrphanedVolumesMutex       sync.RWMutex
	getOrphanedVolumesArgsForCall []struct {
	}
	getOrphanedVolumesReturns struct {
		result1 []db.CreatedVolume
		result2 error
	}
	getOrphanedVolumesReturnsOnCall map[int]struct {
		result1 []db.CreatedVolume
		result2 error
	}
	GetTeamVolumesStub        func(int) ([]db.CreatedVolume, error)
	getTeamVolumesMutex       sync.RWMutex
	getTeamVolumesArgsForCall []struct {
		arg1 int
	}
	getTeamVolumesReturns struct {
		result1 []db.CreatedVolume
		result2 error
	}
	getTeamVolumesReturnsOnCall map[int]struct {
		result1 []db.CreatedVolume
		result2 error
	}
	RemoveDestroyingVolumesStub        func(string, []string) (int, error)
	removeDestroyingVolumesMutex       sync.RWMutex
	removeDestroyingVolumesArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	removeDestroyingVolumesReturns struct {
		result1 int
		result2 error
	}
	removeDestroyingVolumesReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	RemoveMissingVolumesStub        func(time.Duration) (int, error)
	removeMissingVolumesMutex       sync.RWMutex
	removeMissingVolumesArgsForCall []struct {
		arg1 time.Duration
	}
	removeMissingVolumesReturns struct {
		result1 int
		result2 error
	}
	removeMissingVolumesReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	UpdateVolumesMissingSinceStub        func(string, []string) error
	updateVolumesMissingSinceMutex       sync.RWMutex
	updateVolumesMissingSinceArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	updateVolumesMissingSinceReturns struct {
		result1 error
	}
	updateVolumesMissingSinceReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeVolumeRepository) CreateBaseResourceTypeVolume(arg1 *db.UsedWorkerBaseResourceType) (db.CreatingVolume, error) {
	fake.createBaseResourceTypeVolumeMutex.Lock()
	ret, specificReturn := fake.createBaseResourceTypeVolumeReturnsOnCall[len(fake.createBaseResourceTypeVolumeArgsForCall)]
	fake.createBaseResourceTypeVolumeArgsForCall = append(fake.createBaseResourceTypeVolumeArgsForCall, struct {
		arg1 *db.UsedWorkerBaseResourceType
	}{arg1})
	stub := fake.CreateBaseResourceTypeVolumeStub
	fakeReturns := fake.createBaseResourceTypeVolumeReturns
	fake.recordInvocation("CreateBaseResourceTypeVolume", []interface{}{arg1})
	fake.createBaseResourceTypeVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) CreateBaseResourceTypeVolumeCallCount() int {
	fake.createBaseResourceTypeVolumeMutex.RLock()
	defer fake.createBaseResourceTypeVolumeMutex.RUnlock()
	return len(fake.createBaseResourceTypeVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) CreateBaseResourceTypeVolumeCalls(stub func(*db.UsedWorkerBaseResourceType) (db.CreatingVolume, error)) {
	fake.createBaseResourceTypeVolumeMutex.Lock()
	defer fake.createBaseResourceTypeVolumeMutex.Unlock()
	fake.CreateBaseResourceTypeVolumeStub = stub
}

func (fake *FakeVolumeRepository) CreateBaseResourceTypeVolumeArgsForCall(i int) *db.UsedWorkerBaseResourceType {
	fake.createBaseResourceTypeVolumeMutex.RLock()
	defer fake.createBaseResourceTypeVolumeMutex.RUnlock()
	argsForCall := fake.createBaseResourceTypeVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVolumeRepository) CreateBaseResourceTypeVolumeReturns(result1 db.CreatingVolume, result2 error) {
	fake.createBaseResourceTypeVolumeMutex.Lock()
	defer fake.createBaseResourceTypeVolumeMutex.Unlock()
	fake.CreateBaseResourceTypeVolumeStub = nil
	fake.createBaseResourceTypeVolumeReturns = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateBaseResourceTypeVolumeReturnsOnCall(i int, result1 db.CreatingVolume, result2 error) {
	fake.createBaseResourceTypeVolumeMutex.Lock()
	defer fake.createBaseResourceTypeVolumeMutex.Unlock()
	fake.CreateBaseResourceTypeVolumeStub = nil
	if fake.createBaseResourceTypeVolumeReturnsOnCall == nil {
		fake.createBaseResourceTypeVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatingVolume
			result2 error
		})
	}
	fake.createBaseResourceTypeVolumeReturnsOnCall[i] = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateContainerVolume(arg1 int, arg2 string, arg3 db.CreatingContainer, arg4 string) (db.CreatingVolume, error) {
	fake.createContainerVolumeMutex.Lock()
	ret, specificReturn := fake.createContainerVolumeReturnsOnCall[len(fake.createContainerVolumeArgsForCall)]
	fake.createContainerVolumeArgsForCall = append(fake.createContainerVolumeArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 db.CreatingContainer
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateContainerVolumeStub
	fakeReturns := fake.createContainerVolumeReturns
	fake.recordInvocation("CreateContainerVolume", []interface{}{arg1, arg2, arg3, arg4})
	fake.createContainerVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) CreateContainerVolumeCallCount() int {
	fake.createContainerVolumeMutex.RLock()
	defer fake.createContainerVolumeMutex.RUnlock()
	return len(fake.createContainerVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) CreateContainerVolumeCalls(stub func(int, string, db.CreatingContainer, string) (db.CreatingVolume, error)) {
	fake.createContainerVolumeMutex.Lock()
	defer fake.createContainerVolumeMutex.Unlock()
	fake.CreateContainerVolumeStub = stub
}

func (fake *FakeVolumeRepository) CreateContainerVolumeArgsForCall(i int) (int, string, db.CreatingContainer, string) {
	fake.createContainerVolumeMutex.RLock()
	defer fake.createContainerVolumeMutex.RUnlock()
	argsForCall := fake.createContainerVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeVolumeRepository) CreateContainerVolumeReturns(result1 db.CreatingVolume, result2 error) {
	fake.createContainerVolumeMutex.Lock()
	defer fake.createContainerVolumeMutex.Unlock()
	fake.CreateContainerVolumeStub = nil
	fake.createContainerVolumeReturns = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateContainerVolumeReturnsOnCall(i int, result1 db.CreatingVolume, result2 error) {
	fake.createContainerVolumeMutex.Lock()
	defer fake.createContainerVolumeMutex.Unlock()
	fake.CreateContainerVolumeStub = nil
	if fake.createContainerVolumeReturnsOnCall == nil {
		fake.createContainerVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatingVolume
			result2 error
		})
	}
	fake.createContainerVolumeReturnsOnCall[i] = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateResourceCertsVolume(arg1 string, arg2 *db.UsedWorkerResourceCerts) (db.CreatingVolume, error) {
	fake.createResourceCertsVolumeMutex.Lock()
	ret, specificReturn := fake.createResourceCertsVolumeReturnsOnCall[len(fake.createResourceCertsVolumeArgsForCall)]
	fake.createResourceCertsVolumeArgsForCall = append(fake.createResourceCertsVolumeArgsForCall, struct {
		arg1 string
		arg2 *db.UsedWorkerResourceCerts
	}{arg1, arg2})
	stub := fake.CreateResourceCertsVolumeStub
	fakeReturns := fake.createResourceCertsVolumeReturns
	fake.recordInvocation("CreateResourceCertsVolume", []interface{}{arg1, arg2})
	fake.createResourceCertsVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) CreateResourceCertsVolumeCallCount() int {
	fake.createResourceCertsVolumeMutex.RLock()
	defer fake.createResourceCertsVolumeMutex.RUnlock()
	return len(fake.createResourceCertsVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) CreateResourceCertsVolumeCalls(stub func(string, *db.UsedWorkerResourceCerts) (db.CreatingVolume, error)) {
	fake.createResourceCertsVolumeMutex.Lock()
	defer fake.createResourceCertsVolumeMutex.Unlock()
	fake.CreateResourceCertsVolumeStub = stub
}

func (fake *FakeVolumeRepository) CreateResourceCertsVolumeArgsForCall(i int) (string, *db.UsedWorkerResourceCerts) {
	fake.createResourceCertsVolumeMutex.RLock()
	defer fake.createResourceCertsVolumeMutex.RUnlock()
	argsForCall := fake.createResourceCertsVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVolumeRepository) CreateResourceCertsVolumeReturns(result1 db.CreatingVolume, result2 error) {
	fake.createResourceCertsVolumeMutex.Lock()
	defer fake.createResourceCertsVolumeMutex.Unlock()
	fake.CreateResourceCertsVolumeStub = nil
	fake.createResourceCertsVolumeReturns = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateResourceCertsVolumeReturnsOnCall(i int, result1 db.CreatingVolume, result2 error) {
	fake.createResourceCertsVolumeMutex.Lock()
	defer fake.createResourceCertsVolumeMutex.Unlock()
	fake.CreateResourceCertsVolumeStub = nil
	if fake.createResourceCertsVolumeReturnsOnCall == nil {
		fake.createResourceCertsVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatingVolume
			result2 error
		})
	}
	fake.createResourceCertsVolumeReturnsOnCall[i] = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateTaskCacheVolume(arg1 int, arg2 *db.UsedWorkerTaskCache) (db.CreatingVolume, error) {
	fake.createTaskCacheVolumeMutex.Lock()
	ret, specificReturn := fake.createTaskCacheVolumeReturnsOnCall[len(fake.createTaskCacheVolumeArgsForCall)]
	fake.createTaskCacheVolumeArgsForCall = append(fake.createTaskCacheVolumeArgsForCall, struct {
		arg1 int
		arg2 *db.UsedWorkerTaskCache
	}{arg1, arg2})
	stub := fake.CreateTaskCacheVolumeStub
	fakeReturns := fake.createTaskCacheVolumeReturns
	fake.recordInvocation("CreateTaskCacheVolume", []interface{}{arg1, arg2})
	fake.createTaskCacheVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) CreateTaskCacheVolumeCallCount() int {
	fake.createTaskCacheVolumeMutex.RLock()
	defer fake.createTaskCacheVolumeMutex.RUnlock()
	return len(fake.createTaskCacheVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) CreateTaskCacheVolumeCalls(stub func(int, *db.UsedWorkerTaskCache) (db.CreatingVolume, error)) {
	fake.createTaskCacheVolumeMutex.Lock()
	defer fake.createTaskCacheVolumeMutex.Unlock()
	fake.CreateTaskCacheVolumeStub = stub
}

func (fake *FakeVolumeRepository) CreateTaskCacheVolumeArgsForCall(i int) (int, *db.UsedWorkerTaskCache) {
	fake.createTaskCacheVolumeMutex.RLock()
	defer fake.createTaskCacheVolumeMutex.RUnlock()
	argsForCall := fake.createTaskCacheVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVolumeRepository) CreateTaskCacheVolumeReturns(result1 db.CreatingVolume, result2 error) {
	fake.createTaskCacheVolumeMutex.Lock()
	defer fake.createTaskCacheVolumeMutex.Unlock()
	fake.CreateTaskCacheVolumeStub = nil
	fake.createTaskCacheVolumeReturns = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateTaskCacheVolumeReturnsOnCall(i int, result1 db.CreatingVolume, result2 error) {
	fake.createTaskCacheVolumeMutex.Lock()
	defer fake.createTaskCacheVolumeMutex.Unlock()
	fake.CreateTaskCacheVolumeStub = nil
	if fake.createTaskCacheVolumeReturnsOnCall == nil {
		fake.createTaskCacheVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatingVolume
			result2 error
		})
	}
	fake.createTaskCacheVolumeReturnsOnCall[i] = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateVolume(arg1 int, arg2 string, arg3 db.VolumeType) (db.CreatingVolume, error) {
	fake.createVolumeMutex.Lock()
	ret, specificReturn := fake.createVolumeReturnsOnCall[len(fake.createVolumeArgsForCall)]
	fake.createVolumeArgsForCall = append(fake.createVolumeArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 db.VolumeType
	}{arg1, arg2, arg3})
	stub := fake.CreateVolumeStub
	fakeReturns := fake.createVolumeReturns
	fake.recordInvocation("CreateVolume", []interface{}{arg1, arg2, arg3})
	fake.createVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) CreateVolumeCallCount() int {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return len(fake.createVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) CreateVolumeCalls(stub func(int, string, db.VolumeType) (db.CreatingVolume, error)) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = stub
}

func (fake *FakeVolumeRepository) CreateVolumeArgsForCall(i int) (int, string, db.VolumeType) {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	argsForCall := fake.createVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeVolumeRepository) CreateVolumeReturns(result1 db.CreatingVolume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	fake.createVolumeReturns = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateVolumeReturnsOnCall(i int, result1 db.CreatingVolume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	if fake.createVolumeReturnsOnCall == nil {
		fake.createVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatingVolume
			result2 error
		})
	}
	fake.createVolumeReturnsOnCall[i] = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateVolumeWithHandle(arg1 string, arg2 int, arg3 string, arg4 db.VolumeType) (db.CreatingVolume, error) {
	fake.createVolumeWithHandleMutex.Lock()
	ret, specificReturn := fake.createVolumeWithHandleReturnsOnCall[len(fake.createVolumeWithHandleArgsForCall)]
	fake.createVolumeWithHandleArgsForCall = append(fake.createVolumeWithHandleArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 db.VolumeType
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateVolumeWithHandleStub
	fakeReturns := fake.createVolumeWithHandleReturns
	fake.recordInvocation("CreateVolumeWithHandle", []interface{}{arg1, arg2, arg3, arg4})
	fake.createVolumeWithHandleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) CreateVolumeWithHandleCallCount() int {
	fake.createVolumeWithHandleMutex.RLock()
	defer fake.createVolumeWithHandleMutex.RUnlock()
	return len(fake.createVolumeWithHandleArgsForCall)
}

func (fake *FakeVolumeRepository) CreateVolumeWithHandleCalls(stub func(string, int, string, db.VolumeType) (db.CreatingVolume, error)) {
	fake.createVolumeWithHandleMutex.Lock()
	defer fake.createVolumeWithHandleMutex.Unlock()
	fake.CreateVolumeWithHandleStub = stub
}

func (fake *FakeVolumeRepository) CreateVolumeWithHandleArgsForCall(i int) (string, int, string, db.VolumeType) {
	fake.createVolumeWithHandleMutex.RLock()
	defer fake.createVolumeWithHandleMutex.RUnlock()
	argsForCall := fake.createVolumeWithHandleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeVolumeRepository) CreateVolumeWithHandleReturns(result1 db.CreatingVolume, result2 error) {
	fake.createVolumeWithHandleMutex.Lock()
	defer fake.createVolumeWithHandleMutex.Unlock()
	fake.CreateVolumeWithHandleStub = nil
	fake.createVolumeWithHandleReturns = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) CreateVolumeWithHandleReturnsOnCall(i int, result1 db.CreatingVolume, result2 error) {
	fake.createVolumeWithHandleMutex.Lock()
	defer fake.createVolumeWithHandleMutex.Unlock()
	fake.CreateVolumeWithHandleStub = nil
	if fake.createVolumeWithHandleReturnsOnCall == nil {
		fake.createVolumeWithHandleReturnsOnCall = make(map[int]struct {
			result1 db.CreatingVolume
			result2 error
		})
	}
	fake.createVolumeWithHandleReturnsOnCall[i] = struct {
		result1 db.CreatingVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) DestroyFailedVolumes() (int, error) {
	fake.destroyFailedVolumesMutex.Lock()
	ret, specificReturn := fake.destroyFailedVolumesReturnsOnCall[len(fake.destroyFailedVolumesArgsForCall)]
	fake.destroyFailedVolumesArgsForCall = append(fake.destroyFailedVolumesArgsForCall, struct {
	}{})
	stub := fake.DestroyFailedVolumesStub
	fakeReturns := fake.destroyFailedVolumesReturns
	fake.recordInvocation("DestroyFailedVolumes", []interface{}{})
	fake.destroyFailedVolumesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) DestroyFailedVolumesCallCount() int {
	fake.destroyFailedVolumesMutex.RLock()
	defer fake.destroyFailedVolumesMutex.RUnlock()
	return len(fake.destroyFailedVolumesArgsForCall)
}

func (fake *FakeVolumeRepository) DestroyFailedVolumesCalls(stub func() (int, error)) {
	fake.destroyFailedVolumesMutex.Lock()
	defer fake.destroyFailedVolumesMutex.Unlock()
	fake.DestroyFailedVolumesStub = stub
}

func (fake *FakeVolumeRepository) DestroyFailedVolumesReturns(result1 int, result2 error) {
	fake.destroyFailedVolumesMutex.Lock()
	defer fake.destroyFailedVolumesMutex.Unlock()
	fake.DestroyFailedVolumesStub = nil
	fake.destroyFailedVolumesReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) DestroyFailedVolumesReturnsOnCall(i int, result1 int, result2 error) {
	fake.destroyFailedVolumesMutex.Lock()
	defer fake.destroyFailedVolumesMutex.Unlock()
	fake.DestroyFailedVolumesStub = nil
	if fake.destroyFailedVolumesReturnsOnCall == nil {
		fake.destroyFailedVolumesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.destroyFailedVolumesReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) DestroyUnknownVolumes(arg1 string, arg2 []string) (int, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.destroyUnknownVolumesMutex.Lock()
	ret, specificReturn := fake.destroyUnknownVolumesReturnsOnCall[len(fake.destroyUnknownVolumesArgsForCall)]
	fake.destroyUnknownVolumesArgsForCall = append(fake.destroyUnknownVolumesArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.DestroyUnknownVolumesStub
	fakeReturns := fake.destroyUnknownVolumesReturns
	fake.recordInvocation("DestroyUnknownVolumes", []interface{}{arg1, arg2Copy})
	fake.destroyUnknownVolumesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) DestroyUnknownVolumesCallCount() int {
	fake.destroyUnknownVolumesMutex.RLock()
	defer fake.destroyUnknownVolumesMutex.RUnlock()
	return len(fake.destroyUnknownVolumesArgsForCall)
}

func (fake *FakeVolumeRepository) DestroyUnknownVolumesCalls(stub func(string, []string) (int, error)) {
	fake.destroyUnknownVolumesMutex.Lock()
	defer fake.destroyUnknownVolumesMutex.Unlock()
	fake.DestroyUnknownVolumesStub = stub
}

func (fake *FakeVolumeRepository) DestroyUnknownVolumesArgsForCall(i int) (string, []string) {
	fake.destroyUnknownVolumesMutex.RLock()
	defer fake.destroyUnknownVolumesMutex.RUnlock()
	argsForCall := fake.destroyUnknownVolumesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVolumeRepository) DestroyUnknownVolumesReturns(result1 int, result2 error) {
	fake.destroyUnknownVolumesMutex.Lock()
	defer fake.destroyUnknownVolumesMutex.Unlock()
	fake.DestroyUnknownVolumesStub = nil
	fake.destroyUnknownVolumesReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) DestroyUnknownVolumesReturnsOnCall(i int, result1 int, result2 error) {
	fake.destroyUnknownVolumesMutex.Lock()
	defer fake.destroyUnknownVolumesMutex.Unlock()
	fake.DestroyUnknownVolumesStub = nil
	if fake.destroyUnknownVolumesReturnsOnCall == nil {
		fake.destroyUnknownVolumesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.destroyUnknownVolumesReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) FindBaseResourceTypeVolume(arg1 *db.UsedWorkerBaseResourceType) (db.CreatingVolume, db.CreatedVolume, error) {
	fake.findBaseResourceTypeVolumeMutex.Lock()
	ret, specificReturn := fake.findBaseResourceTypeVolumeReturnsOnCall[len(fake.findBaseResourceTypeVolumeArgsForCall)]
	fake.findBaseResourceTypeVolumeArgsForCall = append(fake.findBaseResourceTypeVolumeArgsForCall, struct {
		arg1 *db.UsedWorkerBaseResourceType
	}{arg1})
	stub := fake.FindBaseResourceTypeVolumeStub
	fakeReturns := fake.findBaseResourceTypeVolumeReturns
	fake.recordInvocation("FindBaseResourceTypeVolume", []interface{}{arg1})
	fake.findBaseResourceTypeVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeVolumeRepository) FindBaseResourceTypeVolumeCallCount() int {
	fake.findBaseResourceTypeVolumeMutex.RLock()
	defer fake.findBaseResourceTypeVolumeMutex.RUnlock()
	return len(fake.findBaseResourceTypeVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) FindBaseResourceTypeVolumeCalls(stub func(*db.UsedWorkerBaseResourceType) (db.CreatingVolume, db.CreatedVolume, error)) {
	fake.findBaseResourceTypeVolumeMutex.Lock()
	defer fake.findBaseResourceTypeVolumeMutex.Unlock()
	fake.FindBaseResourceTypeVolumeStub = stub
}

func (fake *FakeVolumeRepository) FindBaseResourceTypeVolumeArgsForCall(i int) *db.UsedWorkerBaseResourceType {
	fake.findBaseResourceTypeVolumeMutex.RLock()
	defer fake.findBaseResourceTypeVolumeMutex.RUnlock()
	argsForCall := fake.findBaseResourceTypeVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVolumeRepository) FindBaseResourceTypeVolumeReturns(result1 db.CreatingVolume, result2 db.CreatedVolume, result3 error) {
	fake.findBaseResourceTypeVolumeMutex.Lock()
	defer fake.findBaseResourceTypeVolumeMutex.Unlock()
	fake.FindBaseResourceTypeVolumeStub = nil
	fake.findBaseResourceTypeVolumeReturns = struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindBaseResourceTypeVolumeReturnsOnCall(i int, result1 db.CreatingVolume, result2 db.CreatedVolume, result3 error) {
	fake.findBaseResourceTypeVolumeMutex.Lock()
	defer fake.findBaseResourceTypeVolumeMutex.Unlock()
	fake.FindBaseResourceTypeVolumeStub = nil
	if fake.findBaseResourceTypeVolumeReturnsOnCall == nil {
		fake.findBaseResourceTypeVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatingVolume
			result2 db.CreatedVolume
			result3 error
		})
	}
	fake.findBaseResourceTypeVolumeReturnsOnCall[i] = struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindContainerVolume(arg1 int, arg2 string, arg3 db.CreatingContainer, arg4 string) (db.CreatingVolume, db.CreatedVolume, error) {
	fake.findContainerVolumeMutex.Lock()
	ret, specificReturn := fake.findContainerVolumeReturnsOnCall[len(fake.findContainerVolumeArgsForCall)]
	fake.findContainerVolumeArgsForCall = append(fake.findContainerVolumeArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 db.CreatingContainer
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.FindContainerVolumeStub
	fakeReturns := fake.findContainerVolumeReturns
	fake.recordInvocation("FindContainerVolume", []interface{}{arg1, arg2, arg3, arg4})
	fake.findContainerVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeVolumeRepository) FindContainerVolumeCallCount() int {
	fake.findContainerVolumeMutex.RLock()
	defer fake.findContainerVolumeMutex.RUnlock()
	return len(fake.findContainerVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) FindContainerVolumeCalls(stub func(int, string, db.CreatingContainer, string) (db.CreatingVolume, db.CreatedVolume, error)) {
	fake.findContainerVolumeMutex.Lock()
	defer fake.findContainerVolumeMutex.Unlock()
	fake.FindContainerVolumeStub = stub
}

func (fake *FakeVolumeRepository) FindContainerVolumeArgsForCall(i int) (int, string, db.CreatingContainer, string) {
	fake.findContainerVolumeMutex.RLock()
	defer fake.findContainerVolumeMutex.RUnlock()
	argsForCall := fake.findContainerVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeVolumeRepository) FindContainerVolumeReturns(result1 db.CreatingVolume, result2 db.CreatedVolume, result3 error) {
	fake.findContainerVolumeMutex.Lock()
	defer fake.findContainerVolumeMutex.Unlock()
	fake.FindContainerVolumeStub = nil
	fake.findContainerVolumeReturns = struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindContainerVolumeReturnsOnCall(i int, result1 db.CreatingVolume, result2 db.CreatedVolume, result3 error) {
	fake.findContainerVolumeMutex.Lock()
	defer fake.findContainerVolumeMutex.Unlock()
	fake.FindContainerVolumeStub = nil
	if fake.findContainerVolumeReturnsOnCall == nil {
		fake.findContainerVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatingVolume
			result2 db.CreatedVolume
			result3 error
		})
	}
	fake.findContainerVolumeReturnsOnCall[i] = struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindResourceCacheVolume(arg1 string, arg2 db.ResourceCache, arg3 time.Time) (db.CreatedVolume, bool, error) {
	fake.findResourceCacheVolumeMutex.Lock()
	ret, specificReturn := fake.findResourceCacheVolumeReturnsOnCall[len(fake.findResourceCacheVolumeArgsForCall)]
	fake.findResourceCacheVolumeArgsForCall = append(fake.findResourceCacheVolumeArgsForCall, struct {
		arg1 string
		arg2 db.ResourceCache
		arg3 time.Time
	}{arg1, arg2, arg3})
	stub := fake.FindResourceCacheVolumeStub
	fakeReturns := fake.findResourceCacheVolumeReturns
	fake.recordInvocation("FindResourceCacheVolume", []interface{}{arg1, arg2, arg3})
	fake.findResourceCacheVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeVolumeRepository) FindResourceCacheVolumeCallCount() int {
	fake.findResourceCacheVolumeMutex.RLock()
	defer fake.findResourceCacheVolumeMutex.RUnlock()
	return len(fake.findResourceCacheVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) FindResourceCacheVolumeCalls(stub func(string, db.ResourceCache, time.Time) (db.CreatedVolume, bool, error)) {
	fake.findResourceCacheVolumeMutex.Lock()
	defer fake.findResourceCacheVolumeMutex.Unlock()
	fake.FindResourceCacheVolumeStub = stub
}

func (fake *FakeVolumeRepository) FindResourceCacheVolumeArgsForCall(i int) (string, db.ResourceCache, time.Time) {
	fake.findResourceCacheVolumeMutex.RLock()
	defer fake.findResourceCacheVolumeMutex.RUnlock()
	argsForCall := fake.findResourceCacheVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeVolumeRepository) FindResourceCacheVolumeReturns(result1 db.CreatedVolume, result2 bool, result3 error) {
	fake.findResourceCacheVolumeMutex.Lock()
	defer fake.findResourceCacheVolumeMutex.Unlock()
	fake.FindResourceCacheVolumeStub = nil
	fake.findResourceCacheVolumeReturns = struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindResourceCacheVolumeReturnsOnCall(i int, result1 db.CreatedVolume, result2 bool, result3 error) {
	fake.findResourceCacheVolumeMutex.Lock()
	defer fake.findResourceCacheVolumeMutex.Unlock()
	fake.FindResourceCacheVolumeStub = nil
	if fake.findResourceCacheVolumeReturnsOnCall == nil {
		fake.findResourceCacheVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatedVolume
			result2 bool
			result3 error
		})
	}
	fake.findResourceCacheVolumeReturnsOnCall[i] = struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindResourceCertsVolume(arg1 string, arg2 *db.UsedWorkerResourceCerts) (db.CreatingVolume, db.CreatedVolume, error) {
	fake.findResourceCertsVolumeMutex.Lock()
	ret, specificReturn := fake.findResourceCertsVolumeReturnsOnCall[len(fake.findResourceCertsVolumeArgsForCall)]
	fake.findResourceCertsVolumeArgsForCall = append(fake.findResourceCertsVolumeArgsForCall, struct {
		arg1 string
		arg2 *db.UsedWorkerResourceCerts
	}{arg1, arg2})
	stub := fake.FindResourceCertsVolumeStub
	fakeReturns := fake.findResourceCertsVolumeReturns
	fake.recordInvocation("FindResourceCertsVolume", []interface{}{arg1, arg2})
	fake.findResourceCertsVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeVolumeRepository) FindResourceCertsVolumeCallCount() int {
	fake.findResourceCertsVolumeMutex.RLock()
	defer fake.findResourceCertsVolumeMutex.RUnlock()
	return len(fake.findResourceCertsVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) FindResourceCertsVolumeCalls(stub func(string, *db.UsedWorkerResourceCerts) (db.CreatingVolume, db.CreatedVolume, error)) {
	fake.findResourceCertsVolumeMutex.Lock()
	defer fake.findResourceCertsVolumeMutex.Unlock()
	fake.FindResourceCertsVolumeStub = stub
}

func (fake *FakeVolumeRepository) FindResourceCertsVolumeArgsForCall(i int) (string, *db.UsedWorkerResourceCerts) {
	fake.findResourceCertsVolumeMutex.RLock()
	defer fake.findResourceCertsVolumeMutex.RUnlock()
	argsForCall := fake.findResourceCertsVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVolumeRepository) FindResourceCertsVolumeReturns(result1 db.CreatingVolume, result2 db.CreatedVolume, result3 error) {
	fake.findResourceCertsVolumeMutex.Lock()
	defer fake.findResourceCertsVolumeMutex.Unlock()
	fake.FindResourceCertsVolumeStub = nil
	fake.findResourceCertsVolumeReturns = struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindResourceCertsVolumeReturnsOnCall(i int, result1 db.CreatingVolume, result2 db.CreatedVolume, result3 error) {
	fake.findResourceCertsVolumeMutex.Lock()
	defer fake.findResourceCertsVolumeMutex.Unlock()
	fake.FindResourceCertsVolumeStub = nil
	if fake.findResourceCertsVolumeReturnsOnCall == nil {
		fake.findResourceCertsVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatingVolume
			result2 db.CreatedVolume
			result3 error
		})
	}
	fake.findResourceCertsVolumeReturnsOnCall[i] = struct {
		result1 db.CreatingVolume
		result2 db.CreatedVolume
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindTaskCacheVolume(arg1 int, arg2 string, arg3 db.UsedTaskCache) (db.CreatedVolume, bool, error) {
	fake.findTaskCacheVolumeMutex.Lock()
	ret, specificReturn := fake.findTaskCacheVolumeReturnsOnCall[len(fake.findTaskCacheVolumeArgsForCall)]
	fake.findTaskCacheVolumeArgsForCall = append(fake.findTaskCacheVolumeArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 db.UsedTaskCache
	}{arg1, arg2, arg3})
	stub := fake.FindTaskCacheVolumeStub
	fakeReturns := fake.findTaskCacheVolumeReturns
	fake.recordInvocation("FindTaskCacheVolume", []interface{}{arg1, arg2, arg3})
	fake.findTaskCacheVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeVolumeRepository) FindTaskCacheVolumeCallCount() int {
	fake.findTaskCacheVolumeMutex.RLock()
	defer fake.findTaskCacheVolumeMutex.RUnlock()
	return len(fake.findTaskCacheVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) FindTaskCacheVolumeCalls(stub func(int, string, db.UsedTaskCache) (db.CreatedVolume, bool, error)) {
	fake.findTaskCacheVolumeMutex.Lock()
	defer fake.findTaskCacheVolumeMutex.Unlock()
	fake.FindTaskCacheVolumeStub = stub
}

func (fake *FakeVolumeRepository) FindTaskCacheVolumeArgsForCall(i int) (int, string, db.UsedTaskCache) {
	fake.findTaskCacheVolumeMutex.RLock()
	defer fake.findTaskCacheVolumeMutex.RUnlock()
	argsForCall := fake.findTaskCacheVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeVolumeRepository) FindTaskCacheVolumeReturns(result1 db.CreatedVolume, result2 bool, result3 error) {
	fake.findTaskCacheVolumeMutex.Lock()
	defer fake.findTaskCacheVolumeMutex.Unlock()
	fake.FindTaskCacheVolumeStub = nil
	fake.findTaskCacheVolumeReturns = struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindTaskCacheVolumeReturnsOnCall(i int, result1 db.CreatedVolume, result2 bool, result3 error) {
	fake.findTaskCacheVolumeMutex.Lock()
	defer fake.findTaskCacheVolumeMutex.Unlock()
	fake.FindTaskCacheVolumeStub = nil
	if fake.findTaskCacheVolumeReturnsOnCall == nil {
		fake.findTaskCacheVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatedVolume
			result2 bool
			result3 error
		})
	}
	fake.findTaskCacheVolumeReturnsOnCall[i] = struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindVolume(arg1 string) (db.CreatedVolume, bool, error) {
	fake.findVolumeMutex.Lock()
	ret, specificReturn := fake.findVolumeReturnsOnCall[len(fake.findVolumeArgsForCall)]
	fake.findVolumeArgsForCall = append(fake.findVolumeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindVolumeStub
	fakeReturns := fake.findVolumeReturns
	fake.recordInvocation("FindVolume", []interface{}{arg1})
	fake.findVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeVolumeRepository) FindVolumeCallCount() int {
	fake.findVolumeMutex.RLock()
	defer fake.findVolumeMutex.RUnlock()
	return len(fake.findVolumeArgsForCall)
}

func (fake *FakeVolumeRepository) FindVolumeCalls(stub func(string) (db.CreatedVolume, bool, error)) {
	fake.findVolumeMutex.Lock()
	defer fake.findVolumeMutex.Unlock()
	fake.FindVolumeStub = stub
}

func (fake *FakeVolumeRepository) FindVolumeArgsForCall(i int) string {
	fake.findVolumeMutex.RLock()
	defer fake.findVolumeMutex.RUnlock()
	argsForCall := fake.findVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVolumeRepository) FindVolumeReturns(result1 db.CreatedVolume, result2 bool, result3 error) {
	fake.findVolumeMutex.Lock()
	defer fake.findVolumeMutex.Unlock()
	fake.FindVolumeStub = nil
	fake.findVolumeReturns = struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindVolumeReturnsOnCall(i int, result1 db.CreatedVolume, result2 bool, result3 error) {
	fake.findVolumeMutex.Lock()
	defer fake.findVolumeMutex.Unlock()
	fake.FindVolumeStub = nil
	if fake.findVolumeReturnsOnCall == nil {
		fake.findVolumeReturnsOnCall = make(map[int]struct {
			result1 db.CreatedVolume
			result2 bool
			result3 error
		})
	}
	fake.findVolumeReturnsOnCall[i] = struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeVolumeRepository) FindVolumesForContainer(arg1 db.CreatedContainer) ([]db.CreatedVolume, error) {
	fake.findVolumesForContainerMutex.Lock()
	ret, specificReturn := fake.findVolumesForContainerReturnsOnCall[len(fake.findVolumesForContainerArgsForCall)]
	fake.findVolumesForContainerArgsForCall = append(fake.findVolumesForContainerArgsForCall, struct {
		arg1 db.CreatedContainer
	}{arg1})
	stub := fake.FindVolumesForContainerStub
	fakeReturns := fake.findVolumesForContainerReturns
	fake.recordInvocation("FindVolumesForContainer", []interface{}{arg1})
	fake.findVolumesForContainerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) FindVolumesForContainerCallCount() int {
	fake.findVolumesForContainerMutex.RLock()
	defer fake.findVolumesForContainerMutex.RUnlock()
	return len(fake.findVolumesForContainerArgsForCall)
}

func (fake *FakeVolumeRepository) FindVolumesForContainerCalls(stub func(db.CreatedContainer) ([]db.CreatedVolume, error)) {
	fake.findVolumesForContainerMutex.Lock()
	defer fake.findVolumesForContainerMutex.Unlock()
	fake.FindVolumesForContainerStub = stub
}

func (fake *FakeVolumeRepository) FindVolumesForContainerArgsForCall(i int) db.CreatedContainer {
	fake.findVolumesForContainerMutex.RLock()
	defer fake.findVolumesForContainerMutex.RUnlock()
	argsForCall := fake.findVolumesForContainerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVolumeRepository) FindVolumesForContainerReturns(result1 []db.CreatedVolume, result2 error) {
	fake.findVolumesForContainerMutex.Lock()
	defer fake.findVolumesForContainerMutex.Unlock()
	fake.FindVolumesForContainerStub = nil
	fake.findVolumesForContainerReturns = struct {
		result1 []db.CreatedVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) FindVolumesForContainerReturnsOnCall(i int, result1 []db.CreatedVolume, result2 error) {
	fake.findVolumesForContainerMutex.Lock()
	defer fake.findVolumesForContainerMutex.Unlock()
	fake.FindVolumesForContainerStub = nil
	if fake.findVolumesForContainerReturnsOnCall == nil {
		fake.findVolumesForContainerReturnsOnCall = make(map[int]struct {
			result1 []db.CreatedVolume
			result2 error
		})
	}
	fake.findVolumesForContainerReturnsOnCall[i] = struct {
		result1 []db.CreatedVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) FindWorkersForResourceCache(arg1 db.ResourceCache) ([]string, error) {
	fake.findWorkersForResourceCacheMutex.Lock()
	ret, specificReturn := fake.findWorkersForResourceCacheReturnsOnCall[len(fake.findWorkersForResourceCacheArgsForCall)]
	fake.findWorkersForResourceCacheArgsForCall = append(fake.findWorkersForResourceCacheArgsForCall, struct {
		arg1 db.ResourceCache
	}{arg1})
	stub := fake.FindWorkersForResourceCacheStub
	fakeReturns := fake.findWorkersForResourceCacheReturns
	fake.recordInvocation("FindWorkersForResourceCache", []interface{}{arg1})
	fake.findWorkersForResourceCacheMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) FindWorkersForResourceCacheCallCount() int {
	fake.findWorkersForResourceCacheMutex.RLock()
	defer fake.findWorkersForResourceCacheMutex.RUnlock()
	return len(fake.findWorkersForResourceCacheArgsForCall)
}

func (fake *FakeVolumeRepository) FindWorkersForResourceCacheCalls(stub func(db.ResourceCache) ([]string, error)) {
	fake.findWorkersForResourceCacheMutex.Lock()
	defer fake.findWorkersForResourceCacheMutex.Unlock()
	fake.FindWorkersForResourceCacheStub = stub
}

func (fake *FakeVolumeRepository) FindWorkersForResourceCacheArgsForCall(i int) db.ResourceCache {
	fake.findWorkersForResourceCacheMutex.RLock()
	defer fake.findWorkersForResourceCacheMutex.RUnlock()
	argsForCall := fake.findWorkersForResourceCacheArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVolumeRepository) FindWorkersForResourceCacheReturns(result1 []string, result2 error) {
	fake.findWorkersForResourceCacheMutex.Lock()
	defer fake.findWorkersForResourceCacheMutex.Unlock()
	fake.FindWorkersForResourceCacheStub = nil
	fake.findWorkersForResourceCacheReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) FindWorkersForResourceCacheReturnsOnCall(i int, result1 []string, result2 error) {
	fake.findWorkersForResourceCacheMutex.Lock()
	defer fake.findWorkersForResourceCacheMutex.Unlock()
	fake.FindWorkersForResourceCacheStub = nil
	if fake.findWorkersForResourceCacheReturnsOnCall == nil {
		fake.findWorkersForResourceCacheReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.findWorkersForResourceCacheReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) FindWorkersForTaskCache(arg1 db.UsedTaskCache) ([]string, error) {
	fake.findWorkersForTaskCacheMutex.Lock()
	ret, specificReturn := fake.findWorkersForTaskCacheReturnsOnCall[len(fake.findWorkersForTaskCacheArgsForCall)]
	fake.findWorkersForTaskCacheArgsForCall = append(fake.findWorkersForTaskCacheArgsForCall, struct {
		arg1 db.UsedTaskCache
	}{arg1})
	stub := fake.FindWorkersForTaskCacheStub
	fakeReturns := fake.findWorkersForTaskCacheReturns
	fake.recordInvocation("FindWorkersForTaskCache", []interface{}{arg1})
	fake.findWorkersForTaskCacheMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) FindWorkersForTaskCacheCallCount() int {
	fake.findWorkersForTaskCacheMutex.RLock()
	defer fake.findWorkersForTaskCacheMutex.RUnlock()
	return len(fake.findWorkersForTaskCacheArgsForCall)
}

func (fake *FakeVolumeRepository) FindWorkersForTaskCacheCalls(stub func(db.UsedTaskCache) ([]string, error)) {
	fake.findWorkersForTaskCacheMutex.Lock()
	defer fake.findWorkersForTaskCacheMutex.Unlock()
	fake.FindWorkersForTaskCacheStub = stub
}

func (fake *FakeVolumeRepository) FindWorkersForTaskCacheArgsForCall(i int) db.UsedTaskCache {
	fake.findWorkersForTaskCacheMutex.RLock()
	defer fake.findWorkersForTaskCacheMutex.RUnlock()
	argsForCall := fake.findWorkersForTaskCacheArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVolumeRepository) FindWorkersForTaskCacheReturns(result1 []string, result2 error) {
	fake.findWorkersForTaskCacheMutex.Lock()
	defer fake.findWorkersForTaskCacheMutex.Unlock()
	fake.FindWorkersForTaskCacheStub = nil
	fake.findWorkersForTaskCacheReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) FindWorkersForTaskCacheReturnsOnCall(i int, result1 []string, result2 error) {
	fake.findWorkersForTaskCacheMutex.Lock()
	defer fake.findWorkersForTaskCacheMutex.Unlock()
	fake.FindWorkersForTaskCacheStub = nil
	if fake.findWorkersForTaskCacheReturnsOnCall == nil {
		fake.findWorkersForTaskCacheReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.findWorkersForTaskCacheReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) GetDestroyingVolumes(arg1 string) ([]string, error) {
	fake.getDestroyingVolumesMutex.Lock()
	ret, specificReturn := fake.getDestroyingVolumesReturnsOnCall[len(fake.getDestroyingVolumesArgsForCall)]
	fake.getDestroyingVolumesArgsForCall = append(fake.getDestroyingVolumesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetDestroyingVolumesStub
	fakeReturns := fake.getDestroyingVolumesReturns
	fake.recordInvocation("GetDestroyingVolumes", []interface{}{arg1})
	fake.getDestroyingVolumesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) GetDestroyingVolumesCallCount() int {
	fake.getDestroyingVolumesMutex.RLock()
	defer fake.getDestroyingVolumesMutex.RUnlock()
	return len(fake.getDestroyingVolumesArgsForCall)
}

func (fake *FakeVolumeRepository) GetDestroyingVolumesCalls(stub func(string) ([]string, error)) {
	fake.getDestroyingVolumesMutex.Lock()
	defer fake.getDestroyingVolumesMutex.Unlock()
	fake.GetDestroyingVolumesStub = stub
}

func (fake *FakeVolumeRepository) GetDestroyingVolumesArgsForCall(i int) string {
	fake.getDestroyingVolumesMutex.RLock()
	defer fake.getDestroyingVolumesMutex.RUnlock()
	argsForCall := fake.getDestroyingVolumesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVolumeRepository) GetDestroyingVolumesReturns(result1 []string, result2 error) {
	fake.getDestroyingVolumesMutex.Lock()
	defer fake.getDestroyingVolumesMutex.Unlock()
	fake.GetDestroyingVolumesStub = nil
	fake.getDestroyingVolumesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) GetDestroyingVolumesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getDestroyingVolumesMutex.Lock()
	defer fake.getDestroyingVolumesMutex.Unlock()
	fake.GetDestroyingVolumesStub = nil
	if fake.getDestroyingVolumesReturnsOnCall == nil {
		fake.getDestroyingVolumesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getDestroyingVolumesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) GetOrphanedVolumes() ([]db.CreatedVolume, error) {
	fake.getOrphanedVolumesMutex.Lock()
	ret, specificReturn := fake.getOrphanedVolumesReturnsOnCall[len(fake.getOrphanedVolumesArgsForCall)]
	fake.getOrphanedVolumesArgsForCall = append(fake.getOrphanedVolumesArgsForCall, struct {
	}{})
	stub := fake.GetOrphanedVolumesStub
	fakeReturns := fake.getOrphanedVolumesReturns
	fake.recordInvocation("GetOrphanedVolumes", []interface{}{})
	fake.getOrphanedVolumesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) GetOrphanedVolumesCallCount() int {
	fake.getOrphanedVolumesMutex.RLock()
	defer fake.getOrphanedVolumesMutex.RUnlock()
	return len(fake.getOrphanedVolumesArgsForCall)
}

func (fake *FakeVolumeRepository) GetOrphanedVolumesCalls(stub func() ([]db.CreatedVolume, error)) {
	fake.getOrphanedVolumesMutex.Lock()
	defer fake.getOrphanedVolumesMutex.Unlock()
	fake.GetOrphanedVolumesStub = stub
}

func (fake *FakeVolumeRepository) GetOrphanedVolumesReturns(result1 []db.CreatedVolume, result2 error) {
	fake.getOrphanedVolumesMutex.Lock()
	defer fake.getOrphanedVolumesMutex.Unlock()
	fake.GetOrphanedVolumesStub = nil
	fake.getOrphanedVolumesReturns = struct {
		result1 []db.CreatedVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) GetOrphanedVolumesReturnsOnCall(i int, result1 []db.CreatedVolume, result2 error) {
	fake.getOrphanedVolumesMutex.Lock()
	defer fake.getOrphanedVolumesMutex.Unlock()
	fake.GetOrphanedVolumesStub = nil
	if fake.getOrphanedVolumesReturnsOnCall == nil {
		fake.getOrphanedVolumesReturnsOnCall = make(map[int]struct {
			result1 []db.CreatedVolume
			result2 error
		})
	}
	fake.getOrphanedVolumesReturnsOnCall[i] = struct {
		result1 []db.CreatedVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) GetTeamVolumes(arg1 int) ([]db.CreatedVolume, error) {
	fake.getTeamVolumesMutex.Lock()
	ret, specificReturn := fake.getTeamVolumesReturnsOnCall[len(fake.getTeamVolumesArgsForCall)]
	fake.getTeamVolumesArgsForCall = append(fake.getTeamVolumesArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GetTeamVolumesStub
	fakeReturns := fake.getTeamVolumesReturns
	fake.recordInvocation("GetTeamVolumes", []interface{}{arg1})
	fake.getTeamVolumesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) GetTeamVolumesCallCount() int {
	fake.getTeamVolumesMutex.RLock()
	defer fake.getTeamVolumesMutex.RUnlock()
	return len(fake.getTeamVolumesArgsForCall)
}

func (fake *FakeVolumeRepository) GetTeamVolumesCalls(stub func(int) ([]db.CreatedVolume, error)) {
	fake.getTeamVolumesMutex.Lock()
	defer fake.getTeamVolumesMutex.Unlock()
	fake.GetTeamVolumesStub = stub
}

func (fake *FakeVolumeRepository) GetTeamVolumesArgsForCall(i int) int {
	fake.getTeamVolumesMutex.RLock()
	defer fake.getTeamVolumesMutex.RUnlock()
	argsForCall := fake.getTeamVolumesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVolumeRepository) GetTeamVolumesReturns(result1 []db.CreatedVolume, result2 error) {
	fake.getTeamVolumesMutex.Lock()
	defer fake.getTeamVolumesMutex.Unlock()
	fake.GetTeamVolumesStub = nil
	fake.getTeamVolumesReturns = struct {
		result1 []db.CreatedVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) GetTeamVolumesReturnsOnCall(i int, result1 []db.CreatedVolume, result2 error) {
	fake.getTeamVolumesMutex.Lock()
	defer fake.getTeamVolumesMutex.Unlock()
	fake.GetTeamVolumesStub = nil
	if fake.getTeamVolumesReturnsOnCall == nil {
		fake.getTeamVolumesReturnsOnCall = make(map[int]struct {
			result1 []db.CreatedVolume
			result2 error
		})
	}
	fake.getTeamVolumesReturnsOnCall[i] = struct {
		result1 []db.CreatedVolume
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) RemoveDestroyingVolumes(arg1 string, arg2 []string) (int, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.removeDestroyingVolumesMutex.Lock()
	ret, specificReturn := fake.removeDestroyingVolumesReturnsOnCall[len(fake.removeDestroyingVolumesArgsForCall)]
	fake.removeDestroyingVolumesArgsForCall = append(fake.removeDestroyingVolumesArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.RemoveDestroyingVolumesStub
	fakeReturns := fake.removeDestroyingVolumesReturns
	fake.recordInvocation("RemoveDestroyingVolumes", []interface{}{arg1, arg2Copy})
	fake.removeDestroyingVolumesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) RemoveDestroyingVolumesCallCount() int {
	fake.removeDestroyingVolumesMutex.RLock()
	defer fake.removeDestroyingVolumesMutex.RUnlock()
	return len(fake.removeDestroyingVolumesArgsForCall)
}

func (fake *FakeVolumeRepository) RemoveDestroyingVolumesCalls(stub func(string, []string) (int, error)) {
	fake.removeDestroyingVolumesMutex.Lock()
	defer fake.removeDestroyingVolumesMutex.Unlock()
	fake.RemoveDestroyingVolumesStub = stub
}

func (fake *FakeVolumeRepository) RemoveDestroyingVolumesArgsForCall(i int) (string, []string) {
	fake.removeDestroyingVolumesMutex.RLock()
	defer fake.removeDestroyingVolumesMutex.RUnlock()
	argsForCall := fake.removeDestroyingVolumesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVolumeRepository) RemoveDestroyingVolumesReturns(result1 int, result2 error) {
	fake.removeDestroyingVolumesMutex.Lock()
	defer fake.removeDestroyingVolumesMutex.Unlock()
	fake.RemoveDestroyingVolumesStub = nil
	fake.removeDestroyingVolumesReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) RemoveDestroyingVolumesReturnsOnCall(i int, result1 int, result2 error) {
	fake.removeDestroyingVolumesMutex.Lock()
	defer fake.removeDestroyingVolumesMutex.Unlock()
	fake.RemoveDestroyingVolumesStub = nil
	if fake.removeDestroyingVolumesReturnsOnCall == nil {
		fake.removeDestroyingVolumesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.removeDestroyingVolumesReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) RemoveMissingVolumes(arg1 time.Duration) (int, error) {
	fake.removeMissingVolumesMutex.Lock()
	ret, specificReturn := fake.removeMissingVolumesReturnsOnCall[len(fake.removeMissingVolumesArgsForCall)]
	fake.removeMissingVolumesArgsForCall = append(fake.removeMissingVolumesArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	stub := fake.RemoveMissingVolumesStub
	fakeReturns := fake.removeMissingVolumesReturns
	fake.recordInvocation("RemoveMissingVolumes", []interface{}{arg1})
	fake.removeMissingVolumesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVolumeRepository) RemoveMissingVolumesCallCount() int {
	fake.removeMissingVolumesMutex.RLock()
	defer fake.removeMissingVolumesMutex.RUnlock()
	return len(fake.removeMissingVolumesArgsForCall)
}

func (fake *FakeVolumeRepository) RemoveMissingVolumesCalls(stub func(time.Duration) (int, error)) {
	fake.removeMissingVolumesMutex.Lock()
	defer fake.removeMissingVolumesMutex.Unlock()
	fake.RemoveMissingVolumesStub = stub
}

func (fake *FakeVolumeRepository) RemoveMissingVolumesArgsForCall(i int) time.Duration {
	fake.removeMissingVolumesMutex.RLock()
	defer fake.removeMissingVolumesMutex.RUnlock()
	argsForCall := fake.removeMissingVolumesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeVolumeRepository) RemoveMissingVolumesReturns(result1 int, result2 error) {
	fake.removeMissingVolumesMutex.Lock()
	defer fake.removeMissingVolumesMutex.Unlock()
	fake.RemoveMissingVolumesStub = nil
	fake.removeMissingVolumesReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) RemoveMissingVolumesReturnsOnCall(i int, result1 int, result2 error) {
	fake.removeMissingVolumesMutex.Lock()
	defer fake.removeMissingVolumesMutex.Unlock()
	fake.RemoveMissingVolumesStub = nil
	if fake.removeMissingVolumesReturnsOnCall == nil {
		fake.removeMissingVolumesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.removeMissingVolumesReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeVolumeRepository) UpdateVolumesMissingSince(arg1 string, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.updateVolumesMissingSinceMutex.Lock()
	ret, specificReturn := fake.updateVolumesMissingSinceReturnsOnCall[len(fake.updateVolumesMissingSinceArgsForCall)]
	fake.updateVolumesMissingSinceArgsForCall = append(fake.updateVolumesMissingSinceArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.UpdateVolumesMissingSinceStub
	fakeReturns := fake.updateVolumesMissingSinceReturns
	fake.recordInvocation("UpdateVolumesMissingSince", []interface{}{arg1, arg2Copy})
	fake.updateVolumesMissingSinceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeVolumeRepository) UpdateVolumesMissingSinceCallCount() int {
	fake.updateVolumesMissingSinceMutex.RLock()
	defer fake.updateVolumesMissingSinceMutex.RUnlock()
	return len(fake.updateVolumesMissingSinceArgsForCall)
}

func (fake *FakeVolumeRepository) UpdateVolumesMissingSinceCalls(stub func(string, []string) error) {
	fake.updateVolumesMissingSinceMutex.Lock()
	defer fake.updateVolumesMissingSinceMutex.Unlock()
	fake.UpdateVolumesMissingSinceStub = stub
}

func (fake *FakeVolumeRepository) UpdateVolumesMissingSinceArgsForCall(i int) (string, []string) {
	fake.updateVolumesMissingSinceMutex.RLock()
	defer fake.updateVolumesMissingSinceMutex.RUnlock()
	argsForCall := fake.updateVolumesMissingSinceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVolumeRepository) UpdateVolumesMissingSinceReturns(result1 error) {
	fake.updateVolumesMissingSinceMutex.Lock()
	defer fake.updateVolumesMissingSinceMutex.Unlock()
	fake.UpdateVolumesMissingSinceStub = nil
	fake.updateVolumesMissingSinceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVolumeRepository) UpdateVolumesMissingSinceReturnsOnCall(i int, result1 error) {
	fake.updateVolumesMissingSinceMutex.Lock()
	defer fake.updateVolumesMissingSinceMutex.Unlock()
	fake.UpdateVolumesMissingSinceStub = nil
	if fake.updateVolumesMissingSinceReturnsOnCall == nil {
		fake.updateVolumesMissingSinceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateVolumesMissingSinceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVolumeRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createBaseResourceTypeVolumeMutex.RLock()
	defer fake.createBaseResourceTypeVolumeMutex.RUnlock()
	fake.createContainerVolumeMutex.RLock()
	defer fake.createContainerVolumeMutex.RUnlock()
	fake.createResourceCertsVolumeMutex.RLock()
	defer fake.createResourceCertsVolumeMutex.RUnlock()
	fake.createTaskCacheVolumeMutex.RLock()
	defer fake.createTaskCacheVolumeMutex.RUnlock()
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	fake.createVolumeWithHandleMutex.RLock()
	defer fake.createVolumeWithHandleMutex.RUnlock()
	fake.destroyFailedVolumesMutex.RLock()
	defer fake.destroyFailedVolumesMutex.RUnlock()
	fake.destroyUnknownVolumesMutex.RLock()
	defer fake.destroyUnknownVolumesMutex.RUnlock()
	fake.findBaseResourceTypeVolumeMutex.RLock()
	defer fake.findBaseResourceTypeVolumeMutex.RUnlock()
	fake.findContainerVolumeMutex.RLock()
	defer fake.findContainerVolumeMutex.RUnlock()
	fake.findResourceCacheVolumeMutex.RLock()
	defer fake.findResourceCacheVolumeMutex.RUnlock()
	fake.findResourceCertsVolumeMutex.RLock()
	defer fake.findResourceCertsVolumeMutex.RUnlock()
	fake.findTaskCacheVolumeMutex.RLock()
	defer fake.findTaskCacheVolumeMutex.RUnlock()
	fake.findVolumeMutex.RLock()
	defer fake.findVolumeMutex.RUnlock()
	fake.findVolumesForContainerMutex.RLock()
	defer fake.findVolumesForContainerMutex.RUnlock()
	fake.findWorkersForResourceCacheMutex.RLock()
	defer fake.findWorkersForResourceCacheMutex.RUnlock()
	fake.findWorkersForTaskCacheMutex.RLock()
	defer fake.findWorkersForTaskCacheMutex.RUnlock()
	fake.getDestroyingVolumesMutex.RLock()
	defer fake.getDestroyingVolumesMutex.RUnlock()
	fake.getOrphanedVolumesMutex.RLock()
	defer fake.getOrphanedVolumesMutex.RUnlock()
	fake.getTeamVolumesMutex.RLock()
	defer fake.getTeamVolumesMutex.RUnlock()
	fake.removeDestroyingVolumesMutex.RLock()
	defer fake.removeDestroyingVolumesMutex.RUnlock()
	fake.removeMissingVolumesMutex.RLock()
	defer fake.removeMissingVolumesMutex.RUnlock()
	fake.updateVolumesMissingSinceMutex.RLock()
	defer fake.updateVolumesMissingSinceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeVolumeRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.VolumeRepository = new(FakeVolumeRepository)
