// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/creds"
	"github.com/concourse/concourse/atc/db"
)

type FakeTeam struct {
	AdminStub        func() bool
	adminMutex       sync.RWMutex
	adminArgsForCall []struct {
	}
	adminReturns struct {
		result1 bool
	}
	adminReturnsOnCall map[int]struct {
		result1 bool
	}
	AuthStub        func() atc.TeamAuth
	authMutex       sync.RWMutex
	authArgsForCall []struct {
	}
	authReturns struct {
		result1 atc.TeamAuth
	}
	authReturnsOnCall map[int]struct {
		result1 atc.TeamAuth
	}
	BuildsStub        func(db.Page) ([]db.Build, db.Pagination, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		arg1 db.Page
	}
	buildsReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	BuildsWithTimeStub        func(db.Page) ([]db.Build, db.Pagination, error)
	buildsWithTimeMutex       sync.RWMutex
	buildsWithTimeArgsForCall []struct {
		arg1 db.Page
	}
	buildsWithTimeReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsWithTimeReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	ContainersStub        func() ([]db.Container, error)
	containersMutex       sync.RWMutex
	containersArgsForCall []struct {
	}
	containersReturns struct {
		result1 []db.Container
		result2 error
	}
	containersReturnsOnCall map[int]struct {
		result1 []db.Container
		result2 error
	}
	CreateOneOffBuildStub        func() (db.Build, error)
	createOneOffBuildMutex       sync.RWMutex
	createOneOffBuildArgsForCall []struct {
	}
	createOneOffBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createOneOffBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	CreateStartedBuildStub        func(atc.Plan) (db.Build, error)
	createStartedBuildMutex       sync.RWMutex
	createStartedBuildArgsForCall []struct {
		arg1 atc.Plan
	}
	createStartedBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createStartedBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	DeleteStub        func() error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	FindCheckContainersStub        func(string, string, creds.Secrets) ([]db.Container, map[int]time.Time, error)
	findCheckContainersMutex       sync.RWMutex
	findCheckContainersArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 creds.Secrets
	}
	findCheckContainersReturns struct {
		result1 []db.Container
		result2 map[int]time.Time
		result3 error
	}
	findCheckContainersReturnsOnCall map[int]struct {
		result1 []db.Container
		result2 map[int]time.Time
		result3 error
	}
	FindContainerByHandleStub        func(string) (db.Container, bool, error)
	findContainerByHandleMutex       sync.RWMutex
	findContainerByHandleArgsForCall []struct {
		arg1 string
	}
	findContainerByHandleReturns struct {
		result1 db.Container
		result2 bool
		result3 error
	}
	findContainerByHandleReturnsOnCall map[int]struct {
		result1 db.Container
		result2 bool
		result3 error
	}
	FindContainersByMetadataStub        func(db.ContainerMetadata) ([]db.Container, error)
	findContainersByMetadataMutex       sync.RWMutex
	findContainersByMetadataArgsForCall []struct {
		arg1 db.ContainerMetadata
	}
	findContainersByMetadataReturns struct {
		result1 []db.Container
		result2 error
	}
	findContainersByMetadataReturnsOnCall map[int]struct {
		result1 []db.Container
		result2 error
	}
	FindCreatedContainerByHandleStub        func(string) (db.CreatedContainer, bool, error)
	findCreatedContainerByHandleMutex       sync.RWMutex
	findCreatedContainerByHandleArgsForCall []struct {
		arg1 string
	}
	findCreatedContainerByHandleReturns struct {
		result1 db.CreatedContainer
		result2 bool
		result3 error
	}
	findCreatedContainerByHandleReturnsOnCall map[int]struct {
		result1 db.CreatedContainer
		result2 bool
		result3 error
	}
	FindVolumeForWorkerArtifactStub        func(int) (db.CreatedVolume, bool, error)
	findVolumeForWorkerArtifactMutex       sync.RWMutex
	findVolumeForWorkerArtifactArgsForCall []struct {
		arg1 int
	}
	findVolumeForWorkerArtifactReturns struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}
	findVolumeForWorkerArtifactReturnsOnCall map[int]struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}
	FindWorkerForContainerStub        func(string) (db.Worker, bool, error)
	findWorkerForContainerMutex       sync.RWMutex
	findWorkerForContainerArgsForCall []struct {
		arg1 string
	}
	findWorkerForContainerReturns struct {
		result1 db.Worker
		result2 bool
		result3 error
	}
	findWorkerForContainerReturnsOnCall map[int]struct {
		result1 db.Worker
		result2 bool
		result3 error
	}
	FindWorkerForVolumeStub        func(string) (db.Worker, bool, error)
	findWorkerForVolumeMutex       sync.RWMutex
	findWorkerForVolumeArgsForCall []struct {
		arg1 string
	}
	findWorkerForVolumeReturns struct {
		result1 db.Worker
		result2 bool
		result3 error
	}
	findWorkerForVolumeReturnsOnCall map[int]struct {
		result1 db.Worker
		result2 bool
		result3 error
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	IsCheckContainerStub        func(string) (bool, error)
	isCheckContainerMutex       sync.RWMutex
	isCheckContainerArgsForCall []struct {
		arg1 string
	}
	isCheckContainerReturns struct {
		result1 bool
		result2 error
	}
	isCheckContainerReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsContainerWithinTeamStub        func(string, bool) (bool, error)
	isContainerWithinTeamMutex       sync.RWMutex
	isContainerWithinTeamArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	isContainerWithinTeamReturns struct {
		result1 bool
		result2 error
	}
	isContainerWithinTeamReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	OrderPipelinesStub        func([]string) error
	orderPipelinesMutex       sync.RWMutex
	orderPipelinesArgsForCall []struct {
		arg1 []string
	}
	orderPipelinesReturns struct {
		result1 error
	}
	orderPipelinesReturnsOnCall map[int]struct {
		result1 error
	}
	PipelineStub        func(string) (db.Pipeline, bool, error)
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct {
		arg1 string
	}
	pipelineReturns struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	pipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	PipelinesStub        func() ([]db.Pipeline, error)
	pipelinesMutex       sync.RWMutex
	pipelinesArgsForCall []struct {
	}
	pipelinesReturns struct {
		result1 []db.Pipeline
		result2 error
	}
	pipelinesReturnsOnCall map[int]struct {
		result1 []db.Pipeline
		result2 error
	}
	PrivateAndPublicBuildsStub        func(db.Page) ([]db.Build, db.Pagination, error)
	privateAndPublicBuildsMutex       sync.RWMutex
	privateAndPublicBuildsArgsForCall []struct {
		arg1 db.Page
	}
	privateAndPublicBuildsReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	privateAndPublicBuildsReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	PublicPipelinesStub        func() ([]db.Pipeline, error)
	publicPipelinesMutex       sync.RWMutex
	publicPipelinesArgsForCall []struct {
	}
	publicPipelinesReturns struct {
		result1 []db.Pipeline
		result2 error
	}
	publicPipelinesReturnsOnCall map[int]struct {
		result1 []db.Pipeline
		result2 error
	}
	RenameStub        func(string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	SavePipelineStub        func(string, atc.Config, db.ConfigVersion, bool) (db.Pipeline, bool, error)
	savePipelineMutex       sync.RWMutex
	savePipelineArgsForCall []struct {
		arg1 string
		arg2 atc.Config
		arg3 db.ConfigVersion
		arg4 bool
	}
	savePipelineReturns struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	savePipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	SaveWorkerStub        func(atc.Worker, time.Duration) (db.Worker, error)
	saveWorkerMutex       sync.RWMutex
	saveWorkerArgsForCall []struct {
		arg1 atc.Worker
		arg2 time.Duration
	}
	saveWorkerReturns struct {
		result1 db.Worker
		result2 error
	}
	saveWorkerReturnsOnCall map[int]struct {
		result1 db.Worker
		result2 error
	}
	UpdateProviderAuthStub        func(atc.TeamAuth) error
	updateProviderAuthMutex       sync.RWMutex
	updateProviderAuthArgsForCall []struct {
		arg1 atc.TeamAuth
	}
	updateProviderAuthReturns struct {
		result1 error
	}
	updateProviderAuthReturnsOnCall map[int]struct {
		result1 error
	}
	VisiblePipelinesStub        func() ([]db.Pipeline, error)
	visiblePipelinesMutex       sync.RWMutex
	visiblePipelinesArgsForCall []struct {
	}
	visiblePipelinesReturns struct {
		result1 []db.Pipeline
		result2 error
	}
	visiblePipelinesReturnsOnCall map[int]struct {
		result1 []db.Pipeline
		result2 error
	}
	WorkersStub        func() ([]db.Worker, error)
	workersMutex       sync.RWMutex
	workersArgsForCall []struct {
	}
	workersReturns struct {
		result1 []db.Worker
		result2 error
	}
	workersReturnsOnCall map[int]struct {
		result1 []db.Worker
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTeam) Admin() bool {
	fake.adminMutex.Lock()
	ret, specificReturn := fake.adminReturnsOnCall[len(fake.adminArgsForCall)]
	fake.adminArgsForCall = append(fake.adminArgsForCall, struct {
	}{})
	fake.recordInvocation("Admin", []interface{}{})
	fake.adminMutex.Unlock()
	if fake.AdminStub != nil {
		return fake.AdminStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.adminReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) AdminCallCount() int {
	fake.adminMutex.RLock()
	defer fake.adminMutex.RUnlock()
	return len(fake.adminArgsForCall)
}

func (fake *FakeTeam) AdminCalls(stub func() bool) {
	fake.adminMutex.Lock()
	defer fake.adminMutex.Unlock()
	fake.AdminStub = stub
}

func (fake *FakeTeam) AdminReturns(result1 bool) {
	fake.adminMutex.Lock()
	defer fake.adminMutex.Unlock()
	fake.AdminStub = nil
	fake.adminReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeTeam) AdminReturnsOnCall(i int, result1 bool) {
	fake.adminMutex.Lock()
	defer fake.adminMutex.Unlock()
	fake.AdminStub = nil
	if fake.adminReturnsOnCall == nil {
		fake.adminReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.adminReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeTeam) Auth() atc.TeamAuth {
	fake.authMutex.Lock()
	ret, specificReturn := fake.authReturnsOnCall[len(fake.authArgsForCall)]
	fake.authArgsForCall = append(fake.authArgsForCall, struct {
	}{})
	fake.recordInvocation("Auth", []interface{}{})
	fake.authMutex.Unlock()
	if fake.AuthStub != nil {
		return fake.AuthStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.authReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) AuthCallCount() int {
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	return len(fake.authArgsForCall)
}

func (fake *FakeTeam) AuthCalls(stub func() atc.TeamAuth) {
	fake.authMutex.Lock()
	defer fake.authMutex.Unlock()
	fake.AuthStub = stub
}

func (fake *FakeTeam) AuthReturns(result1 atc.TeamAuth) {
	fake.authMutex.Lock()
	defer fake.authMutex.Unlock()
	fake.AuthStub = nil
	fake.authReturns = struct {
		result1 atc.TeamAuth
	}{result1}
}

func (fake *FakeTeam) AuthReturnsOnCall(i int, result1 atc.TeamAuth) {
	fake.authMutex.Lock()
	defer fake.authMutex.Unlock()
	fake.AuthStub = nil
	if fake.authReturnsOnCall == nil {
		fake.authReturnsOnCall = make(map[int]struct {
			result1 atc.TeamAuth
		})
	}
	fake.authReturnsOnCall[i] = struct {
		result1 atc.TeamAuth
	}{result1}
}

func (fake *FakeTeam) Builds(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	fake.recordInvocation("Builds", []interface{}{arg1})
	fake.buildsMutex.Unlock()
	if fake.BuildsStub != nil {
		return fake.BuildsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakeTeam) BuildsCalls(stub func(db.Page) ([]db.Build, db.Pagination, error)) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = stub
}

func (fake *FakeTeam) BuildsArgsForCall(i int) db.Page {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	argsForCall := fake.buildsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) BuildsReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsWithTime(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsWithTimeMutex.Lock()
	ret, specificReturn := fake.buildsWithTimeReturnsOnCall[len(fake.buildsWithTimeArgsForCall)]
	fake.buildsWithTimeArgsForCall = append(fake.buildsWithTimeArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	fake.recordInvocation("BuildsWithTime", []interface{}{arg1})
	fake.buildsWithTimeMutex.Unlock()
	if fake.BuildsWithTimeStub != nil {
		return fake.BuildsWithTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsWithTimeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) BuildsWithTimeCallCount() int {
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	return len(fake.buildsWithTimeArgsForCall)
}

func (fake *FakeTeam) BuildsWithTimeCalls(stub func(db.Page) ([]db.Build, db.Pagination, error)) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = stub
}

func (fake *FakeTeam) BuildsWithTimeArgsForCall(i int) db.Page {
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	argsForCall := fake.buildsWithTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) BuildsWithTimeReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = nil
	fake.buildsWithTimeReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) BuildsWithTimeReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = nil
	if fake.buildsWithTimeReturnsOnCall == nil {
		fake.buildsWithTimeReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsWithTimeReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) Containers() ([]db.Container, error) {
	fake.containersMutex.Lock()
	ret, specificReturn := fake.containersReturnsOnCall[len(fake.containersArgsForCall)]
	fake.containersArgsForCall = append(fake.containersArgsForCall, struct {
	}{})
	fake.recordInvocation("Containers", []interface{}{})
	fake.containersMutex.Unlock()
	if fake.ContainersStub != nil {
		return fake.ContainersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) ContainersCallCount() int {
	fake.containersMutex.RLock()
	defer fake.containersMutex.RUnlock()
	return len(fake.containersArgsForCall)
}

func (fake *FakeTeam) ContainersCalls(stub func() ([]db.Container, error)) {
	fake.containersMutex.Lock()
	defer fake.containersMutex.Unlock()
	fake.ContainersStub = stub
}

func (fake *FakeTeam) ContainersReturns(result1 []db.Container, result2 error) {
	fake.containersMutex.Lock()
	defer fake.containersMutex.Unlock()
	fake.ContainersStub = nil
	fake.containersReturns = struct {
		result1 []db.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) ContainersReturnsOnCall(i int, result1 []db.Container, result2 error) {
	fake.containersMutex.Lock()
	defer fake.containersMutex.Unlock()
	fake.ContainersStub = nil
	if fake.containersReturnsOnCall == nil {
		fake.containersReturnsOnCall = make(map[int]struct {
			result1 []db.Container
			result2 error
		})
	}
	fake.containersReturnsOnCall[i] = struct {
		result1 []db.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateOneOffBuild() (db.Build, error) {
	fake.createOneOffBuildMutex.Lock()
	ret, specificReturn := fake.createOneOffBuildReturnsOnCall[len(fake.createOneOffBuildArgsForCall)]
	fake.createOneOffBuildArgsForCall = append(fake.createOneOffBuildArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateOneOffBuild", []interface{}{})
	fake.createOneOffBuildMutex.Unlock()
	if fake.CreateOneOffBuildStub != nil {
		return fake.CreateOneOffBuildStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createOneOffBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) CreateOneOffBuildCallCount() int {
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	return len(fake.createOneOffBuildArgsForCall)
}

func (fake *FakeTeam) CreateOneOffBuildCalls(stub func() (db.Build, error)) {
	fake.createOneOffBuildMutex.Lock()
	defer fake.createOneOffBuildMutex.Unlock()
	fake.CreateOneOffBuildStub = stub
}

func (fake *FakeTeam) CreateOneOffBuildReturns(result1 db.Build, result2 error) {
	fake.createOneOffBuildMutex.Lock()
	defer fake.createOneOffBuildMutex.Unlock()
	fake.CreateOneOffBuildStub = nil
	fake.createOneOffBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateOneOffBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.createOneOffBuildMutex.Lock()
	defer fake.createOneOffBuildMutex.Unlock()
	fake.CreateOneOffBuildStub = nil
	if fake.createOneOffBuildReturnsOnCall == nil {
		fake.createOneOffBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createOneOffBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateStartedBuild(arg1 atc.Plan) (db.Build, error) {
	fake.createStartedBuildMutex.Lock()
	ret, specificReturn := fake.createStartedBuildReturnsOnCall[len(fake.createStartedBuildArgsForCall)]
	fake.createStartedBuildArgsForCall = append(fake.createStartedBuildArgsForCall, struct {
		arg1 atc.Plan
	}{arg1})
	fake.recordInvocation("CreateStartedBuild", []interface{}{arg1})
	fake.createStartedBuildMutex.Unlock()
	if fake.CreateStartedBuildStub != nil {
		return fake.CreateStartedBuildStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createStartedBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) CreateStartedBuildCallCount() int {
	fake.createStartedBuildMutex.RLock()
	defer fake.createStartedBuildMutex.RUnlock()
	return len(fake.createStartedBuildArgsForCall)
}

func (fake *FakeTeam) CreateStartedBuildCalls(stub func(atc.Plan) (db.Build, error)) {
	fake.createStartedBuildMutex.Lock()
	defer fake.createStartedBuildMutex.Unlock()
	fake.CreateStartedBuildStub = stub
}

func (fake *FakeTeam) CreateStartedBuildArgsForCall(i int) atc.Plan {
	fake.createStartedBuildMutex.RLock()
	defer fake.createStartedBuildMutex.RUnlock()
	argsForCall := fake.createStartedBuildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) CreateStartedBuildReturns(result1 db.Build, result2 error) {
	fake.createStartedBuildMutex.Lock()
	defer fake.createStartedBuildMutex.Unlock()
	fake.CreateStartedBuildStub = nil
	fake.createStartedBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateStartedBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.createStartedBuildMutex.Lock()
	defer fake.createStartedBuildMutex.Unlock()
	fake.CreateStartedBuildStub = nil
	if fake.createStartedBuildReturnsOnCall == nil {
		fake.createStartedBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createStartedBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Delete() error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
	}{})
	fake.recordInvocation("Delete", []interface{}{})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeTeam) DeleteCalls(stub func() error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeTeam) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) FindCheckContainers(arg1 string, arg2 string, arg3 creds.Secrets) ([]db.Container, map[int]time.Time, error) {
	fake.findCheckContainersMutex.Lock()
	ret, specificReturn := fake.findCheckContainersReturnsOnCall[len(fake.findCheckContainersArgsForCall)]
	fake.findCheckContainersArgsForCall = append(fake.findCheckContainersArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 creds.Secrets
	}{arg1, arg2, arg3})
	fake.recordInvocation("FindCheckContainers", []interface{}{arg1, arg2, arg3})
	fake.findCheckContainersMutex.Unlock()
	if fake.FindCheckContainersStub != nil {
		return fake.FindCheckContainersStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findCheckContainersReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) FindCheckContainersCallCount() int {
	fake.findCheckContainersMutex.RLock()
	defer fake.findCheckContainersMutex.RUnlock()
	return len(fake.findCheckContainersArgsForCall)
}

func (fake *FakeTeam) FindCheckContainersCalls(stub func(string, string, creds.Secrets) ([]db.Container, map[int]time.Time, error)) {
	fake.findCheckContainersMutex.Lock()
	defer fake.findCheckContainersMutex.Unlock()
	fake.FindCheckContainersStub = stub
}

func (fake *FakeTeam) FindCheckContainersArgsForCall(i int) (string, string, creds.Secrets) {
	fake.findCheckContainersMutex.RLock()
	defer fake.findCheckContainersMutex.RUnlock()
	argsForCall := fake.findCheckContainersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeam) FindCheckContainersReturns(result1 []db.Container, result2 map[int]time.Time, result3 error) {
	fake.findCheckContainersMutex.Lock()
	defer fake.findCheckContainersMutex.Unlock()
	fake.FindCheckContainersStub = nil
	fake.findCheckContainersReturns = struct {
		result1 []db.Container
		result2 map[int]time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindCheckContainersReturnsOnCall(i int, result1 []db.Container, result2 map[int]time.Time, result3 error) {
	fake.findCheckContainersMutex.Lock()
	defer fake.findCheckContainersMutex.Unlock()
	fake.FindCheckContainersStub = nil
	if fake.findCheckContainersReturnsOnCall == nil {
		fake.findCheckContainersReturnsOnCall = make(map[int]struct {
			result1 []db.Container
			result2 map[int]time.Time
			result3 error
		})
	}
	fake.findCheckContainersReturnsOnCall[i] = struct {
		result1 []db.Container
		result2 map[int]time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindContainerByHandle(arg1 string) (db.Container, bool, error) {
	fake.findContainerByHandleMutex.Lock()
	ret, specificReturn := fake.findContainerByHandleReturnsOnCall[len(fake.findContainerByHandleArgsForCall)]
	fake.findContainerByHandleArgsForCall = append(fake.findContainerByHandleArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindContainerByHandle", []interface{}{arg1})
	fake.findContainerByHandleMutex.Unlock()
	if fake.FindContainerByHandleStub != nil {
		return fake.FindContainerByHandleStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findContainerByHandleReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) FindContainerByHandleCallCount() int {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	return len(fake.findContainerByHandleArgsForCall)
}

func (fake *FakeTeam) FindContainerByHandleCalls(stub func(string) (db.Container, bool, error)) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = stub
}

func (fake *FakeTeam) FindContainerByHandleArgsForCall(i int) string {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	argsForCall := fake.findContainerByHandleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) FindContainerByHandleReturns(result1 db.Container, result2 bool, result3 error) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = nil
	fake.findContainerByHandleReturns = struct {
		result1 db.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindContainerByHandleReturnsOnCall(i int, result1 db.Container, result2 bool, result3 error) {
	fake.findContainerByHandleMutex.Lock()
	defer fake.findContainerByHandleMutex.Unlock()
	fake.FindContainerByHandleStub = nil
	if fake.findContainerByHandleReturnsOnCall == nil {
		fake.findContainerByHandleReturnsOnCall = make(map[int]struct {
			result1 db.Container
			result2 bool
			result3 error
		})
	}
	fake.findContainerByHandleReturnsOnCall[i] = struct {
		result1 db.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindContainersByMetadata(arg1 db.ContainerMetadata) ([]db.Container, error) {
	fake.findContainersByMetadataMutex.Lock()
	ret, specificReturn := fake.findContainersByMetadataReturnsOnCall[len(fake.findContainersByMetadataArgsForCall)]
	fake.findContainersByMetadataArgsForCall = append(fake.findContainersByMetadataArgsForCall, struct {
		arg1 db.ContainerMetadata
	}{arg1})
	fake.recordInvocation("FindContainersByMetadata", []interface{}{arg1})
	fake.findContainersByMetadataMutex.Unlock()
	if fake.FindContainersByMetadataStub != nil {
		return fake.FindContainersByMetadataStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findContainersByMetadataReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) FindContainersByMetadataCallCount() int {
	fake.findContainersByMetadataMutex.RLock()
	defer fake.findContainersByMetadataMutex.RUnlock()
	return len(fake.findContainersByMetadataArgsForCall)
}

func (fake *FakeTeam) FindContainersByMetadataCalls(stub func(db.ContainerMetadata) ([]db.Container, error)) {
	fake.findContainersByMetadataMutex.Lock()
	defer fake.findContainersByMetadataMutex.Unlock()
	fake.FindContainersByMetadataStub = stub
}

func (fake *FakeTeam) FindContainersByMetadataArgsForCall(i int) db.ContainerMetadata {
	fake.findContainersByMetadataMutex.RLock()
	defer fake.findContainersByMetadataMutex.RUnlock()
	argsForCall := fake.findContainersByMetadataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) FindContainersByMetadataReturns(result1 []db.Container, result2 error) {
	fake.findContainersByMetadataMutex.Lock()
	defer fake.findContainersByMetadataMutex.Unlock()
	fake.FindContainersByMetadataStub = nil
	fake.findContainersByMetadataReturns = struct {
		result1 []db.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) FindContainersByMetadataReturnsOnCall(i int, result1 []db.Container, result2 error) {
	fake.findContainersByMetadataMutex.Lock()
	defer fake.findContainersByMetadataMutex.Unlock()
	fake.FindContainersByMetadataStub = nil
	if fake.findContainersByMetadataReturnsOnCall == nil {
		fake.findContainersByMetadataReturnsOnCall = make(map[int]struct {
			result1 []db.Container
			result2 error
		})
	}
	fake.findContainersByMetadataReturnsOnCall[i] = struct {
		result1 []db.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) FindCreatedContainerByHandle(arg1 string) (db.CreatedContainer, bool, error) {
	fake.findCreatedContainerByHandleMutex.Lock()
	ret, specificReturn := fake.findCreatedContainerByHandleReturnsOnCall[len(fake.findCreatedContainerByHandleArgsForCall)]
	fake.findCreatedContainerByHandleArgsForCall = append(fake.findCreatedContainerByHandleArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindCreatedContainerByHandle", []interface{}{arg1})
	fake.findCreatedContainerByHandleMutex.Unlock()
	if fake.FindCreatedContainerByHandleStub != nil {
		return fake.FindCreatedContainerByHandleStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findCreatedContainerByHandleReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) FindCreatedContainerByHandleCallCount() int {
	fake.findCreatedContainerByHandleMutex.RLock()
	defer fake.findCreatedContainerByHandleMutex.RUnlock()
	return len(fake.findCreatedContainerByHandleArgsForCall)
}

func (fake *FakeTeam) FindCreatedContainerByHandleCalls(stub func(string) (db.CreatedContainer, bool, error)) {
	fake.findCreatedContainerByHandleMutex.Lock()
	defer fake.findCreatedContainerByHandleMutex.Unlock()
	fake.FindCreatedContainerByHandleStub = stub
}

func (fake *FakeTeam) FindCreatedContainerByHandleArgsForCall(i int) string {
	fake.findCreatedContainerByHandleMutex.RLock()
	defer fake.findCreatedContainerByHandleMutex.RUnlock()
	argsForCall := fake.findCreatedContainerByHandleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) FindCreatedContainerByHandleReturns(result1 db.CreatedContainer, result2 bool, result3 error) {
	fake.findCreatedContainerByHandleMutex.Lock()
	defer fake.findCreatedContainerByHandleMutex.Unlock()
	fake.FindCreatedContainerByHandleStub = nil
	fake.findCreatedContainerByHandleReturns = struct {
		result1 db.CreatedContainer
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindCreatedContainerByHandleReturnsOnCall(i int, result1 db.CreatedContainer, result2 bool, result3 error) {
	fake.findCreatedContainerByHandleMutex.Lock()
	defer fake.findCreatedContainerByHandleMutex.Unlock()
	fake.FindCreatedContainerByHandleStub = nil
	if fake.findCreatedContainerByHandleReturnsOnCall == nil {
		fake.findCreatedContainerByHandleReturnsOnCall = make(map[int]struct {
			result1 db.CreatedContainer
			result2 bool
			result3 error
		})
	}
	fake.findCreatedContainerByHandleReturnsOnCall[i] = struct {
		result1 db.CreatedContainer
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindVolumeForWorkerArtifact(arg1 int) (db.CreatedVolume, bool, error) {
	fake.findVolumeForWorkerArtifactMutex.Lock()
	ret, specificReturn := fake.findVolumeForWorkerArtifactReturnsOnCall[len(fake.findVolumeForWorkerArtifactArgsForCall)]
	fake.findVolumeForWorkerArtifactArgsForCall = append(fake.findVolumeForWorkerArtifactArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("FindVolumeForWorkerArtifact", []interface{}{arg1})
	fake.findVolumeForWorkerArtifactMutex.Unlock()
	if fake.FindVolumeForWorkerArtifactStub != nil {
		return fake.FindVolumeForWorkerArtifactStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findVolumeForWorkerArtifactReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) FindVolumeForWorkerArtifactCallCount() int {
	fake.findVolumeForWorkerArtifactMutex.RLock()
	defer fake.findVolumeForWorkerArtifactMutex.RUnlock()
	return len(fake.findVolumeForWorkerArtifactArgsForCall)
}

func (fake *FakeTeam) FindVolumeForWorkerArtifactCalls(stub func(int) (db.CreatedVolume, bool, error)) {
	fake.findVolumeForWorkerArtifactMutex.Lock()
	defer fake.findVolumeForWorkerArtifactMutex.Unlock()
	fake.FindVolumeForWorkerArtifactStub = stub
}

func (fake *FakeTeam) FindVolumeForWorkerArtifactArgsForCall(i int) int {
	fake.findVolumeForWorkerArtifactMutex.RLock()
	defer fake.findVolumeForWorkerArtifactMutex.RUnlock()
	argsForCall := fake.findVolumeForWorkerArtifactArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) FindVolumeForWorkerArtifactReturns(result1 db.CreatedVolume, result2 bool, result3 error) {
	fake.findVolumeForWorkerArtifactMutex.Lock()
	defer fake.findVolumeForWorkerArtifactMutex.Unlock()
	fake.FindVolumeForWorkerArtifactStub = nil
	fake.findVolumeForWorkerArtifactReturns = struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindVolumeForWorkerArtifactReturnsOnCall(i int, result1 db.CreatedVolume, result2 bool, result3 error) {
	fake.findVolumeForWorkerArtifactMutex.Lock()
	defer fake.findVolumeForWorkerArtifactMutex.Unlock()
	fake.FindVolumeForWorkerArtifactStub = nil
	if fake.findVolumeForWorkerArtifactReturnsOnCall == nil {
		fake.findVolumeForWorkerArtifactReturnsOnCall = make(map[int]struct {
			result1 db.CreatedVolume
			result2 bool
			result3 error
		})
	}
	fake.findVolumeForWorkerArtifactReturnsOnCall[i] = struct {
		result1 db.CreatedVolume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindWorkerForContainer(arg1 string) (db.Worker, bool, error) {
	fake.findWorkerForContainerMutex.Lock()
	ret, specificReturn := fake.findWorkerForContainerReturnsOnCall[len(fake.findWorkerForContainerArgsForCall)]
	fake.findWorkerForContainerArgsForCall = append(fake.findWorkerForContainerArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindWorkerForContainer", []interface{}{arg1})
	fake.findWorkerForContainerMutex.Unlock()
	if fake.FindWorkerForContainerStub != nil {
		return fake.FindWorkerForContainerStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findWorkerForContainerReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) FindWorkerForContainerCallCount() int {
	fake.findWorkerForContainerMutex.RLock()
	defer fake.findWorkerForContainerMutex.RUnlock()
	return len(fake.findWorkerForContainerArgsForCall)
}

func (fake *FakeTeam) FindWorkerForContainerCalls(stub func(string) (db.Worker, bool, error)) {
	fake.findWorkerForContainerMutex.Lock()
	defer fake.findWorkerForContainerMutex.Unlock()
	fake.FindWorkerForContainerStub = stub
}

func (fake *FakeTeam) FindWorkerForContainerArgsForCall(i int) string {
	fake.findWorkerForContainerMutex.RLock()
	defer fake.findWorkerForContainerMutex.RUnlock()
	argsForCall := fake.findWorkerForContainerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) FindWorkerForContainerReturns(result1 db.Worker, result2 bool, result3 error) {
	fake.findWorkerForContainerMutex.Lock()
	defer fake.findWorkerForContainerMutex.Unlock()
	fake.FindWorkerForContainerStub = nil
	fake.findWorkerForContainerReturns = struct {
		result1 db.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindWorkerForContainerReturnsOnCall(i int, result1 db.Worker, result2 bool, result3 error) {
	fake.findWorkerForContainerMutex.Lock()
	defer fake.findWorkerForContainerMutex.Unlock()
	fake.FindWorkerForContainerStub = nil
	if fake.findWorkerForContainerReturnsOnCall == nil {
		fake.findWorkerForContainerReturnsOnCall = make(map[int]struct {
			result1 db.Worker
			result2 bool
			result3 error
		})
	}
	fake.findWorkerForContainerReturnsOnCall[i] = struct {
		result1 db.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindWorkerForVolume(arg1 string) (db.Worker, bool, error) {
	fake.findWorkerForVolumeMutex.Lock()
	ret, specificReturn := fake.findWorkerForVolumeReturnsOnCall[len(fake.findWorkerForVolumeArgsForCall)]
	fake.findWorkerForVolumeArgsForCall = append(fake.findWorkerForVolumeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindWorkerForVolume", []interface{}{arg1})
	fake.findWorkerForVolumeMutex.Unlock()
	if fake.FindWorkerForVolumeStub != nil {
		return fake.FindWorkerForVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findWorkerForVolumeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) FindWorkerForVolumeCallCount() int {
	fake.findWorkerForVolumeMutex.RLock()
	defer fake.findWorkerForVolumeMutex.RUnlock()
	return len(fake.findWorkerForVolumeArgsForCall)
}

func (fake *FakeTeam) FindWorkerForVolumeCalls(stub func(string) (db.Worker, bool, error)) {
	fake.findWorkerForVolumeMutex.Lock()
	defer fake.findWorkerForVolumeMutex.Unlock()
	fake.FindWorkerForVolumeStub = stub
}

func (fake *FakeTeam) FindWorkerForVolumeArgsForCall(i int) string {
	fake.findWorkerForVolumeMutex.RLock()
	defer fake.findWorkerForVolumeMutex.RUnlock()
	argsForCall := fake.findWorkerForVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) FindWorkerForVolumeReturns(result1 db.Worker, result2 bool, result3 error) {
	fake.findWorkerForVolumeMutex.Lock()
	defer fake.findWorkerForVolumeMutex.Unlock()
	fake.FindWorkerForVolumeStub = nil
	fake.findWorkerForVolumeReturns = struct {
		result1 db.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindWorkerForVolumeReturnsOnCall(i int, result1 db.Worker, result2 bool, result3 error) {
	fake.findWorkerForVolumeMutex.Lock()
	defer fake.findWorkerForVolumeMutex.Unlock()
	fake.FindWorkerForVolumeStub = nil
	if fake.findWorkerForVolumeReturnsOnCall == nil {
		fake.findWorkerForVolumeReturnsOnCall = make(map[int]struct {
			result1 db.Worker
			result2 bool
			result3 error
		})
	}
	fake.findWorkerForVolumeReturnsOnCall[i] = struct {
		result1 db.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeTeam) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeTeam) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeTeam) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeTeam) IsCheckContainer(arg1 string) (bool, error) {
	fake.isCheckContainerMutex.Lock()
	ret, specificReturn := fake.isCheckContainerReturnsOnCall[len(fake.isCheckContainerArgsForCall)]
	fake.isCheckContainerArgsForCall = append(fake.isCheckContainerArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("IsCheckContainer", []interface{}{arg1})
	fake.isCheckContainerMutex.Unlock()
	if fake.IsCheckContainerStub != nil {
		return fake.IsCheckContainerStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.isCheckContainerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) IsCheckContainerCallCount() int {
	fake.isCheckContainerMutex.RLock()
	defer fake.isCheckContainerMutex.RUnlock()
	return len(fake.isCheckContainerArgsForCall)
}

func (fake *FakeTeam) IsCheckContainerCalls(stub func(string) (bool, error)) {
	fake.isCheckContainerMutex.Lock()
	defer fake.isCheckContainerMutex.Unlock()
	fake.IsCheckContainerStub = stub
}

func (fake *FakeTeam) IsCheckContainerArgsForCall(i int) string {
	fake.isCheckContainerMutex.RLock()
	defer fake.isCheckContainerMutex.RUnlock()
	argsForCall := fake.isCheckContainerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) IsCheckContainerReturns(result1 bool, result2 error) {
	fake.isCheckContainerMutex.Lock()
	defer fake.isCheckContainerMutex.Unlock()
	fake.IsCheckContainerStub = nil
	fake.isCheckContainerReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) IsCheckContainerReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isCheckContainerMutex.Lock()
	defer fake.isCheckContainerMutex.Unlock()
	fake.IsCheckContainerStub = nil
	if fake.isCheckContainerReturnsOnCall == nil {
		fake.isCheckContainerReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isCheckContainerReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) IsContainerWithinTeam(arg1 string, arg2 bool) (bool, error) {
	fake.isContainerWithinTeamMutex.Lock()
	ret, specificReturn := fake.isContainerWithinTeamReturnsOnCall[len(fake.isContainerWithinTeamArgsForCall)]
	fake.isContainerWithinTeamArgsForCall = append(fake.isContainerWithinTeamArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("IsContainerWithinTeam", []interface{}{arg1, arg2})
	fake.isContainerWithinTeamMutex.Unlock()
	if fake.IsContainerWithinTeamStub != nil {
		return fake.IsContainerWithinTeamStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.isContainerWithinTeamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) IsContainerWithinTeamCallCount() int {
	fake.isContainerWithinTeamMutex.RLock()
	defer fake.isContainerWithinTeamMutex.RUnlock()
	return len(fake.isContainerWithinTeamArgsForCall)
}

func (fake *FakeTeam) IsContainerWithinTeamCalls(stub func(string, bool) (bool, error)) {
	fake.isContainerWithinTeamMutex.Lock()
	defer fake.isContainerWithinTeamMutex.Unlock()
	fake.IsContainerWithinTeamStub = stub
}

func (fake *FakeTeam) IsContainerWithinTeamArgsForCall(i int) (string, bool) {
	fake.isContainerWithinTeamMutex.RLock()
	defer fake.isContainerWithinTeamMutex.RUnlock()
	argsForCall := fake.isContainerWithinTeamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) IsContainerWithinTeamReturns(result1 bool, result2 error) {
	fake.isContainerWithinTeamMutex.Lock()
	defer fake.isContainerWithinTeamMutex.Unlock()
	fake.IsContainerWithinTeamStub = nil
	fake.isContainerWithinTeamReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) IsContainerWithinTeamReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isContainerWithinTeamMutex.Lock()
	defer fake.isContainerWithinTeamMutex.Unlock()
	fake.IsContainerWithinTeamStub = nil
	if fake.isContainerWithinTeamReturnsOnCall == nil {
		fake.isContainerWithinTeamReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isContainerWithinTeamReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeTeam) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeTeam) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeam) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeam) OrderPipelines(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.orderPipelinesMutex.Lock()
	ret, specificReturn := fake.orderPipelinesReturnsOnCall[len(fake.orderPipelinesArgsForCall)]
	fake.orderPipelinesArgsForCall = append(fake.orderPipelinesArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("OrderPipelines", []interface{}{arg1Copy})
	fake.orderPipelinesMutex.Unlock()
	if fake.OrderPipelinesStub != nil {
		return fake.OrderPipelinesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.orderPipelinesReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) OrderPipelinesCallCount() int {
	fake.orderPipelinesMutex.RLock()
	defer fake.orderPipelinesMutex.RUnlock()
	return len(fake.orderPipelinesArgsForCall)
}

func (fake *FakeTeam) OrderPipelinesCalls(stub func([]string) error) {
	fake.orderPipelinesMutex.Lock()
	defer fake.orderPipelinesMutex.Unlock()
	fake.OrderPipelinesStub = stub
}

func (fake *FakeTeam) OrderPipelinesArgsForCall(i int) []string {
	fake.orderPipelinesMutex.RLock()
	defer fake.orderPipelinesMutex.RUnlock()
	argsForCall := fake.orderPipelinesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) OrderPipelinesReturns(result1 error) {
	fake.orderPipelinesMutex.Lock()
	defer fake.orderPipelinesMutex.Unlock()
	fake.OrderPipelinesStub = nil
	fake.orderPipelinesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) OrderPipelinesReturnsOnCall(i int, result1 error) {
	fake.orderPipelinesMutex.Lock()
	defer fake.orderPipelinesMutex.Unlock()
	fake.OrderPipelinesStub = nil
	if fake.orderPipelinesReturnsOnCall == nil {
		fake.orderPipelinesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.orderPipelinesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) Pipeline(arg1 string) (db.Pipeline, bool, error) {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Pipeline", []interface{}{arg1})
	fake.pipelineMutex.Unlock()
	if fake.PipelineStub != nil {
		return fake.PipelineStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.pipelineReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeTeam) PipelineCalls(stub func(string) (db.Pipeline, bool, error)) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = stub
}

func (fake *FakeTeam) PipelineArgsForCall(i int) string {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	argsForCall := fake.pipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) PipelineReturns(result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) PipelineReturnsOnCall(i int, result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) Pipelines() ([]db.Pipeline, error) {
	fake.pipelinesMutex.Lock()
	ret, specificReturn := fake.pipelinesReturnsOnCall[len(fake.pipelinesArgsForCall)]
	fake.pipelinesArgsForCall = append(fake.pipelinesArgsForCall, struct {
	}{})
	fake.recordInvocation("Pipelines", []interface{}{})
	fake.pipelinesMutex.Unlock()
	if fake.PipelinesStub != nil {
		return fake.PipelinesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pipelinesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) PipelinesCallCount() int {
	fake.pipelinesMutex.RLock()
	defer fake.pipelinesMutex.RUnlock()
	return len(fake.pipelinesArgsForCall)
}

func (fake *FakeTeam) PipelinesCalls(stub func() ([]db.Pipeline, error)) {
	fake.pipelinesMutex.Lock()
	defer fake.pipelinesMutex.Unlock()
	fake.PipelinesStub = stub
}

func (fake *FakeTeam) PipelinesReturns(result1 []db.Pipeline, result2 error) {
	fake.pipelinesMutex.Lock()
	defer fake.pipelinesMutex.Unlock()
	fake.PipelinesStub = nil
	fake.pipelinesReturns = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PipelinesReturnsOnCall(i int, result1 []db.Pipeline, result2 error) {
	fake.pipelinesMutex.Lock()
	defer fake.pipelinesMutex.Unlock()
	fake.PipelinesStub = nil
	if fake.pipelinesReturnsOnCall == nil {
		fake.pipelinesReturnsOnCall = make(map[int]struct {
			result1 []db.Pipeline
			result2 error
		})
	}
	fake.pipelinesReturnsOnCall[i] = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PrivateAndPublicBuilds(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.privateAndPublicBuildsMutex.Lock()
	ret, specificReturn := fake.privateAndPublicBuildsReturnsOnCall[len(fake.privateAndPublicBuildsArgsForCall)]
	fake.privateAndPublicBuildsArgsForCall = append(fake.privateAndPublicBuildsArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	fake.recordInvocation("PrivateAndPublicBuilds", []interface{}{arg1})
	fake.privateAndPublicBuildsMutex.Unlock()
	if fake.PrivateAndPublicBuildsStub != nil {
		return fake.PrivateAndPublicBuildsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.privateAndPublicBuildsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) PrivateAndPublicBuildsCallCount() int {
	fake.privateAndPublicBuildsMutex.RLock()
	defer fake.privateAndPublicBuildsMutex.RUnlock()
	return len(fake.privateAndPublicBuildsArgsForCall)
}

func (fake *FakeTeam) PrivateAndPublicBuildsCalls(stub func(db.Page) ([]db.Build, db.Pagination, error)) {
	fake.privateAndPublicBuildsMutex.Lock()
	defer fake.privateAndPublicBuildsMutex.Unlock()
	fake.PrivateAndPublicBuildsStub = stub
}

func (fake *FakeTeam) PrivateAndPublicBuildsArgsForCall(i int) db.Page {
	fake.privateAndPublicBuildsMutex.RLock()
	defer fake.privateAndPublicBuildsMutex.RUnlock()
	argsForCall := fake.privateAndPublicBuildsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) PrivateAndPublicBuildsReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.privateAndPublicBuildsMutex.Lock()
	defer fake.privateAndPublicBuildsMutex.Unlock()
	fake.PrivateAndPublicBuildsStub = nil
	fake.privateAndPublicBuildsReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) PrivateAndPublicBuildsReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.privateAndPublicBuildsMutex.Lock()
	defer fake.privateAndPublicBuildsMutex.Unlock()
	fake.PrivateAndPublicBuildsStub = nil
	if fake.privateAndPublicBuildsReturnsOnCall == nil {
		fake.privateAndPublicBuildsReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.privateAndPublicBuildsReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) PublicPipelines() ([]db.Pipeline, error) {
	fake.publicPipelinesMutex.Lock()
	ret, specificReturn := fake.publicPipelinesReturnsOnCall[len(fake.publicPipelinesArgsForCall)]
	fake.publicPipelinesArgsForCall = append(fake.publicPipelinesArgsForCall, struct {
	}{})
	fake.recordInvocation("PublicPipelines", []interface{}{})
	fake.publicPipelinesMutex.Unlock()
	if fake.PublicPipelinesStub != nil {
		return fake.PublicPipelinesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.publicPipelinesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) PublicPipelinesCallCount() int {
	fake.publicPipelinesMutex.RLock()
	defer fake.publicPipelinesMutex.RUnlock()
	return len(fake.publicPipelinesArgsForCall)
}

func (fake *FakeTeam) PublicPipelinesCalls(stub func() ([]db.Pipeline, error)) {
	fake.publicPipelinesMutex.Lock()
	defer fake.publicPipelinesMutex.Unlock()
	fake.PublicPipelinesStub = stub
}

func (fake *FakeTeam) PublicPipelinesReturns(result1 []db.Pipeline, result2 error) {
	fake.publicPipelinesMutex.Lock()
	defer fake.publicPipelinesMutex.Unlock()
	fake.PublicPipelinesStub = nil
	fake.publicPipelinesReturns = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) PublicPipelinesReturnsOnCall(i int, result1 []db.Pipeline, result2 error) {
	fake.publicPipelinesMutex.Lock()
	defer fake.publicPipelinesMutex.Unlock()
	fake.PublicPipelinesStub = nil
	if fake.publicPipelinesReturnsOnCall == nil {
		fake.publicPipelinesReturnsOnCall = make(map[int]struct {
			result1 []db.Pipeline
			result2 error
		})
	}
	fake.publicPipelinesReturnsOnCall[i] = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Rename(arg1 string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Rename", []interface{}{arg1})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renameReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeTeam) RenameCalls(stub func(string) error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = stub
}

func (fake *FakeTeam) RenameArgsForCall(i int) string {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	argsForCall := fake.renameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) RenameReturns(result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) RenameReturnsOnCall(i int, result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) SavePipeline(arg1 string, arg2 atc.Config, arg3 db.ConfigVersion, arg4 bool) (db.Pipeline, bool, error) {
	fake.savePipelineMutex.Lock()
	ret, specificReturn := fake.savePipelineReturnsOnCall[len(fake.savePipelineArgsForCall)]
	fake.savePipelineArgsForCall = append(fake.savePipelineArgsForCall, struct {
		arg1 string
		arg2 atc.Config
		arg3 db.ConfigVersion
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("SavePipeline", []interface{}{arg1, arg2, arg3, arg4})
	fake.savePipelineMutex.Unlock()
	if fake.SavePipelineStub != nil {
		return fake.SavePipelineStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.savePipelineReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTeam) SavePipelineCallCount() int {
	fake.savePipelineMutex.RLock()
	defer fake.savePipelineMutex.RUnlock()
	return len(fake.savePipelineArgsForCall)
}

func (fake *FakeTeam) SavePipelineCalls(stub func(string, atc.Config, db.ConfigVersion, bool) (db.Pipeline, bool, error)) {
	fake.savePipelineMutex.Lock()
	defer fake.savePipelineMutex.Unlock()
	fake.SavePipelineStub = stub
}

func (fake *FakeTeam) SavePipelineArgsForCall(i int) (string, atc.Config, db.ConfigVersion, bool) {
	fake.savePipelineMutex.RLock()
	defer fake.savePipelineMutex.RUnlock()
	argsForCall := fake.savePipelineArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTeam) SavePipelineReturns(result1 db.Pipeline, result2 bool, result3 error) {
	fake.savePipelineMutex.Lock()
	defer fake.savePipelineMutex.Unlock()
	fake.SavePipelineStub = nil
	fake.savePipelineReturns = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) SavePipelineReturnsOnCall(i int, result1 db.Pipeline, result2 bool, result3 error) {
	fake.savePipelineMutex.Lock()
	defer fake.savePipelineMutex.Unlock()
	fake.SavePipelineStub = nil
	if fake.savePipelineReturnsOnCall == nil {
		fake.savePipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.savePipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) SaveWorker(arg1 atc.Worker, arg2 time.Duration) (db.Worker, error) {
	fake.saveWorkerMutex.Lock()
	ret, specificReturn := fake.saveWorkerReturnsOnCall[len(fake.saveWorkerArgsForCall)]
	fake.saveWorkerArgsForCall = append(fake.saveWorkerArgsForCall, struct {
		arg1 atc.Worker
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("SaveWorker", []interface{}{arg1, arg2})
	fake.saveWorkerMutex.Unlock()
	if fake.SaveWorkerStub != nil {
		return fake.SaveWorkerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.saveWorkerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) SaveWorkerCallCount() int {
	fake.saveWorkerMutex.RLock()
	defer fake.saveWorkerMutex.RUnlock()
	return len(fake.saveWorkerArgsForCall)
}

func (fake *FakeTeam) SaveWorkerCalls(stub func(atc.Worker, time.Duration) (db.Worker, error)) {
	fake.saveWorkerMutex.Lock()
	defer fake.saveWorkerMutex.Unlock()
	fake.SaveWorkerStub = stub
}

func (fake *FakeTeam) SaveWorkerArgsForCall(i int) (atc.Worker, time.Duration) {
	fake.saveWorkerMutex.RLock()
	defer fake.saveWorkerMutex.RUnlock()
	argsForCall := fake.saveWorkerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeam) SaveWorkerReturns(result1 db.Worker, result2 error) {
	fake.saveWorkerMutex.Lock()
	defer fake.saveWorkerMutex.Unlock()
	fake.SaveWorkerStub = nil
	fake.saveWorkerReturns = struct {
		result1 db.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) SaveWorkerReturnsOnCall(i int, result1 db.Worker, result2 error) {
	fake.saveWorkerMutex.Lock()
	defer fake.saveWorkerMutex.Unlock()
	fake.SaveWorkerStub = nil
	if fake.saveWorkerReturnsOnCall == nil {
		fake.saveWorkerReturnsOnCall = make(map[int]struct {
			result1 db.Worker
			result2 error
		})
	}
	fake.saveWorkerReturnsOnCall[i] = struct {
		result1 db.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UpdateProviderAuth(arg1 atc.TeamAuth) error {
	fake.updateProviderAuthMutex.Lock()
	ret, specificReturn := fake.updateProviderAuthReturnsOnCall[len(fake.updateProviderAuthArgsForCall)]
	fake.updateProviderAuthArgsForCall = append(fake.updateProviderAuthArgsForCall, struct {
		arg1 atc.TeamAuth
	}{arg1})
	fake.recordInvocation("UpdateProviderAuth", []interface{}{arg1})
	fake.updateProviderAuthMutex.Unlock()
	if fake.UpdateProviderAuthStub != nil {
		return fake.UpdateProviderAuthStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateProviderAuthReturns
	return fakeReturns.result1
}

func (fake *FakeTeam) UpdateProviderAuthCallCount() int {
	fake.updateProviderAuthMutex.RLock()
	defer fake.updateProviderAuthMutex.RUnlock()
	return len(fake.updateProviderAuthArgsForCall)
}

func (fake *FakeTeam) UpdateProviderAuthCalls(stub func(atc.TeamAuth) error) {
	fake.updateProviderAuthMutex.Lock()
	defer fake.updateProviderAuthMutex.Unlock()
	fake.UpdateProviderAuthStub = stub
}

func (fake *FakeTeam) UpdateProviderAuthArgsForCall(i int) atc.TeamAuth {
	fake.updateProviderAuthMutex.RLock()
	defer fake.updateProviderAuthMutex.RUnlock()
	argsForCall := fake.updateProviderAuthArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeam) UpdateProviderAuthReturns(result1 error) {
	fake.updateProviderAuthMutex.Lock()
	defer fake.updateProviderAuthMutex.Unlock()
	fake.UpdateProviderAuthStub = nil
	fake.updateProviderAuthReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) UpdateProviderAuthReturnsOnCall(i int, result1 error) {
	fake.updateProviderAuthMutex.Lock()
	defer fake.updateProviderAuthMutex.Unlock()
	fake.UpdateProviderAuthStub = nil
	if fake.updateProviderAuthReturnsOnCall == nil {
		fake.updateProviderAuthReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateProviderAuthReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) VisiblePipelines() ([]db.Pipeline, error) {
	fake.visiblePipelinesMutex.Lock()
	ret, specificReturn := fake.visiblePipelinesReturnsOnCall[len(fake.visiblePipelinesArgsForCall)]
	fake.visiblePipelinesArgsForCall = append(fake.visiblePipelinesArgsForCall, struct {
	}{})
	fake.recordInvocation("VisiblePipelines", []interface{}{})
	fake.visiblePipelinesMutex.Unlock()
	if fake.VisiblePipelinesStub != nil {
		return fake.VisiblePipelinesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.visiblePipelinesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) VisiblePipelinesCallCount() int {
	fake.visiblePipelinesMutex.RLock()
	defer fake.visiblePipelinesMutex.RUnlock()
	return len(fake.visiblePipelinesArgsForCall)
}

func (fake *FakeTeam) VisiblePipelinesCalls(stub func() ([]db.Pipeline, error)) {
	fake.visiblePipelinesMutex.Lock()
	defer fake.visiblePipelinesMutex.Unlock()
	fake.VisiblePipelinesStub = stub
}

func (fake *FakeTeam) VisiblePipelinesReturns(result1 []db.Pipeline, result2 error) {
	fake.visiblePipelinesMutex.Lock()
	defer fake.visiblePipelinesMutex.Unlock()
	fake.VisiblePipelinesStub = nil
	fake.visiblePipelinesReturns = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) VisiblePipelinesReturnsOnCall(i int, result1 []db.Pipeline, result2 error) {
	fake.visiblePipelinesMutex.Lock()
	defer fake.visiblePipelinesMutex.Unlock()
	fake.VisiblePipelinesStub = nil
	if fake.visiblePipelinesReturnsOnCall == nil {
		fake.visiblePipelinesReturnsOnCall = make(map[int]struct {
			result1 []db.Pipeline
			result2 error
		})
	}
	fake.visiblePipelinesReturnsOnCall[i] = struct {
		result1 []db.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Workers() ([]db.Worker, error) {
	fake.workersMutex.Lock()
	ret, specificReturn := fake.workersReturnsOnCall[len(fake.workersArgsForCall)]
	fake.workersArgsForCall = append(fake.workersArgsForCall, struct {
	}{})
	fake.recordInvocation("Workers", []interface{}{})
	fake.workersMutex.Unlock()
	if fake.WorkersStub != nil {
		return fake.WorkersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.workersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeam) WorkersCallCount() int {
	fake.workersMutex.RLock()
	defer fake.workersMutex.RUnlock()
	return len(fake.workersArgsForCall)
}

func (fake *FakeTeam) WorkersCalls(stub func() ([]db.Worker, error)) {
	fake.workersMutex.Lock()
	defer fake.workersMutex.Unlock()
	fake.WorkersStub = stub
}

func (fake *FakeTeam) WorkersReturns(result1 []db.Worker, result2 error) {
	fake.workersMutex.Lock()
	defer fake.workersMutex.Unlock()
	fake.WorkersStub = nil
	fake.workersReturns = struct {
		result1 []db.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) WorkersReturnsOnCall(i int, result1 []db.Worker, result2 error) {
	fake.workersMutex.Lock()
	defer fake.workersMutex.Unlock()
	fake.WorkersStub = nil
	if fake.workersReturnsOnCall == nil {
		fake.workersReturnsOnCall = make(map[int]struct {
			result1 []db.Worker
			result2 error
		})
	}
	fake.workersReturnsOnCall[i] = struct {
		result1 []db.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.adminMutex.RLock()
	defer fake.adminMutex.RUnlock()
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	fake.containersMutex.RLock()
	defer fake.containersMutex.RUnlock()
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	fake.createStartedBuildMutex.RLock()
	defer fake.createStartedBuildMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.findCheckContainersMutex.RLock()
	defer fake.findCheckContainersMutex.RUnlock()
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	fake.findContainersByMetadataMutex.RLock()
	defer fake.findContainersByMetadataMutex.RUnlock()
	fake.findCreatedContainerByHandleMutex.RLock()
	defer fake.findCreatedContainerByHandleMutex.RUnlock()
	fake.findVolumeForWorkerArtifactMutex.RLock()
	defer fake.findVolumeForWorkerArtifactMutex.RUnlock()
	fake.findWorkerForContainerMutex.RLock()
	defer fake.findWorkerForContainerMutex.RUnlock()
	fake.findWorkerForVolumeMutex.RLock()
	defer fake.findWorkerForVolumeMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.isCheckContainerMutex.RLock()
	defer fake.isCheckContainerMutex.RUnlock()
	fake.isContainerWithinTeamMutex.RLock()
	defer fake.isContainerWithinTeamMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.orderPipelinesMutex.RLock()
	defer fake.orderPipelinesMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.pipelinesMutex.RLock()
	defer fake.pipelinesMutex.RUnlock()
	fake.privateAndPublicBuildsMutex.RLock()
	defer fake.privateAndPublicBuildsMutex.RUnlock()
	fake.publicPipelinesMutex.RLock()
	defer fake.publicPipelinesMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.savePipelineMutex.RLock()
	defer fake.savePipelineMutex.RUnlock()
	fake.saveWorkerMutex.RLock()
	defer fake.saveWorkerMutex.RUnlock()
	fake.updateProviderAuthMutex.RLock()
	defer fake.updateProviderAuthMutex.RUnlock()
	fake.visiblePipelinesMutex.RLock()
	defer fake.visiblePipelinesMutex.RUnlock()
	fake.workersMutex.RLock()
	defer fake.workersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTeam) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Team = new(FakeTeam)
