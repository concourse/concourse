package main

import (
	"crypto/rand"
	"crypto/rsa"
	"fmt"
	"os"

	"github.com/concourse/flag"
	flags "github.com/jessevdk/go-flags"
	"github.com/tedsuo/ifrit"
	"github.com/tedsuo/ifrit/grouper"
	"github.com/tedsuo/ifrit/sigmon"
	"golang.org/x/crypto/ssh"
)

type QuickstartCommand struct {
	*WebCommand    `group:"Web Configuration"`
	*WorkerCommand `group:"Worker Configuration" namespace:"worker"`
}

func (cmd QuickstartCommand) lessenRequirements(command *flags.Command) {
	cmd.WebCommand.lessenRequirements(command)
	cmd.WorkerCommand.lessenRequirements("worker-", command)

	// autogenerated
	command.FindOptionByLongName("session-signing-key").Required = false
	command.FindOptionByLongName("tsa-authorized-keys").Required = false
	command.FindOptionByLongName("tsa-host-key").Required = false
}

func (cmd *QuickstartCommand) Execute(args []string) error {
	runner, err := cmd.Runner(args)
	if err != nil {
		return err
	}

	return <-ifrit.Invoke(sigmon.New(runner)).Wait()
}

func (cmd *QuickstartCommand) Runner(args []string) (ifrit.Runner, error) {
	if cmd.WebCommand.ATCCommand.SessionSigningKey == nil || cmd.WebCommand.TSACommand.SessionSigningKey.PrivateKey == nil {
		signingKey, err := rsa.GenerateKey(rand.Reader, 2048)
		if err != nil {
			return nil, fmt.Errorf("failed to generate session signing key: %s", err)
		}

		cmd.WebCommand.ATCCommand.SessionSigningKey = &flag.PrivateKey{PrivateKey: signingKey}
		cmd.WebCommand.TSACommand.SessionSigningKey = &flag.PrivateKey{PrivateKey: signingKey}
	}

	if cmd.WebCommand.TSACommand.HostKey == nil || cmd.WebCommand.TSACommand.HostKey.PrivateKey == nil {
		tsaHostKey, err := rsa.GenerateKey(rand.Reader, 2048)
		if err != nil {
			return nil, fmt.Errorf("failed to generate tsa host key: %s", err)
		}

		tsaHostPublicKey, err := ssh.NewPublicKey(tsaHostKey.Public())
		if err != nil {
			return nil, fmt.Errorf("failed to create worker authorized key: %s", err)
		}

		cmd.WebCommand.TSACommand.HostKey = &flag.PrivateKey{PrivateKey: tsaHostKey}
		cmd.WorkerCommand.TSA.PublicKey.Keys =
			append(cmd.WorkerCommand.TSA.PublicKey.Keys, tsaHostPublicKey)
	}

	if cmd.WorkerCommand.TSA.WorkerPrivateKey == nil || cmd.WorkerCommand.TSA.WorkerPrivateKey.PrivateKey == nil {
		workerKey, err := rsa.GenerateKey(rand.Reader, 2048)
		if err != nil {
			return nil, fmt.Errorf("failed to generate worker key: %s", err)
		}

		workerPublicKey, err := ssh.NewPublicKey(workerKey.Public())
		if err != nil {
			return nil, fmt.Errorf("failed to create worker authorized key: %s", err)
		}

		cmd.WorkerCommand.TSA.WorkerPrivateKey = &flag.PrivateKey{PrivateKey: workerKey}
		cmd.WebCommand.TSACommand.AuthorizedKeys.Keys =
			append(cmd.WebCommand.TSACommand.AuthorizedKeys.Keys, workerPublicKey)
	}

	webRunner, err := cmd.WebCommand.Runner(args)
	if err != nil {
		return nil, err
	}

	workerRunner, err := cmd.WorkerCommand.Runner(args)
	if err != nil {
		return nil, err
	}

	return grouper.NewParallel(os.Interrupt, grouper.Members{
		{Name: "web", Runner: webRunner},
		{Name: "worker", Runner: workerRunner},
	}), nil
}
